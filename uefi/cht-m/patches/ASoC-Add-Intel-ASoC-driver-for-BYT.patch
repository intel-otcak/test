From 0de1c591ec4cf93e24980507da1c4509b180ade7 Mon Sep 17 00:00:00 2001
From: "ola.lilja" <ola.lilja@intel.com>
Date: Thu, 15 May 2014 17:57:58 +0200
Subject: ASoC: Add Intel ASoC-driver for BYT

Add the whole platform- and machine-driver
for Intel audio, including Baytrail-
architecture.

Issue: GMIN-495
Change-Id: Ic72cd91ed7731e8f3065bc533e6d8b90855b2560
Signed-off-by: ola.lilja <ola.lilja@intel.com>
---
 arch/x86/include/asm/intel_sst_mrfld.h             |   40 +
 arch/x86/include/asm/platform_byt_audio.h          |   58 +
 arch/x86/include/asm/platform_sst.h                |  133 ++
 arch/x86/include/asm/platform_sst_audio.h          |  237 +++
 arch/x86/platform/intel-mid/device_libs/Makefile   |    2 +
 .../intel-mid/device_libs/platform_byt_audio.c     |   32 +
 .../intel-mid/device_libs/platform_sst_audio.c     |  384 ++++
 include/linux/lnw_gpio.h                           |   13 +
 include/linux/sst_trace.h                          |  143 ++
 include/sound/intel_sst_ioctl.h                    |    4 -
 include/trace/sst_trace.h                          |  143 ++
 sound/soc/intel/Kconfig                            |   41 +
 sound/soc/intel/Makefile                           |   19 +
 sound/soc/intel/board/Makefile                     |   12 +
 sound/soc/intel/board/byt_cr_dpcm_rt5640.c         | 1082 +++++++++++
 sound/soc/intel/compress.c                         |  250 +++
 sound/soc/intel/effects.c                          |  402 ++++
 sound/soc/intel/pcm.c                              | 1119 +++++++++++
 sound/soc/intel/platform-libs/controls_v2.c        | 1763 +++++++++++++++++
 sound/soc/intel/platform-libs/controls_v2.h        |  705 +++++++
 sound/soc/intel/platform-libs/controls_v2_dpcm.c   | 1979 +++++++++++++++++++
 sound/soc/intel/platform-libs/ipc_lib.h            |   29 +
 sound/soc/intel/platform-libs/ipc_lib_v2.c         |  105 +
 sound/soc/intel/platform-libs/probe_point_dpcm.c   |  172 ++
 sound/soc/intel/platform-libs/sst_widgets.h        |  352 ++++
 sound/soc/intel/platform_ipc_v2.h                  |  690 +++++++
 sound/soc/intel/sst/Makefile                       |   14 +
 sound/soc/intel/sst/sst.c                          | 1297 +++++++++++++
 sound/soc/intel/sst/sst.h                          |  933 +++++++++
 sound/soc/intel/sst/sst_acpi.c                     |  711 +++++++
 sound/soc/intel/sst/sst_app_compat_interface.c     |   81 +
 sound/soc/intel/sst/sst_app_interface.c            |  338 ++++
 sound/soc/intel/sst/sst_debug.c                    | 1368 +++++++++++++
 sound/soc/intel/sst/sst_drv_interface.c            | 1117 +++++++++++
 sound/soc/intel/sst/sst_dsp.c                      | 2008 ++++++++++++++++++++
 sound/soc/intel/sst/sst_ipc.c                      |  772 ++++++++
 sound/soc/intel/sst/sst_pvt.c                      |  572 ++++++
 sound/soc/intel/sst/sst_stream.c                   |  827 ++++++++
 sound/soc/intel/sst/sst_trace.h                    |  143 ++
 sound/soc/intel/sst_platform.h                     |  151 ++
 sound/soc/intel/sst_platform_pvt.h                 |  141 ++
 41 files changed, 20378 insertions(+), 4 deletions(-)
 create mode 100644 arch/x86/include/asm/intel_sst_mrfld.h
 create mode 100644 arch/x86/include/asm/platform_byt_audio.h
 create mode 100644 arch/x86/include/asm/platform_sst.h
 create mode 100644 arch/x86/include/asm/platform_sst_audio.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_byt_audio.c
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_sst_audio.c
 create mode 100644 include/linux/lnw_gpio.h
 create mode 100644 include/linux/sst_trace.h
 create mode 100644 include/trace/sst_trace.h
 create mode 100644 sound/soc/intel/Kconfig
 create mode 100644 sound/soc/intel/Makefile
 create mode 100644 sound/soc/intel/board/Makefile
 create mode 100644 sound/soc/intel/board/byt_cr_dpcm_rt5640.c
 create mode 100644 sound/soc/intel/compress.c
 create mode 100644 sound/soc/intel/effects.c
 create mode 100644 sound/soc/intel/pcm.c
 create mode 100644 sound/soc/intel/platform-libs/controls_v2.c
 create mode 100644 sound/soc/intel/platform-libs/controls_v2.h
 create mode 100644 sound/soc/intel/platform-libs/controls_v2_dpcm.c
 create mode 100644 sound/soc/intel/platform-libs/ipc_lib.h
 create mode 100644 sound/soc/intel/platform-libs/ipc_lib_v2.c
 create mode 100644 sound/soc/intel/platform-libs/probe_point_dpcm.c
 create mode 100644 sound/soc/intel/platform-libs/sst_widgets.h
 create mode 100644 sound/soc/intel/platform_ipc_v2.h
 create mode 100644 sound/soc/intel/sst/Makefile
 create mode 100644 sound/soc/intel/sst/sst.c
 create mode 100644 sound/soc/intel/sst/sst.h
 create mode 100644 sound/soc/intel/sst/sst_acpi.c
 create mode 100644 sound/soc/intel/sst/sst_app_compat_interface.c
 create mode 100644 sound/soc/intel/sst/sst_app_interface.c
 create mode 100644 sound/soc/intel/sst/sst_debug.c
 create mode 100644 sound/soc/intel/sst/sst_drv_interface.c
 create mode 100644 sound/soc/intel/sst/sst_dsp.c
 create mode 100644 sound/soc/intel/sst/sst_ipc.c
 create mode 100644 sound/soc/intel/sst/sst_pvt.c
 create mode 100644 sound/soc/intel/sst/sst_stream.c
 create mode 100644 sound/soc/intel/sst/sst_trace.h
 create mode 100644 sound/soc/intel/sst_platform.h
 create mode 100644 sound/soc/intel/sst_platform_pvt.h

diff --git a/arch/x86/include/asm/intel_sst_mrfld.h b/arch/x86/include/asm/intel_sst_mrfld.h
new file mode 100644
index 0000000..fda1e84
--- /dev/null
+++ b/arch/x86/include/asm/intel_sst_mrfld.h
@@ -0,0 +1,40 @@
+/* intel_sst_mrlfd.h - Common enum of the Merrifield platform
+ *
+ *  Copyright (C) 2013 Intel Corp
+ *  Author: Samreen Nilofer <samreen.nilofer@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+#ifndef _INTEL_SST_MRFLD_H
+#define _INTEL_SST_MRFLD_H
+
+enum {
+	MERR_SALTBAY_AUDIO = 0,
+	MERR_SALTBAY_COMPR,
+	MERR_SALTBAY_VOIP,
+	MERR_SALTBAY_PROBE,
+	MERR_SALTBAY_AWARE,
+	MERR_SALTBAY_VAD,
+	MERR_SALTBAY_POWER,
+};
+
+enum {
+	MERR_DPCM_AUDIO = 0,
+	MERR_DPCM_DB,
+	MERR_DPCM_LL,
+	MERR_DPCM_COMPR,
+	MERR_DPCM_VOIP,
+	MERR_DPCM_PROBE,
+};
+
+#endif
diff --git a/arch/x86/include/asm/platform_byt_audio.h b/arch/x86/include/asm/platform_byt_audio.h
new file mode 100644
index 0000000..d24b6f3
--- /dev/null
+++ b/arch/x86/include/asm/platform_byt_audio.h
@@ -0,0 +1,58 @@
+/*
+ * platform_byt_audio.h: Baytrail audio platform data header file
+ *
+ * (C) Copyright 2013 Intel Corporation
+ * Author: Omair Md Abdullah <omair.m.abdullah@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_BYT_AUDIO_H_
+#define _PLATFORM_BYT_AUDIO_H_
+
+enum {
+	BYT_AUD_AIF1 = 0,
+	BYT_AUD_AIF2,
+	BYT_AUD_COMPR_DEV,
+#ifdef CONFIG_SND_SOC_COMMS_SSP
+	BYT_COMMS_BT,
+	BYT_COMMS_MODEM,
+#endif /* CONFIG_SND_SOC_COMMS_SSP */
+	BYT_AUD_PROBE_DEV,
+};
+
+enum {
+	BYT_DPCM_AUD_AIF1 = 0,
+	BYT_DPCM_DB,
+	BYT_DPCM_LL,
+	BYT_DPCM_COMPR,
+	BYT_DPCM_VOIP,
+	BYT_DPCM_PROBE,
+};
+
+enum {
+	BYT_CR_AUD_AIF1 = 0,
+	BYT_CR_AUD_COMPR_DEV,
+	BYT_CR_COMMS_BT,
+};
+/* LPE viewpoint addresses */
+/* TODO: move to DSDT */
+#define SST_BYT_IRAM_PHY_START	0xff2c0000
+#define SST_BYT_IRAM_PHY_END	0xff2d4000
+#define SST_BYT_DRAM_PHY_START	0xff300000
+#define SST_BYT_DRAM_PHY_END	0xff320000
+#define SST_BYT_IMR_VIRT_START	0xc0000000 /* virtual addr in LPE */
+#define SST_BYT_IMR_VIRT_END	0xc01fffff
+#define SST_BYT_SHIM_PHY_ADDR	0xff340000
+#define SST_BYT_MBOX_PHY_ADDR	0xff344000
+#define SST_BYT_DMA0_PHY_ADDR	0xff298000
+#define SST_BYT_DMA1_PHY_ADDR	0xff29c000
+#define SST_BYT_SSP0_PHY_ADDR	0xff2a0000
+#define SST_BYT_SSP2_PHY_ADDR	0xff2a2000
+
+#define BYT_FW_MOD_TABLE_OFFSET 0x80000
+#define BYT_FW_MOD_TABLE_SIZE   0x100
+
+#endif
diff --git a/arch/x86/include/asm/platform_sst.h b/arch/x86/include/asm/platform_sst.h
new file mode 100644
index 0000000..12fa1a6
--- /dev/null
+++ b/arch/x86/include/asm/platform_sst.h
@@ -0,0 +1,133 @@
+
+/*
+ * platform_sst.h:  sst audio platform data header file
+ *
+ * Copyright (C) 2013 Intel Corporation
+ * Author: Dharageswari R <dharageswari.r@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#ifndef _PLATFORM_SST_H_
+#define _PLATFORM_SST_H_
+
+#include <linux/sfi.h>
+
+#define MAX_NUM_STREAMS_CTP	5
+#define MAX_NUM_STREAMS_MRFLD	25
+#define MAX_NUM_STREAMS	MAX_NUM_STREAMS_MRFLD
+
+#define SST_MAX_SSP_PORTS 4
+#define SST_MAX_DMA 2
+
+enum {
+	SST_SSP_AUDIO = 0,
+	SST_SSP_MODEM,
+	SST_SSP_BT,
+	SST_SSP_FM,
+};
+
+struct sst_gpio_config {
+	u32 i2s_rx_alt;
+	u32 i2s_tx_alt;
+	u32 i2s_frame;
+	u32 i2s_clock;
+	u32 alt_function;
+};
+
+struct sst_ssp_info {
+	u32 base_add;
+	struct sst_gpio_config gpio;
+	bool gpio_in_use;
+};
+
+struct sst_info {
+	u32 iram_start;
+	u32 iram_end;
+	bool iram_use;
+	u32 dram_start;
+	u32 dram_end;
+	bool dram_use;
+	u32 imr_start;
+	u32 imr_end;
+	bool imr_use;
+	u32 mailbox_start;
+	bool use_elf;
+	bool lpe_viewpt_rqd;
+	unsigned int max_streams;
+	u32 dma_max_len;
+	u8 num_probes;
+};
+
+struct sst_ssp_platform_cfg {
+	u8 ssp_cfg_sst;
+	u8 port_number;
+	u8 is_master;
+	u8 pack_mode;
+	u8 num_slots_per_frame;
+	u8 num_bits_per_slot;
+	u8 active_tx_map;
+	u8 active_rx_map;
+	u8 ssp_frame_format;
+	u8 frame_polarity;
+	u8 serial_bitrate_clk_mode;
+	u8 frame_sync_width;
+	u8 dma_handshake_interface_tx;
+	u8 dma_handshake_interface_rx;
+	u8 network_mode;
+	u8 start_delay;
+	u32 ssp_base_add;
+} __packed;
+
+struct sst_board_config_data {
+	struct sst_ssp_platform_cfg ssp_platform_data[SST_MAX_SSP_PORTS];
+	u8 active_ssp_ports;
+	u8 platform_id;
+	u8 board_id;
+	u8 ihf_num_chan;
+	u32 osc_clk_freq;
+} __packed;
+
+struct sst_platform_config_data {
+	u32 sst_sram_buff_base;
+	u32 sst_dma_base[SST_MAX_DMA];
+} __packed;
+
+struct sst_platform_debugfs_data {
+	u32 ssp_reg_size;
+	u32 dma_reg_size;
+	u32 checkpoint_offset;
+	u32 checkpoint_size;
+	u8 num_ssp;
+	u8 num_dma;
+};
+
+struct sst_ipc_info {
+	int ipc_offset;
+	bool use_32bit_ops;
+	unsigned int mbox_recv_off;
+};
+
+struct sst_lib_dnld_info {
+	unsigned int mod_base;
+	unsigned int mod_end;
+	unsigned int mod_table_offset;
+	unsigned int mod_table_size;
+	bool mod_ddr_dnld;
+};
+
+struct sst_platform_info {
+	const struct sst_info *probe_data;
+	const struct sst_ssp_info *ssp_data;
+	const struct sst_board_config_data *bdata;
+	const struct sst_platform_config_data *pdata;
+	const struct sst_ipc_info *ipc_info;
+	const struct sst_platform_debugfs_data *debugfs_data;
+	const struct sst_lib_dnld_info *lib_info;
+	bool enable_recovery;
+};
+
+#endif
diff --git a/arch/x86/include/asm/platform_sst_audio.h b/arch/x86/include/asm/platform_sst_audio.h
new file mode 100644
index 0000000..85bee41
--- /dev/null
+++ b/arch/x86/include/asm/platform_sst_audio.h
@@ -0,0 +1,237 @@
+/*
+ * platform_sst_audio.h:  sst audio platform data header file
+ *
+ * Copyright (C) 2012 Intel Corporation
+ * Author: Jeeja KP <jeeja.kp@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_SST_AUDIO_H_
+#define _PLATFORM_SST_AUDIO_H_
+
+#include <linux/sfi.h>
+
+/* The stream map status is used to dynamically assign
+ * device-id to a device, for example probe device. If
+ * a stream map entry is free for a device then the device-id
+ * for that device will be popluated when the device is
+ * opened and then the status set to IN_USE. When device
+ * is closed, the strm map status is set to FREE again.
+ */
+enum sst_strm_map_status {
+	SST_DEV_MAP_FREE = 0,
+	SST_DEV_MAP_IN_USE,
+};
+
+/* Device IDs for CTP are same as stream IDs */
+enum sst_audio_device_id_ctp {
+	SST_PCM_OUT0 = 1,
+	SST_PCM_OUT1 = 2,
+	SST_COMPRESSED_OUT = 3,
+	SST_CAPTURE_IN = 4,
+	SST_PROBE_IN = 5,
+};
+
+enum sst_audio_task_id_mrfld {
+	SST_TASK_ID_NONE = 0,
+	SST_TASK_ID_SBA = 1,
+	SST_TASK_ID_FBA_UL = 2,
+	SST_TASK_ID_MEDIA = 3,
+	SST_TASK_ID_AWARE = 4,
+	SST_TASK_ID_FBA_DL = 5,
+	SST_TASK_ID_MAX = SST_TASK_ID_FBA_DL,
+};
+
+/* Device IDs for Merrifield are Pipe IDs,
+ * ref: LPE DSP command interface spec v0.75 */
+enum sst_audio_device_id_mrfld {
+	/* Output pipeline IDs */
+	PIPE_ID_OUT_START = 0x0,
+	PIPE_MODEM_OUT = 0x0,
+	PIPE_BT_OUT = 0x1,
+	PIPE_CODEC_OUT0 = 0x2,
+	PIPE_CODEC_OUT1 = 0x3,
+	PIPE_SPROT_LOOP_OUT = 0x4,
+	PIPE_MEDIA_LOOP1_OUT = 0x5,
+	PIPE_MEDIA_LOOP2_OUT = 0x6,
+	PIPE_PROBE_OUT = 0x7,
+	PIPE_HF_SNS_OUT = 0x8, /* VOCIE_UPLINK_REF2 */
+	PIPE_HF_OUT = 0x9, /* VOICE_UPLINK_REF1 */
+	PIPE_SPEECH_OUT = 0xA, /* VOICE UPLINK */
+	PIPE_RxSPEECH_OUT = 0xB, /* VOICE_DOWNLINK */
+	PIPE_VOIP_OUT = 0xC,
+	PIPE_PCM0_OUT = 0xD,
+	PIPE_PCM1_OUT = 0xE,
+	PIPE_PCM2_OUT = 0xF,
+	PIPE_AWARE_OUT = 0x10,
+	PIPE_VAD_OUT = 0x11,
+	PIPE_MEDIA0_OUT = 0x12,
+	PIPE_MEDIA1_OUT = 0x13,
+	PIPE_FM_OUT = 0x14,
+	PIPE_PROBE1_OUT = 0x15,
+	PIPE_PROBE2_OUT = 0x16,
+	PIPE_PROBE3_OUT = 0x17,
+	PIPE_PROBE4_OUT = 0x18,
+	PIPE_PROBE5_OUT = 0x19,
+	PIPE_PROBE6_OUT = 0x1A,
+	PIPE_PROBE7_OUT = 0x1B,
+	PIPE_PROBE8_OUT = 0x1C,
+/* Input Pipeline IDs */
+	PIPE_ID_IN_START = 0x80,
+	PIPE_MODEM_IN = 0x80,
+	PIPE_BT_IN = 0x81,
+	PIPE_CODEC_IN0 = 0x82,
+	PIPE_CODEC_IN1 = 0x83,
+	PIPE_SPROT_LOOP_IN = 0x84,
+	PIPE_MEDIA_LOOP1_IN = 0x85,
+	PIPE_MEDIA_LOOP2_IN = 0x86,
+	PIPE_PROBE_IN = 0x87,
+	PIPE_SIDETONE_IN = 0x88,
+	PIPE_TxSPEECH_IN = 0x89,
+	PIPE_SPEECH_IN = 0x8A,
+	PIPE_TONE_IN = 0x8B,
+	PIPE_VOIP_IN = 0x8C,
+	PIPE_PCM0_IN = 0x8D,
+	PIPE_PCM1_IN = 0x8E,
+	PIPE_MEDIA0_IN = 0x8F,
+	PIPE_MEDIA1_IN = 0x90,
+	PIPE_MEDIA2_IN = 0x91,
+	PIPE_FM_IN = 0x92,
+	PIPE_PROBE1_IN = 0x93,
+	PIPE_PROBE2_IN = 0x94,
+	PIPE_PROBE3_IN = 0x95,
+	PIPE_PROBE4_IN = 0x96,
+	PIPE_PROBE5_IN = 0x97,
+	PIPE_PROBE6_IN = 0x98,
+	PIPE_PROBE7_IN = 0x99,
+	PIPE_PROBE8_IN = 0x9A,
+	PIPE_MEDIA3_IN = 0x9C,
+	PIPE_LOW_PCM0_IN = 0x9D,
+	PIPE_RSVD = 0xFF,
+};
+
+enum sst_ssp_mode {
+	SSP_MODE_MASTER = 0,
+	SSP_MODE_SLAVE = 1,
+};
+
+enum sst_ssp_pcm_mode {
+	SSP_PCM_MODE_NORMAL = 0,
+	SSP_PCM_MODE_NETWORK = 1,
+};
+
+enum sst_ssp_duplex {
+	SSP_DUPLEX = 0,
+	SSP_RX = 1,
+	SSP_TX = 2,
+};
+
+enum sst_ssp_fs_frequency {
+	SSP_FS_8_KHZ = 0,
+	SSP_FS_16_KHZ = 1,
+	SSP_FS_44_1_KHZ = 2,
+	SSP_FS_48_KHZ = 3,
+};
+
+enum sst_ssp_fs_polarity {
+	SSP_FS_ACTIVE_LOW = 0,
+	SSP_FS_ACTIVE_HIGH = 1,
+};
+
+enum sst_ssp_protocol {
+	SSP_MODE_PCM = 0,
+	SSP_MODE_I2S = 1,
+};
+
+enum sst_ssp_port_id {
+	SSP_MODEM = 0,
+	SSP_BT = 1,
+	SSP_FM = 2,
+	SSP_CODEC = 3,
+};
+/* physical SSP numbers */
+enum {
+	SST_SSP0 = 0,
+	SST_SSP1,
+	SST_SSP2,
+	SST_SSP_LAST = SST_SSP2,
+};
+
+#define SST_NUM_SSPS		(SST_SSP_LAST + 1)	/* physical SSPs */
+#define SST_MAX_SSP_MUX		2			/* single SSP muxed between pipes */
+#define SST_MAX_SSP_DOMAINS	2			/* domains present in each pipe */
+#define SST_BT_FM_MUX_SHIFT	0
+#define SST_VOICE_MODE_SHIFT	1
+#define SST_BT_MODE_SHIFT	2
+
+#define SST_SSP_FM_MUX			0
+#define SST_SSP_FM_DOMAIN		0
+#define SST_SSP_BT_MUX			1
+
+struct sst_ssp_config {
+	u8 ssp_id;
+	u8 bits_per_slot;
+	u8 slots;
+	u8 ssp_mode;
+	u8 pcm_mode;
+	u8 data_polarity;
+	u8 duplex;
+	u8 ssp_protocol;
+	u8 fs_frequency;
+	u8 active_slot_map;
+	u8 start_delay;
+	u16 fs_width;
+};
+
+/* The stream map for each platform consists of an array of the below
+ * stream map structure. The array index is used as the static stream-id
+ * associated with a device and (dev_num,subdev_num,direction) tuple match
+ * gives the device_id for the device.
+ */
+struct sst_dev_stream_map {
+	u8 dev_num;
+	u8 subdev_num;
+	u8 direction;
+	u8 device_id;
+	u8 task_id;
+	u8 status;
+};
+
+#define MAX_DESCRIPTOR_SIZE 172
+
+struct sst_dev_effects_map {
+	char	uuid[16];
+	u16	algo_id;
+	char	descriptor[MAX_DESCRIPTOR_SIZE];
+};
+
+struct sst_dev_effects_resource_map {
+	char  uuid[16];
+	unsigned int flags;
+	u16 cpuLoad;
+	u16 memoryUsage;
+};
+
+struct sst_dev_effects {
+	struct sst_dev_effects_map *effs_map;
+	struct sst_dev_effects_resource_map *effs_res_map;
+	unsigned int effs_num_map;
+};
+
+struct sst_platform_data {
+	/* Intel software platform id*/
+	const struct soft_platform_id *spid;
+	struct sst_dev_stream_map *pdev_strm_map;
+	struct sst_dev_effects pdev_effs;
+	unsigned int strm_map_size;
+	int mux_shift[SST_NUM_SSPS];
+	const int domain_shift[SST_NUM_SSPS][SST_MAX_SSP_MUX];
+	const struct sst_ssp_config ssp_config[SST_NUM_SSPS][SST_MAX_SSP_MUX][SST_MAX_SSP_DOMAINS];
+};
+
+int add_sst_platform_device(void);
+#endif
+
diff --git a/arch/x86/platform/intel-mid/device_libs/Makefile b/arch/x86/platform/intel-mid/device_libs/Makefile
index 17e3f3f..c83d772 100644
--- a/arch/x86/platform/intel-mid/device_libs/Makefile
+++ b/arch/x86/platform/intel-mid/device_libs/Makefile
@@ -1,5 +1,7 @@
 # IPC Devices
 #obj-y += platform_ipc.o
+obj-y += platform_sst_audio.o
+obj-$(subst m,y,$(CONFIG_SND_BYT_MACHINE)) += platform_byt_audio.o
 obj-$(subst m,y,$(CONFIG_MFD_INTEL_MSIC)) += platform_msic.o
 obj-$(subst m,y,$(CONFIG_SND_MFLD_MACHINE)) += platform_msic_audio.o
 obj-$(subst m,y,$(CONFIG_GPIO_MSIC)) += platform_msic_gpio.o
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_byt_audio.c b/arch/x86/platform/intel-mid/device_libs/platform_byt_audio.c
new file mode 100644
index 0000000..08cd54f
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_byt_audio.c
@@ -0,0 +1,32 @@
+/*
+ * platform_byt_audio.c: Baytrail audio platform data initilization file
+ *
+ * (C) Copyright 2013 Intel Corporation
+ * Author: Omair Md Abudllah <omair.m.abdullah@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/platform_sst_audio.h>
+
+static int __init byt_audio_platform_init(void)
+{
+	struct platform_device *pdev;
+	int ret;
+
+	pr_err("in %s\n", __func__);
+
+	ret = add_sst_platform_device();
+	if (ret < 0) {
+		pr_err("%s failed to sst_platform device\n", __func__);
+		return 0;
+	}
+
+	return 0;
+}
+device_initcall(byt_audio_platform_init);
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_sst_audio.c b/arch/x86/platform/intel-mid/device_libs/platform_sst_audio.c
new file mode 100644
index 0000000..7eebafa
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_sst_audio.c
@@ -0,0 +1,384 @@
+/*
+ * platform_sst_libs.c: SST platform  data initilization file
+ *
+ * Copyright (C) 2012 Intel Corporation
+ * Author: Jeeja KP <jeeja.kp@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/sfi.h>
+#include <linux/platform_device.h>
+#include <asm/platform_sst_audio.h>
+#include <asm/intel-mid.h>
+#include <asm/intel_sst_mrfld.h>
+#include <asm/platform_byt_audio.h>
+#include <sound/asound.h>
+
+static struct sst_platform_data sst_platform_pdata;
+static struct sst_dev_stream_map byt_bl_strm_map[] = {
+	{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, /* Reserved, not in use */
+	{BYT_AUD_AIF1, 0, SNDRV_PCM_STREAM_PLAYBACK, SST_PCM_OUT0, SST_TASK_ID_NONE, SST_DEV_MAP_IN_USE},
+	{BYT_AUD_AIF1, 1, SNDRV_PCM_STREAM_PLAYBACK, SST_PCM_OUT1, SST_TASK_ID_NONE, SST_DEV_MAP_IN_USE},
+	{BYT_AUD_COMPR_DEV, 0, SNDRV_PCM_STREAM_PLAYBACK, SST_COMPRESSED_OUT,
+					SST_TASK_ID_NONE, SST_DEV_MAP_IN_USE},
+	{BYT_AUD_AIF1, 0, SNDRV_PCM_STREAM_CAPTURE, SST_CAPTURE_IN, SST_TASK_ID_NONE, SST_DEV_MAP_IN_USE},
+};
+static struct sst_dev_stream_map byt_cr_strm_map[] = {
+	{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, /* Reserved, not in use */
+	{BYT_CR_AUD_AIF1, 0, SNDRV_PCM_STREAM_PLAYBACK, SST_PCM_OUT0, SST_TASK_ID_NONE, SST_DEV_MAP_IN_USE},
+	{BYT_CR_AUD_AIF1, 1, SNDRV_PCM_STREAM_PLAYBACK, SST_PCM_OUT1, SST_TASK_ID_NONE, SST_DEV_MAP_IN_USE},
+	{BYT_CR_AUD_COMPR_DEV, 0, SNDRV_PCM_STREAM_PLAYBACK, SST_COMPRESSED_OUT,
+					SST_TASK_ID_NONE, SST_DEV_MAP_IN_USE},
+	{BYT_CR_AUD_AIF1, 0, SNDRV_PCM_STREAM_CAPTURE, SST_CAPTURE_IN, SST_TASK_ID_NONE, SST_DEV_MAP_IN_USE},
+};
+
+static struct sst_dev_stream_map mrfld_strm_map[] = {
+	{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, /* Reserved, not in use */
+	{MERR_SALTBAY_AUDIO, 0, SNDRV_PCM_STREAM_PLAYBACK, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_AUDIO, 1, SNDRV_PCM_STREAM_PLAYBACK, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_AUDIO, 2, SNDRV_PCM_STREAM_PLAYBACK, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_COMPR, 0, SNDRV_PCM_STREAM_PLAYBACK, PIPE_MEDIA0_IN, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_SALTBAY_VOIP, 0, SNDRV_PCM_STREAM_PLAYBACK, PIPE_VOIP_IN, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_SALTBAY_AUDIO, 0, SNDRV_PCM_STREAM_CAPTURE, PIPE_PCM1_OUT, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_SALTBAY_VOIP, 0, SNDRV_PCM_STREAM_CAPTURE, PIPE_VOIP_OUT, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_SALTBAY_PROBE, 0, SNDRV_PCM_STREAM_CAPTURE, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_PROBE, 1, SNDRV_PCM_STREAM_CAPTURE, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_PROBE, 2, SNDRV_PCM_STREAM_CAPTURE, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_PROBE, 3, SNDRV_PCM_STREAM_CAPTURE, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_PROBE, 4, SNDRV_PCM_STREAM_CAPTURE, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_PROBE, 5, SNDRV_PCM_STREAM_CAPTURE, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_PROBE, 6, SNDRV_PCM_STREAM_CAPTURE, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_PROBE, 7, SNDRV_PCM_STREAM_CAPTURE, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_PROBE, 0, SNDRV_PCM_STREAM_PLAYBACK, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_PROBE, 1, SNDRV_PCM_STREAM_PLAYBACK, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_PROBE, 2, SNDRV_PCM_STREAM_PLAYBACK, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_PROBE, 3, SNDRV_PCM_STREAM_PLAYBACK, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_PROBE, 4, SNDRV_PCM_STREAM_PLAYBACK, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_PROBE, 5, SNDRV_PCM_STREAM_PLAYBACK, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_PROBE, 6, SNDRV_PCM_STREAM_PLAYBACK, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_PROBE, 7, SNDRV_PCM_STREAM_PLAYBACK, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_AWARE, 0, SNDRV_PCM_STREAM_CAPTURE, PIPE_AWARE_OUT, SST_TASK_ID_AWARE, SST_DEV_MAP_IN_USE},
+	{MERR_SALTBAY_VAD, 0, SNDRV_PCM_STREAM_CAPTURE, PIPE_VAD_OUT, SST_TASK_ID_AWARE, SST_DEV_MAP_IN_USE},
+};
+
+#define EQ_EFFECT_ALGO_ID 0x99
+static struct sst_dev_effects_map mrfld_effs_map[] = {
+	{
+	  {0xc1, 0x47, 0xa2, 0xf7, 0x7b, 0x1a, 0xe0, 0x11, 0x0d, 0xbb, 0x2a, 0x30, 0xdf, 0xd7, 0x20, 0x45},/* uuid */
+	   EQ_EFFECT_ALGO_ID,										   /* algo id */
+	  {0x00, 0x43, 0xed, 0x0b, 0xd6, 0xdd, 0xdb, 0x11, 0x34, 0x8f, 0x00, 0x02, 0xa5, 0xd5, 0xc5, 0x1b, /* descriptor */
+	   0xc1, 0x47, 0xa2, 0xf7, 0x7b, 0x1a, 0xe0, 0x11, 0x0d, 0xbb, 0x2a, 0x30, 0xdf, 0xd7, 0x20, 0x45,
+	   0x12, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x45, 0x71, 0x75, 0x61,
+	   0x6c, 0x69, 0x7a, 0x65, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0x6e, 0x74, 0x65,
+	   0x6c, 0x20, 0x43, 0x6f, 0x72, 0x70, 0x6f, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00,
+	   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+	  },
+	}
+};
+
+static struct sst_dev_effects_resource_map mrfld_effs_res_map[] = {
+	{
+	 {0xc1, 0x47, 0xa2, 0xf7, 0x7b, 0x1a, 0xe0, 0x11, 0x0d, 0xbb, 0x2a, 0x30, 0xdf, 0xd7, 0x20, 0x45}, /* uuid */
+	  0x50, /* Flags */
+	  0x00, /* Cpu load */
+	  0x01, /* Memory Usage */
+	 }
+};
+
+static const int sst_ssp_mux_shift[SST_NUM_SSPS] = {
+	[SST_SSP0] = -1,			/* no register shift, i.e. single mux value */
+	[SST_SSP1] = SST_BT_FM_MUX_SHIFT,
+	[SST_SSP2] = -1,
+};
+
+static const int sst_ssp_domain_shift[SST_NUM_SSPS][SST_MAX_SSP_MUX] = {
+	[SST_SSP0][0] = -1,			/* no domain shift, i.e. single domain */
+	[SST_SSP1] = {
+		[SST_SSP_FM_MUX] = -1,
+		[SST_SSP_BT_MUX] = SST_BT_MODE_SHIFT,
+	},
+	[SST_SSP2][0] = -1,
+};
+
+#define SST_SSP_CODEC_MUX		0
+#define SST_SSP_CODEC_DOMAIN		0
+#define SST_SSP_MODEM_MUX		0
+#define SST_SSP_MODEM_DOMAIN		0
+#define SST_SSP_FM_MUX			0
+#define SST_SSP_FM_DOMAIN		0
+#define SST_SSP_BT_MUX			1
+#define SST_SSP_BT_NB_DOMAIN		0
+#define SST_SSP_BT_WB_DOMAIN		1
+
+/**
+ * sst_ssp_config - contains SSP configuration for different UCs
+ *
+ * The 3-D array contains SSP configuration for different SSPs for different
+ * domains (e.g. NB, WB), as well as muxed SSPs.
+ *
+ * The first dimension has SSP number
+ * The second dimension has SSP Muxing (e.g. BT/FM muxed on same SSP)
+ * The third dimension has SSP domains (e.g. NB/WB for BT)
+ */
+static const struct sst_ssp_config
+sst_ssp_configs_mrfld[SST_NUM_SSPS][SST_MAX_SSP_MUX][SST_MAX_SSP_DOMAINS] = {
+	[SST_SSP0] = {
+		[SST_SSP_MODEM_MUX] = {
+			[SST_SSP_MODEM_DOMAIN] = {
+				.ssp_id = SSP_MODEM,
+				.bits_per_slot = 16,
+				.slots = 1,
+				.ssp_mode = SSP_MODE_MASTER,
+				.pcm_mode = SSP_PCM_MODE_NETWORK,
+				.data_polarity = 1,
+				.duplex = SSP_DUPLEX,
+				.ssp_protocol = SSP_MODE_PCM,
+				.fs_width = 1,
+				.fs_frequency = SSP_FS_48_KHZ,
+				.active_slot_map = 0x1,
+				.start_delay = 1,
+			},
+		},
+	},
+	[SST_SSP1] = {
+		[SST_SSP_FM_MUX] = {
+			[SST_SSP_FM_DOMAIN] = {
+				.ssp_id = SSP_FM,
+				.bits_per_slot = 16,
+				.slots = 2,
+				.ssp_mode = SSP_MODE_MASTER,
+				.pcm_mode = SSP_PCM_MODE_NORMAL,
+				.data_polarity = 1,
+				.duplex = SSP_DUPLEX,
+				.ssp_protocol = SSP_MODE_I2S,
+				.fs_width = 32,
+				.fs_frequency = SSP_FS_48_KHZ,
+				.active_slot_map = 0x3,
+				.start_delay = 0,
+			},
+		},
+		[SST_SSP_BT_MUX] = {
+			[SST_SSP_BT_NB_DOMAIN] = {
+				.ssp_id = SSP_BT,
+				.bits_per_slot = 16,
+				.slots = 1,
+				.ssp_mode = SSP_MODE_MASTER,
+				.pcm_mode = SSP_PCM_MODE_NORMAL,
+				.data_polarity = 1,
+				.duplex = SSP_DUPLEX,
+				.ssp_protocol = SSP_MODE_PCM,
+				.fs_width = 1,
+				.fs_frequency = SSP_FS_8_KHZ,
+				.active_slot_map = 0x1,
+				.start_delay = 1,
+			},
+			[SST_SSP_BT_WB_DOMAIN] = {
+				.ssp_id = SSP_BT,
+				.bits_per_slot = 16,
+				.slots = 1,
+				.ssp_mode = SSP_MODE_MASTER,
+				.pcm_mode = SSP_PCM_MODE_NORMAL,
+				.data_polarity = 1,
+				.duplex = SSP_DUPLEX,
+				.ssp_protocol = SSP_MODE_PCM,
+				.fs_width = 1,
+				.fs_frequency = SSP_FS_16_KHZ,
+				.active_slot_map = 0x1,
+				.start_delay = 1,
+			},
+		},
+	},
+	[SST_SSP2] = {
+		[SST_SSP_CODEC_MUX] = {
+			[SST_SSP_CODEC_DOMAIN] = {
+				.ssp_id = SSP_CODEC,
+				.bits_per_slot = 24,
+				.slots = 4,
+				.ssp_mode = SSP_MODE_MASTER,
+				.pcm_mode = SSP_PCM_MODE_NETWORK,
+				.data_polarity = 1,
+				.duplex = SSP_DUPLEX,
+				.ssp_protocol = SSP_MODE_PCM,
+				.fs_width = 1,
+				.fs_frequency = SSP_FS_48_KHZ,
+				.active_slot_map = 0xF,
+				.start_delay = 0,
+			},
+		},
+	},
+};
+
+static const struct sst_ssp_config
+sst_ssp_configs_cht_cr[SST_NUM_SSPS][SST_MAX_SSP_MUX][SST_MAX_SSP_DOMAINS] = {
+	[SST_SSP0] = {
+		[SST_SSP_MODEM_MUX] = {
+			[SST_SSP_MODEM_DOMAIN] = {
+				.ssp_id = SSP_MODEM,
+				.bits_per_slot = 16,
+				.slots = 1,
+				.ssp_mode = SSP_MODE_MASTER,
+				.pcm_mode = SSP_PCM_MODE_NETWORK,
+				.data_polarity = 1,
+				.duplex = SSP_DUPLEX,
+				.ssp_protocol = SSP_MODE_PCM,
+				.fs_width = 1,
+				.fs_frequency = SSP_FS_48_KHZ,
+				.active_slot_map = 0x1,
+				.start_delay = 1,
+			},
+		},
+	},
+	[SST_SSP1] = {
+		[SST_SSP_FM_MUX] = {
+			[SST_SSP_FM_DOMAIN] = {
+				.ssp_id = SSP_FM,
+				.bits_per_slot = 16,
+				.slots = 2,
+				.ssp_mode = SSP_MODE_MASTER,
+				.pcm_mode = SSP_PCM_MODE_NORMAL,
+				.data_polarity = 1,
+				.duplex = SSP_DUPLEX,
+				.ssp_protocol = SSP_MODE_I2S,
+				.fs_width = 32,
+				.fs_frequency = SSP_FS_48_KHZ,
+				.active_slot_map = 0x3,
+				.start_delay = 0,
+			},
+		},
+		[SST_SSP_BT_MUX] = {
+			[SST_SSP_BT_NB_DOMAIN] = {
+				.ssp_id = SSP_BT,
+				.bits_per_slot = 16,
+				.slots = 1,
+				.ssp_mode = SSP_MODE_MASTER,
+				.pcm_mode = SSP_PCM_MODE_NORMAL,
+				.data_polarity = 1,
+				.duplex = SSP_DUPLEX,
+				.ssp_protocol = SSP_MODE_PCM,
+				.fs_width = 1,
+				.fs_frequency = SSP_FS_8_KHZ,
+				.active_slot_map = 0x1,
+				.start_delay = 1,
+			},
+			[SST_SSP_BT_WB_DOMAIN] = {
+				.ssp_id = SSP_BT,
+				.bits_per_slot = 16,
+				.slots = 1,
+				.ssp_mode = SSP_MODE_MASTER,
+				.pcm_mode = SSP_PCM_MODE_NORMAL,
+				.data_polarity = 1,
+				.duplex = SSP_DUPLEX,
+				.ssp_protocol = SSP_MODE_PCM,
+				.fs_width = 1,
+				.fs_frequency = SSP_FS_16_KHZ,
+				.active_slot_map = 0x1,
+				.start_delay = 1,
+			},
+		},
+	},
+	[SST_SSP2] = {
+		[SST_SSP_CODEC_MUX] = {
+			[SST_SSP_CODEC_DOMAIN] = {
+				.ssp_id = SSP_CODEC,
+				.bits_per_slot = 24,
+				.slots = 2,
+				.ssp_mode = SSP_MODE_MASTER,
+				.pcm_mode = SSP_PCM_MODE_NORMAL,
+				.data_polarity = 0,
+				.duplex = SSP_DUPLEX,
+				.ssp_protocol = SSP_MODE_I2S,
+				.fs_width = 24,
+				.fs_frequency = SSP_FS_48_KHZ,
+				.active_slot_map = 0x3,
+				.start_delay = 1,
+			},
+		},
+	},
+};
+
+static void set_byt_cr_platform_config(void)
+{
+	sst_platform_pdata.pdev_strm_map = byt_cr_strm_map;
+	sst_platform_pdata.strm_map_size =  ARRAY_SIZE(byt_cr_strm_map);
+	pr_debug("audio:byt_cr:strm_map_size %d\n", sst_platform_pdata.strm_map_size);
+}
+
+static void set_byt_platform_config(void)
+{
+	sst_platform_pdata.pdev_strm_map = byt_bl_strm_map;
+	sst_platform_pdata.strm_map_size =  ARRAY_SIZE(byt_bl_strm_map);
+}
+
+static void set_cht_platform_config(void)
+{
+	sst_platform_pdata.pdev_strm_map = mrfld_strm_map;
+	sst_platform_pdata.strm_map_size = ARRAY_SIZE(mrfld_strm_map);
+	memcpy(sst_platform_pdata.ssp_config, sst_ssp_configs_mrfld, sizeof(sst_ssp_configs_mrfld));
+	memcpy(sst_platform_pdata.mux_shift, sst_ssp_mux_shift, sizeof(sst_ssp_mux_shift));
+	memcpy(sst_platform_pdata.domain_shift, sst_ssp_domain_shift, sizeof(sst_ssp_domain_shift));
+}
+
+static void set_cht_cr_platform_config(void)
+{
+	sst_platform_pdata.pdev_strm_map = mrfld_strm_map;
+	sst_platform_pdata.strm_map_size = ARRAY_SIZE(mrfld_strm_map);
+	memcpy(sst_platform_pdata.ssp_config, sst_ssp_configs_cht_cr, sizeof(sst_ssp_configs_cht_cr));
+	memcpy(sst_platform_pdata.mux_shift, sst_ssp_mux_shift, sizeof(sst_ssp_mux_shift));
+	memcpy(sst_platform_pdata.domain_shift, sst_ssp_domain_shift, sizeof(sst_ssp_domain_shift));
+}
+
+static void set_mrfld_platform_config(void)
+{
+	sst_platform_pdata.pdev_strm_map = mrfld_strm_map;
+	sst_platform_pdata.strm_map_size = ARRAY_SIZE(mrfld_strm_map);
+	sst_platform_pdata.pdev_effs.effs_map = mrfld_effs_map;
+	sst_platform_pdata.pdev_effs.effs_res_map = mrfld_effs_res_map;
+	sst_platform_pdata.pdev_effs.effs_num_map = ARRAY_SIZE(mrfld_effs_map);
+	memcpy(sst_platform_pdata.ssp_config, sst_ssp_configs_mrfld, sizeof(sst_ssp_configs_mrfld));
+	memcpy(sst_platform_pdata.mux_shift, sst_ssp_mux_shift, sizeof(sst_ssp_mux_shift));
+	memcpy(sst_platform_pdata.domain_shift, sst_ssp_domain_shift, sizeof(sst_ssp_domain_shift));
+}
+
+static void  populate_platform_data(void)
+{
+	set_cht_cr_platform_config();
+}
+
+int add_sst_platform_device(void)
+{
+	struct platform_device *pdev = NULL;
+	int ret;
+	populate_platform_data();
+
+	pdev = platform_device_alloc("sst-platform", -1);
+	if (!pdev) {
+		pr_err("failed to allocate audio platform device\n");
+		return -EINVAL;
+	}
+
+	ret = platform_device_add_data(pdev, &sst_platform_pdata,
+					sizeof(sst_platform_pdata));
+	if (ret) {
+		pr_err("failed to add sst platform data\n");
+		platform_device_put(pdev);
+		return  -EINVAL;
+	}
+	ret = platform_device_add(pdev);
+	if (ret) {
+		pr_err("failed to add audio platform device\n");
+		platform_device_put(pdev);
+		return  -EINVAL;
+	}
+	return ret;
+}
diff --git a/include/linux/lnw_gpio.h b/include/linux/lnw_gpio.h
new file mode 100644
index 0000000..9cde4d2
--- /dev/null
+++ b/include/linux/lnw_gpio.h
@@ -0,0 +1,13 @@
+#ifndef _H_LANGWELL_GPIO_H
+#define _H_LANGWELL_GPIO_H
+
+enum {
+	LNW_GPIO = 0,
+	LNW_ALT_1 = 1,
+	LNW_ALT_2 = 2,
+	LNW_ALT_3 = 3,
+};
+
+void lnw_gpio_set_alt(int gpio, int alt);
+
+#endif
diff --git a/include/linux/sst_trace.h b/include/linux/sst_trace.h
new file mode 100644
index 0000000..6ff2f95
--- /dev/null
+++ b/include/linux/sst_trace.h
@@ -0,0 +1,143 @@
+/*
+ *  sst_trace.h - Intel SST Driver tracing support
+ *
+ *  Copyright (C) 2013	Intel Corp
+ *  Authors: Omair Mohammed Abdullah <omair.m.abdullah@linux.intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM sst
+
+#if !defined(_TRACE_SST_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_SST_H
+
+#include <linux/types.h>
+#include <linux/ktime.h>
+#include <linux/tracepoint.h>
+
+TRACE_EVENT(sst_ipc,
+
+	TP_PROTO(const char *msg, u32 header_high, u32 header_low, int pvt_id),
+
+	TP_ARGS(msg, header_high, header_low, pvt_id),
+
+	TP_STRUCT__entry(
+		__string(info_msg,	msg)
+		__field(unsigned int,	val_l)
+		__field(unsigned int,	val_h)
+		__field(unsigned int,	id)
+	),
+
+	TP_fast_assign(
+		__assign_str(info_msg, msg);
+		__entry->val_l = header_low;
+		__entry->val_h = header_high;
+		__entry->id = pvt_id;
+	),
+
+	TP_printk("\t%s\t [%2u] = %#8.8x:%.4x", __get_str(info_msg),
+		  (unsigned int)__entry->id,
+		  (unsigned int)__entry->val_h, (unsigned int)__entry->val_l)
+
+);
+
+TRACE_EVENT(sst_stream,
+
+	TP_PROTO(const char *msg, int str_id, int pipe_id),
+
+	TP_ARGS(msg, str_id, pipe_id),
+
+	TP_STRUCT__entry(
+		__string(info_msg,	msg)
+		__field(unsigned int,	str_id)
+		__field(unsigned int,	pipe_id)
+	),
+
+	TP_fast_assign(
+		__assign_str(info_msg, msg);
+		__entry->str_id = str_id;
+		__entry->pipe_id = pipe_id;
+	),
+
+	TP_printk("\t%s\t str  = %2u, pipe = %#x", __get_str(info_msg),
+		  (unsigned int)__entry->str_id, (unsigned int)__entry->pipe_id)
+);
+
+TRACE_EVENT(sst_ipc_mailbox,
+
+	TP_PROTO(const char *mailbox, int mbox_len),
+
+	TP_ARGS(mailbox, mbox_len),
+
+	TP_STRUCT__entry(
+		__dynamic_array(char,	mbox,	(3 * mbox_len))
+	),
+
+	TP_fast_assign(
+		sst_dump_to_buffer(mailbox, mbox_len,
+				   __get_dynamic_array(mbox));
+	),
+
+	TP_printk("  %s", __get_str(mbox))
+
+);
+
+TRACE_EVENT(sst_lib_download,
+
+	TP_PROTO(const char *msg, const char *lib_name),
+
+	TP_ARGS(msg, lib_name),
+
+	TP_STRUCT__entry(
+		__string(info_msg, msg)
+		__string(info_lib_name, lib_name)
+	),
+
+	TP_fast_assign(
+		__assign_str(info_msg, msg);
+		__assign_str(info_lib_name, lib_name);
+	),
+
+	TP_printk("\t%s %s", __get_str(info_msg),
+			__get_str(info_lib_name))
+);
+
+TRACE_EVENT(sst_fw_download,
+
+	TP_PROTO(const char *msg, int fw_state),
+
+	TP_ARGS(msg, fw_state),
+
+	TP_STRUCT__entry(
+		__string(info_msg, msg)
+		__field(unsigned int,   fw_state)
+	),
+
+	TP_fast_assign(
+		__assign_str(info_msg, msg);
+		__entry->fw_state = fw_state;
+	),
+
+	TP_printk("\t%s\tFW state = %d", __get_str(info_msg),
+				(unsigned int)__entry->fw_state)
+);
+
+#endif /* _TRACE_SST_H */
+
+/* This part must be outside protection */
+#undef TRACE_INCLUDE_PATH
+#define TRACE_INCLUDE_PATH .
+#define TRACE_INCLUDE_FILE sst_trace
+#include <trace/define_trace.h>
diff --git a/include/sound/intel_sst_ioctl.h b/include/sound/intel_sst_ioctl.h
index 6025ef9..825971b 100644
--- a/include/sound/intel_sst_ioctl.h
+++ b/include/sound/intel_sst_ioctl.h
@@ -19,10 +19,6 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  *  General Public License for more details.
  *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- *
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  *
  *  This file defines all sst ioctls
diff --git a/include/trace/sst_trace.h b/include/trace/sst_trace.h
new file mode 100644
index 0000000..6ff2f95
--- /dev/null
+++ b/include/trace/sst_trace.h
@@ -0,0 +1,143 @@
+/*
+ *  sst_trace.h - Intel SST Driver tracing support
+ *
+ *  Copyright (C) 2013	Intel Corp
+ *  Authors: Omair Mohammed Abdullah <omair.m.abdullah@linux.intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM sst
+
+#if !defined(_TRACE_SST_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_SST_H
+
+#include <linux/types.h>
+#include <linux/ktime.h>
+#include <linux/tracepoint.h>
+
+TRACE_EVENT(sst_ipc,
+
+	TP_PROTO(const char *msg, u32 header_high, u32 header_low, int pvt_id),
+
+	TP_ARGS(msg, header_high, header_low, pvt_id),
+
+	TP_STRUCT__entry(
+		__string(info_msg,	msg)
+		__field(unsigned int,	val_l)
+		__field(unsigned int,	val_h)
+		__field(unsigned int,	id)
+	),
+
+	TP_fast_assign(
+		__assign_str(info_msg, msg);
+		__entry->val_l = header_low;
+		__entry->val_h = header_high;
+		__entry->id = pvt_id;
+	),
+
+	TP_printk("\t%s\t [%2u] = %#8.8x:%.4x", __get_str(info_msg),
+		  (unsigned int)__entry->id,
+		  (unsigned int)__entry->val_h, (unsigned int)__entry->val_l)
+
+);
+
+TRACE_EVENT(sst_stream,
+
+	TP_PROTO(const char *msg, int str_id, int pipe_id),
+
+	TP_ARGS(msg, str_id, pipe_id),
+
+	TP_STRUCT__entry(
+		__string(info_msg,	msg)
+		__field(unsigned int,	str_id)
+		__field(unsigned int,	pipe_id)
+	),
+
+	TP_fast_assign(
+		__assign_str(info_msg, msg);
+		__entry->str_id = str_id;
+		__entry->pipe_id = pipe_id;
+	),
+
+	TP_printk("\t%s\t str  = %2u, pipe = %#x", __get_str(info_msg),
+		  (unsigned int)__entry->str_id, (unsigned int)__entry->pipe_id)
+);
+
+TRACE_EVENT(sst_ipc_mailbox,
+
+	TP_PROTO(const char *mailbox, int mbox_len),
+
+	TP_ARGS(mailbox, mbox_len),
+
+	TP_STRUCT__entry(
+		__dynamic_array(char,	mbox,	(3 * mbox_len))
+	),
+
+	TP_fast_assign(
+		sst_dump_to_buffer(mailbox, mbox_len,
+				   __get_dynamic_array(mbox));
+	),
+
+	TP_printk("  %s", __get_str(mbox))
+
+);
+
+TRACE_EVENT(sst_lib_download,
+
+	TP_PROTO(const char *msg, const char *lib_name),
+
+	TP_ARGS(msg, lib_name),
+
+	TP_STRUCT__entry(
+		__string(info_msg, msg)
+		__string(info_lib_name, lib_name)
+	),
+
+	TP_fast_assign(
+		__assign_str(info_msg, msg);
+		__assign_str(info_lib_name, lib_name);
+	),
+
+	TP_printk("\t%s %s", __get_str(info_msg),
+			__get_str(info_lib_name))
+);
+
+TRACE_EVENT(sst_fw_download,
+
+	TP_PROTO(const char *msg, int fw_state),
+
+	TP_ARGS(msg, fw_state),
+
+	TP_STRUCT__entry(
+		__string(info_msg, msg)
+		__field(unsigned int,   fw_state)
+	),
+
+	TP_fast_assign(
+		__assign_str(info_msg, msg);
+		__entry->fw_state = fw_state;
+	),
+
+	TP_printk("\t%s\tFW state = %d", __get_str(info_msg),
+				(unsigned int)__entry->fw_state)
+);
+
+#endif /* _TRACE_SST_H */
+
+/* This part must be outside protection */
+#undef TRACE_INCLUDE_PATH
+#define TRACE_INCLUDE_PATH .
+#define TRACE_INCLUDE_FILE sst_trace
+#include <trace/define_trace.h>
diff --git a/sound/soc/intel/Kconfig b/sound/soc/intel/Kconfig
new file mode 100644
index 0000000..87856b7
--- /dev/null
+++ b/sound/soc/intel/Kconfig
@@ -0,0 +1,41 @@
+
+config SND_BYT_MACHINE
+	tristate "SOC Machine Audio driver for Intel Baytrail MID platform"
+	depends on X86
+	select SND_SOC_RT5640
+	select SND_SST_PLATFORM
+	select SND_SST_MACHINE
+	select SND_INTEL_SST
+	select SND_HWDEP
+	default n
+
+	help
+	  This adds support for ASoC machine driver for Intel(R) MID Baytrail platform
+          used as alsa device in audio substem in Intel(R) MID devices
+          Say Y if you have such a device
+          If unsure select "N".
+
+config SND_INTEL_SST
+       tristate
+
+config SND_SST_PLATFORM
+	tristate
+
+config SND_SOC_COMMS_SSP
+	depends on SND_INTEL_MID_I2S
+	tristate "Use ASOC framework to drive AudioComms SSP BT and Modem"
+	help
+	  Sound SOC cards usually used for BT VOIP and MODEM MIXING use cases.
+	  This will add devices for these uses cases in the list of alsa cards.
+	  Say Y if you need these sound cards (BT chipset or Modem present).
+	  Requires to enable the INTEL_MID_I2S low level SSP I2S driver.
+
+config SST_DPCM
+	bool "Use DPCM based Machine Audio driver"
+	default n
+	help
+	  This adds an option to enable the DPCM based machine driver
+
+config SND_SST_MACHINE
+	tristate
+
diff --git a/sound/soc/intel/Makefile b/sound/soc/intel/Makefile
new file mode 100644
index 0000000..dd4a707
--- /dev/null
+++ b/sound/soc/intel/Makefile
@@ -0,0 +1,19 @@
+#EXTRA CFLAGS
+ccflags-y += -Werror
+
+#ifeq (${TARGET_BUILD_VARIANT},$(filter ${TARGET_BUILD_VARIANT}, eng))
+ccflags-y += -DCONFIG_SND_VERBOSE_PRINTK -DCONFIG_SND_DEBUG -DCONFIG_SND_DEBUG_VERBOSE
+#endif
+
+# SST Platform Driver
+PLATFORM_LIBS = platform-libs/controls_v2.o platform-libs/controls_v2_dpcm.o \
+		platform-libs/ipc_lib_v2.o
+
+snd-soc-sst-platform-objs := pcm.o compress.o effects.o $(PLATFORM_LIBS)
+obj-$(CONFIG_SND_SST_PLATFORM) += snd-soc-sst-platform.o
+
+# Relevant Machine driver
+obj-$(CONFIG_SND_SST_MACHINE) += board/
+
+# DSP driver
+obj-$(CONFIG_SND_INTEL_SST) += sst/
diff --git a/sound/soc/intel/board/Makefile b/sound/soc/intel/board/Makefile
new file mode 100644
index 0000000..c15dc42
--- /dev/null
+++ b/sound/soc/intel/board/Makefile
@@ -0,0 +1,12 @@
+
+#EXTRA CFLAGS
+ccflags-y += -Werror
+
+EXTRA_CFLAGS += -DDEBUG
+
+# Baytrail board
+snd-byt-cr-dpcm-rt5640-objs := byt_cr_dpcm_rt5640.o
+obj-$(CONFIG_SND_BYT_MACHINE) += snd-byt-cr-dpcm-rt5640.o
+
+
+
diff --git a/sound/soc/intel/board/byt_cr_dpcm_rt5640.c b/sound/soc/intel/board/byt_cr_dpcm_rt5640.c
new file mode 100644
index 0000000..153320f
--- /dev/null
+++ b/sound/soc/intel/board/byt_cr_dpcm_rt5640.c
@@ -0,0 +1,1082 @@
+/*
+ *  byt_cr_dpcm_rt5640.c - ASoc Machine driver for Intel Byt CR platform
+ *
+ *  Copyright (C) 2014 Intel Corp
+ *  Author: Subhransu S. Prusty <subhransu.s.prusty@intel.com>
+ *  This file is modified from byt_cr_rt5640.c for byt cr dpcm configuration
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/acpi.h>
+#include <linux/device.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/vlv2_plat_clock.h>
+#include <linux/input.h>
+#include <asm/intel-mid.h>
+#include <asm/platform_byt_audio.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/jack.h>
+#include "../../codecs/rt5640.h"
+
+#define BYT_PLAT_CLK_3_HZ	25000000
+#define BYT_CODEC_GPIO_IDX      0
+#define BYT_JD_GPIO_IDX         1
+
+#define BYT_JD_INTR_DEBOUNCE            0
+#define BYT_CODEC_INTR_DEBOUNCE         0
+#define BYT_HS_INSERT_DET_DELAY         500
+#define BYT_HS_REMOVE_DET_DELAY         500
+#define BYT_BUTTON_DET_DELAY            100
+#define BYT_HS_DET_POLL_INTRVL          100
+#define BYT_BUTTON_EN_DELAY             1500
+
+#define BYT_HS_DET_RETRY_COUNT          6
+
+
+#define BYT_HS_DET_RETRY_COUNT          6
+
+#define VLV2_PLAT_CLK_AUDIO	3
+#define PLAT_CLK_FORCE_ON	1
+#define PLAT_CLK_FORCE_OFF	2
+
+/* 0 = 25MHz from crystal, 1 = 19.2MHz from PLL */
+#define PLAT_CLK_FREQ_XTAL	0
+
+struct byt_mc_private {
+	struct snd_soc_jack jack;
+	struct delayed_work hs_insert_work;
+	struct delayed_work hs_remove_work;
+	struct delayed_work hs_button_work;
+	struct mutex jack_mlock;
+	/* To enable button press interrupts after a delay after
+	   HS detection. This is to avoid spurious button press
+	   events during slow HS insertion */
+	struct delayed_work hs_button_en_work;
+	int intr_debounce;
+	int hs_insert_det_delay;
+	int hs_remove_det_delay;
+	int button_det_delay;
+	int button_en_delay;
+	int hs_det_poll_intrvl;
+	int hs_det_retry;
+	bool process_button_events;
+	int tristate_buffer_gpio;
+	int num_jack_gpios;
+	bool use_soc_jd_gpio;
+
+};
+static int byt_jack_codec_gpio_intr(void *);
+static int byt_jack_soc_gpio_intr(void *);
+static struct snd_soc_jack_gpio hs_gpio[] = {
+	[BYT_CODEC_GPIO_IDX] = {
+		.name                   = "byt-codec-int",
+		.report                 = SND_JACK_HEADSET |
+					  SND_JACK_HEADPHONE |
+					  SND_JACK_BTN_0,
+		.debounce_time	  = BYT_CODEC_INTR_DEBOUNCE,
+		.jack_status_check      = byt_jack_codec_gpio_intr,
+	},
+	[BYT_JD_GPIO_IDX] = {
+		.name                   = "byt-jd-int",
+		.report                 = SND_JACK_HEADSET |
+					  SND_JACK_HEADPHONE,
+		.debounce_time          = BYT_JD_INTR_DEBOUNCE,
+		.jack_status_check      = byt_jack_soc_gpio_intr,
+	},
+
+};
+
+static inline void byt_force_enable_pin(struct snd_soc_codec *codec,
+			 const char *bias_widget, bool enable)
+{
+	pr_debug("%s %s\n", enable ? "enable" : "disable", bias_widget);
+	if (enable)
+		snd_soc_dapm_force_enable_pin(&codec->dapm, bias_widget);
+	else
+		snd_soc_dapm_disable_pin(&codec->dapm, bias_widget);
+}
+static inline void byt_set_mic_bias_ldo(struct snd_soc_codec *codec, bool enable)
+{
+	if (enable) {
+		byt_force_enable_pin(codec, "micbias1", true);
+		byt_force_enable_pin(codec, "LDO2", true);
+	} else {
+		byt_force_enable_pin(codec, "micbias1", false);
+		byt_force_enable_pin(codec, "LDO2", false);
+	}
+	snd_soc_dapm_sync(&codec->dapm);
+}
+
+/*if Soc Jack det is enabled, use it, otherwise use JD via codec */
+static inline int byt_check_jd_status(struct byt_mc_private *ctx)
+{
+	struct snd_soc_jack_gpio *gpio = &hs_gpio[BYT_JD_GPIO_IDX];
+	if (ctx->use_soc_jd_gpio)
+		return gpio_get_value(gpio->gpio);
+	else
+		return rt5640_check_jd_status(ctx->jack.codec);
+}
+
+
+/* Identify the jack type as Headset/Headphone/None */
+static int byt_check_jack_type(void)
+{
+	struct snd_soc_jack_gpio *gpio = &hs_gpio[BYT_CODEC_GPIO_IDX];
+	struct snd_soc_jack *jack = gpio->jack;
+	struct snd_soc_codec *codec = jack->codec;
+	int status, jack_type = 0;
+	struct byt_mc_private *ctx = container_of(jack, struct byt_mc_private, jack);
+
+	status = byt_check_jd_status(ctx);
+	/* jd status low indicates some accessory has been connected */
+	if (!status) {
+		pr_debug("Jack insert intr");
+		/* Do not process button events until accessory is detected as headset*/
+		ctx->process_button_events = false;
+		byt_set_mic_bias_ldo(codec, true);
+		status = rt5640_detect_hs_type(codec, true);
+		if (status == RT5640_HEADPHO_DET)
+			jack_type = SND_JACK_HEADPHONE;
+		else if (status == RT5640_HEADSET_DET) {
+			jack_type = SND_JACK_HEADSET;
+			ctx->process_button_events = true;
+			/* If headset is detected, enable button interrupts after a delay */
+			schedule_delayed_work(&ctx->hs_button_en_work,
+					msecs_to_jiffies(ctx->button_en_delay));
+		} else /* RT5640_NO_JACK */
+			jack_type = 0;
+
+		if (jack_type != SND_JACK_HEADSET)
+			byt_set_mic_bias_ldo(codec, false);
+
+	} else
+		jack_type = 0;
+
+	pr_debug("Jack type detected:%d", jack_type);
+
+	return jack_type;
+}
+
+/* Work function invoked by the Jack Infrastructure. Other delayed works
+   for jack detection/removal/button press are scheduled from this function */
+static int byt_jack_codec_gpio_intr(void *data)
+{
+	struct snd_soc_jack_gpio *gpio = &hs_gpio[BYT_CODEC_GPIO_IDX];
+	struct snd_soc_jack *jack = gpio->jack;
+	int status, jack_type = 0;
+	int ret;
+	struct byt_mc_private *ctx = container_of(jack, struct byt_mc_private, jack);
+
+	mutex_lock(&ctx->jack_mlock);
+	/* Initialize jack status with previous status. The delayed work will confirm
+	   the event and send updated status later */
+	jack_type = jack->status;
+	pr_debug("Enter:%s", __func__);
+	if (ctx->use_soc_jd_gpio) {
+		/* Must be button event. Confirm the event in delayed work*/
+		if (((jack->status & SND_JACK_HEADSET) == SND_JACK_HEADSET) &&
+				ctx->process_button_events) {
+			ret = schedule_delayed_work(&ctx->hs_button_work,
+					msecs_to_jiffies(ctx->button_det_delay));
+			if (!ret)
+				pr_debug("byt_check_hs_button_status already queued");
+			else
+				pr_debug("%s:check BP/BR after %d msec",
+						__func__, ctx->button_det_delay);
+		}
+	} else {
+		if (!jack->status) {
+			ctx->hs_det_retry = BYT_HS_DET_RETRY_COUNT;
+			ret = schedule_delayed_work(&ctx->hs_insert_work,
+					msecs_to_jiffies(ctx->hs_insert_det_delay));
+			if (!ret)
+				pr_debug("byt_check_hs_insert_status already queued");
+			else
+				pr_debug("%s:Check hs insertion  after %d msec",
+						__func__, ctx->hs_insert_det_delay);
+
+		} else {
+			/* First check for accessory removal; If not removed,
+			   check for button events*/
+			status = byt_check_jd_status(ctx);
+			/* jd status high indicates accessory has been disconnected.
+			   However, confirm the removal in the delayed work */
+			if (status) {
+				/* Do not process button events while we make sure
+				   accessory is disconnected*/
+				ctx->process_button_events = false;
+				ret = schedule_delayed_work(&ctx->hs_remove_work,
+						msecs_to_jiffies(ctx->hs_remove_det_delay));
+				if (!ret)
+					pr_debug("byt_check_hs_remove_status already queued");
+				else
+					pr_debug("%s:Check hs removal after %d msec",
+							__func__, ctx->hs_remove_det_delay);
+			} else { /* Must be button event. Confirm the event in delayed work*/
+				if (((jack->status & SND_JACK_HEADSET) == SND_JACK_HEADSET) &&
+						ctx->process_button_events) {
+					ret = schedule_delayed_work(&ctx->hs_button_work,
+							msecs_to_jiffies(ctx->button_det_delay));
+					if (!ret)
+						pr_debug("byt_check_hs_button_status already queued");
+					else
+						pr_debug("%s:check BP/BR after %d msec",
+								__func__, ctx->button_det_delay);
+				}
+			}
+		}
+	}
+
+	pr_debug("Exit:%s", __func__);
+	mutex_unlock(&ctx->jack_mlock);
+	return jack_type;
+}
+
+/*Checks jack insertion and identifies the jack type.
+  Retries the detection if necessary */
+static void byt_check_hs_insert_status(struct work_struct *work)
+{
+	struct snd_soc_jack_gpio *gpio = &hs_gpio[BYT_CODEC_GPIO_IDX];
+	struct snd_soc_jack *jack = gpio->jack;
+	struct byt_mc_private *ctx = container_of(work, struct byt_mc_private, hs_insert_work.work);
+	int jack_type = 0;
+
+	mutex_lock(&ctx->jack_mlock);
+	pr_debug("Enter:%s", __func__);
+
+	jack_type = byt_check_jack_type();
+
+		/* Report jack immediately only if jack is headset.
+		 *  If headphone or no jack was detected,
+		 *  dont report it until the last HS det try.
+		 *  This is to avoid reporting any temporary
+		 *  jack removal or accessory change(eg, HP to HS)
+		 * during the detection tries.
+		 * This provides additional debounce that will help
+		 * in the case of slow insertion.
+		 * This also avoids the pause in audio due to accessory
+		 * change from HP to HS
+		 */
+	if (ctx->hs_det_retry <= 0) /* end of retries; report the status */{
+		pr_debug("%d Jack type sent is %d\n", __LINE__, jack_type);
+		snd_soc_jack_report(jack, jack_type, gpio->report);
+	} else {
+		/* Schedule another detection try if headphone or
+		 * no jack is detected.
+		 * During slow insertion of headset, first a headphone
+		 * may be detected.
+		 * Hence retry until headset is detected
+		 */
+		if (jack_type == SND_JACK_HEADSET) {
+			ctx->hs_det_retry = 0;
+			/* HS detected, no more retries needed */
+			pr_debug("%d Jack type sent is %d\n",
+				 __LINE__, jack_type);
+			snd_soc_jack_report(jack, jack_type, gpio->report);
+		} else {
+			ctx->hs_det_retry--;
+			schedule_delayed_work(&ctx->hs_insert_work,
+				msecs_to_jiffies(ctx->hs_det_poll_intrvl));
+			pr_debug("%s:re-try hs detection after %d msec",
+					__func__, ctx->hs_det_poll_intrvl);
+		}
+	}
+
+	pr_debug("Exit:%s", __func__);
+	mutex_unlock(&ctx->jack_mlock);
+}
+
+/* Checks jack removal. */
+static void byt_check_hs_remove_status(struct work_struct *work)
+{
+	struct snd_soc_jack_gpio *gpio = &hs_gpio[BYT_CODEC_GPIO_IDX];
+	struct snd_soc_jack *jack = gpio->jack;
+	struct snd_soc_codec *codec = jack->codec;
+	struct byt_mc_private *ctx = container_of(work, struct byt_mc_private, hs_remove_work.work);
+	int status = 0, jack_type = 0;
+
+	/* Cancel any pending insertion detection. There
+	   could be pending insertion detection in the
+	   case of very slow insertion or insertion and
+	   immediate removal.*/
+	cancel_delayed_work_sync(&ctx->hs_insert_work);
+
+	mutex_lock(&ctx->jack_mlock);
+	pr_debug("Enter:%s", __func__);
+	/* Initialize jack_type with previous status.
+	   If the event was an invalid one, we return the preious state*/
+	jack_type = jack->status;
+
+	if (jack->status) { /* jack is in connected state; look for removal event */
+		status = byt_check_jd_status(ctx);
+		if (status) { /* jd status high implies accessory disconnected */
+			pr_debug("Jack remove event");
+			ctx->process_button_events = false;
+			cancel_delayed_work_sync(&ctx->hs_button_en_work);
+			status = rt5640_detect_hs_type(codec, false);
+			jack_type = 0;
+			byt_set_mic_bias_ldo(codec, false);
+
+		} else if (((jack->status & SND_JACK_HEADSET) == SND_JACK_HEADSET) && !ctx->process_button_events) {
+			/* Jack is still connected. We may come here if there was a spurious
+			   jack removal event. No state change is done until removal is confirmed
+			   by the check_jd_status above.i.e. jack status remains Headset or headphone.
+			   But as soon as the interrupt thread(byt_jack/_bp_detection) detected a jack
+			   removal, button processing gets disabled. Hence re-enable button processing
+			   in the case of headset */
+			pr_debug(" spurious Jack remove event for headset; re-enable button events");
+			ctx->process_button_events = true;
+		}
+	}
+	snd_soc_jack_report(jack, jack_type, gpio->report);
+	pr_debug("Exit:%s", __func__);
+	mutex_unlock(&ctx->jack_mlock);
+}
+
+/* Check for button press/release */
+static void byt_check_hs_button_status(struct work_struct *work)
+{
+	struct snd_soc_jack_gpio *gpio = &hs_gpio[BYT_CODEC_GPIO_IDX];
+	struct snd_soc_jack *jack = gpio->jack;
+	struct snd_soc_codec *codec = jack->codec;
+	struct byt_mc_private *ctx = container_of(work, struct byt_mc_private, hs_button_work.work);
+	int status = 0, jack_type = 0;
+	int ret;
+
+	mutex_lock(&ctx->jack_mlock);
+	pr_debug("Enter:%s\n", __func__);
+	jack_type = jack->status;
+
+	if (((jack->status & SND_JACK_HEADSET) == SND_JACK_HEADSET)
+			&& ctx->process_button_events) {
+
+		status = byt_check_jd_status(ctx);
+		if (!status) { /* confirm jack is connected */
+
+			status = rt5640_check_bp_status(codec);
+			if (jack->status & SND_JACK_BTN_0) { /* if button was previosly in pressed state*/
+				if (!status) {
+					pr_debug("BR event received");
+					jack_type = SND_JACK_HEADSET;
+				}
+			} else { /* If button was previously in released state */
+				if (status) {
+					pr_debug("BP event received");
+					jack_type = SND_JACK_HEADSET | SND_JACK_BTN_0;
+				}
+			}
+		}
+		/* There could be button interrupts during jack removal. There can be
+		   situations where a button interrupt is generated first but no jack
+		   removal interrupt is generated. This can happen on platforrms where
+		   jack detection is aligned to Headset Left pin instead of the ground
+		   pin and codec multiplexes (ORs) the jack and button interrupts.
+		   So schedule a jack removal detection work */
+		if (!ctx->use_soc_jd_gpio) {
+			ret = schedule_delayed_work(&ctx->hs_remove_work,
+					msecs_to_jiffies(ctx->hs_remove_det_delay));
+			if (!ret)
+				pr_debug("byt_check_hs_remove_status already queued");
+			else
+				pr_debug("%s:Check hs removal after %d msec",
+						__func__, ctx->hs_remove_det_delay);
+		}
+
+	}
+	snd_soc_jack_report(jack, jack_type, gpio->report);
+	pr_debug("Exit:%s", __func__);
+	mutex_unlock(&ctx->jack_mlock);
+}
+
+static int byt_jack_soc_gpio_intr(void *data)
+{
+	struct snd_soc_jack_gpio *gpio = &hs_gpio[BYT_JD_GPIO_IDX];
+	struct snd_soc_jack *jack = gpio->jack;
+	struct byt_mc_private *ctx = container_of(jack, struct byt_mc_private, jack);
+	int ret;
+	int status;
+
+	mutex_lock(&ctx->jack_mlock);
+
+	pr_debug("Enter:%s", __func__);
+
+	if (!jack->status) {
+		ctx->hs_det_retry = BYT_HS_DET_RETRY_COUNT;
+		ret = schedule_delayed_work(&ctx->hs_insert_work,
+				msecs_to_jiffies(ctx->hs_insert_det_delay));
+		if (!ret)
+			pr_debug("byt_check_hs_insert_status already queued");
+		else
+			pr_debug("%s:Check hs insertion  after %d msec",
+					__func__, ctx->hs_insert_det_delay);
+
+	} else {
+		status = byt_check_jd_status(ctx);
+		/* jd status high indicates accessory has been disconnected.
+		   However, confirm the removal in the delayed work */
+		if (status) {
+			/* Do not process button events while we make sure
+			   accessory is disconnected*/
+			ctx->process_button_events = false;
+			ret = schedule_delayed_work(&ctx->hs_remove_work,
+					msecs_to_jiffies(ctx->hs_remove_det_delay));
+			if (!ret)
+				pr_debug("byt_check_hs_remove_status already queued");
+			else
+				pr_debug("%s:Check hs removal after %d msec",
+						__func__, ctx->hs_remove_det_delay);
+		}
+	}
+	mutex_unlock(&ctx->jack_mlock);
+	pr_debug("Exit:%s", __func__);
+	/* return previous status */
+	return jack->status;
+
+}
+
+/* Delayed work for enabling the overcurrent detection circuit and interrupt
+   for generating button events */
+static void byt_enable_hs_button_events(struct work_struct *work)
+{
+	struct snd_soc_jack_gpio *gpio = &hs_gpio[BYT_CODEC_GPIO_IDX];
+	struct snd_soc_jack *jack = gpio->jack;
+	struct snd_soc_codec *codec = jack->codec;
+
+	rt5640_enable_ovcd_interrupt(codec, true);
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+static inline struct snd_soc_codec *byt_get_codec(struct snd_soc_card *card)
+{
+	bool found = false;
+	struct snd_soc_codec *codec;
+
+	list_for_each_entry(codec, &card->codec_dev_list, card_list) {
+		if (!strstr(codec->name, "i2c-10EC5640:00:1c")) {
+			pr_debug("codec was %s", codec->name);
+			continue;
+		} else {
+			found = true;
+			break;
+		}
+	}
+	if (found == false) {
+		pr_err("%s: cant find codec", __func__);
+		return NULL;
+	}
+	return codec;
+}
+
+static int platform_clock_control(struct snd_soc_dapm_widget *w,
+		struct snd_kcontrol *k, int  event)
+{
+	struct snd_soc_dapm_context *dapm = w->dapm;
+	struct snd_soc_card *card = dapm->card;
+	struct snd_soc_codec *codec;
+	codec = byt_get_codec(card);
+	if (!codec) {
+		pr_err("Codec not found; Unable to set platform clock\n");
+		return -EIO;
+	}
+	if (SND_SOC_DAPM_EVENT_ON(event)) {
+		vlv2_plat_configure_clock(VLV2_PLAT_CLK_AUDIO,
+				PLAT_CLK_FORCE_ON);
+
+		pr_debug("Platform clk turned ON\n");
+	snd_soc_codec_set_sysclk(codec, RT5640_SCLK_S_PLL1, 0, BYT_PLAT_CLK_3_HZ, SND_SOC_CLOCK_IN);
+	snd_soc_write(codec, RT5640_ADDA_CLK1, 0x0014);
+	} else {
+		/* Set codec clock source to internal clock before
+		   turning off the platform clock. Codec needs clock
+		   for Jack detection and button press */
+		snd_soc_write(codec, RT5640_ADDA_CLK1, 0x7774);
+		snd_soc_codec_set_sysclk(codec, RT5640_SCLK_S_RCCLK,
+				0, 0, SND_SOC_CLOCK_IN);
+		vlv2_plat_configure_clock(VLV2_PLAT_CLK_AUDIO,
+				PLAT_CLK_FORCE_OFF);
+		pr_debug("Platform clk turned OFF\n");
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_dapm_widget byt_dapm_widgets[] = {
+	SND_SOC_DAPM_HP("Headphone", NULL),
+	SND_SOC_DAPM_MIC("Headset Mic", NULL),
+	SND_SOC_DAPM_MIC("Int Mic", NULL),
+	SND_SOC_DAPM_SPK("Ext Spk", NULL),
+	SND_SOC_DAPM_SUPPLY("Platform Clock", SND_SOC_NOPM, 0, 0,
+			platform_clock_control, SND_SOC_DAPM_PRE_PMU|
+			SND_SOC_DAPM_POST_PMD),
+};
+
+static const struct snd_soc_dapm_route byt_audio_map[] = {
+	{"IN1P", NULL, "Headset Mic"},
+	{"IN1N", NULL, "Headset Mic"},
+	{"IN2P", NULL, "Int Mic"},
+	{"Headphone", NULL, "HPOL"},
+	{"Headphone", NULL, "HPOR"},
+	{"Ext Spk", NULL, "SPOLP"},
+	{"Ext Spk", NULL, "SPOLN"},
+	{"Ext Spk", NULL, "SPORP"},
+	{"Ext Spk", NULL, "SPORN"},
+
+	{"Headphone", NULL, "Platform Clock"},
+	{"Headset Mic", NULL, "Platform Clock"},
+	{"Int Mic", NULL, "Platform Clock"},
+	{"Ext Spk", NULL, "Platform Clock"},
+	{"AIF1 Playback", NULL, "ssp2 Tx"},
+	{"ssp2 Tx", NULL, "codec_out0"},
+	{"ssp2 Tx", NULL, "codec_out1"},
+	{"codec_in0", NULL, "ssp2 Rx"},
+	{"codec_in1", NULL, "ssp2 Rx"},
+	{"ssp2 Rx", NULL, "AIF1 Capture"},
+};
+
+static const struct snd_kcontrol_new byt_mc_controls[] = {
+	SOC_DAPM_PIN_SWITCH("Headphone"),
+	SOC_DAPM_PIN_SWITCH("Headset Mic"),
+	SOC_DAPM_PIN_SWITCH("Int Mic"),
+	SOC_DAPM_PIN_SWITCH("Ext Spk"),
+};
+
+/* Sets dai format and pll */
+static int byt_set_dai_fmt_pll(struct snd_soc_dai *codec_dai,
+					int source, unsigned int freq_out)
+{
+	int ret;
+	unsigned int fmt;
+	/* Set codec DAI configuration */
+	/* I2S Slave Mode`*/
+	fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+		SND_SOC_DAIFMT_CBS_CFS;
+
+	ret = snd_soc_dai_set_fmt(codec_dai, fmt);
+	if (ret < 0) {
+		pr_err("can't set codec DAI configuration %d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_dai_set_pll(codec_dai, 0, source,
+			BYT_PLAT_CLK_3_HZ, freq_out * 512);
+	if (ret < 0) {
+		pr_err("can't set codec pll: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int byt_aif1_hw_params(struct snd_pcm_substream *substream,
+					struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+
+	pr_debug("Enter:%s", __func__);
+	if (strncmp(codec_dai->name, "rt5640-aif1", 11))
+		return 0;
+	/* Setecodec DAI confinuration */
+	return byt_set_dai_fmt_pll(codec_dai, RT5640_PLL1_S_MCLK,
+			params_rate(params));
+}
+
+static const struct snd_soc_pcm_stream byt_dai_params = {
+	.formats = SNDRV_PCM_FMTBIT_S24_LE,
+	.rate_min = 48000,
+	.rate_max = 48000,
+	.channels_min = 2,
+	.channels_max = 2,
+};
+static int byt_codec_fixup(struct snd_soc_pcm_runtime *rtd,
+			    struct snd_pcm_hw_params *params)
+{
+	struct snd_interval *rate = hw_param_interval(params,
+			SNDRV_PCM_HW_PARAM_RATE);
+	struct snd_interval *channels = hw_param_interval(params,
+						SNDRV_PCM_HW_PARAM_CHANNELS);
+
+	pr_debug("Invoked %s for dailink %s\n", __func__, rtd->dai_link->name);
+
+	/* The DSP will covert the FE rate to 48k, stereo, 24bits */
+	rate->min = rate->max = 48000;
+	channels->min = channels->max = 2;
+
+	/* set SSP2 to 24-bit */
+	snd_mask_set(&params->masks[SNDRV_PCM_HW_PARAM_FORMAT -
+				    SNDRV_PCM_HW_PARAM_FIRST_MASK],
+				    SNDRV_PCM_FORMAT_S24_LE);
+	return 0;
+}
+
+static int byt_set_bias_level(struct snd_soc_card *card,
+				struct snd_soc_dapm_context *dapm,
+				enum snd_soc_bias_level level)
+{
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+	case SND_SOC_BIAS_PREPARE:
+	case SND_SOC_BIAS_STANDBY:
+	case SND_SOC_BIAS_OFF:
+		break;
+	default:
+		pr_err("%s: Invalid bias level=%d\n", __func__, level);
+		return -EINVAL;
+	}
+	card->dapm.bias_level = level;
+	pr_debug("card(%s)->bias_level %u\n", card->name,
+			card->dapm.bias_level);
+	return 0;
+}
+
+static int byt_init(struct snd_soc_pcm_runtime *runtime)
+{
+	int ret;
+	struct snd_soc_codec *codec;
+	struct snd_soc_card *card = runtime->card;
+	struct byt_mc_private *ctx = snd_soc_card_get_drvdata(runtime->card);
+	pr_debug("Enter:%s", __func__);
+
+	codec = byt_get_codec(card);
+	if (!codec) {
+		pr_err("Codec not found: %s:failed\n", __func__);
+		return -EIO;
+	}
+
+	/* Set codec bias level */
+	byt_set_bias_level(card, &card->dapm, SND_SOC_BIAS_OFF);
+	card->dapm.idle_bias_off = true;
+
+	/* Threshold base = 2000uA; scale factor = 0.5 =>
+	   effective threshold of 1000uA for micbias resistor for 2.2K */
+	rt5640_config_ovcd_thld(codec, RT5640_MIC1_OVTH_2000UA,
+			RT5640_MIC_OVCD_SF_0P5);
+
+	/* Headset jack detection */
+	ret = snd_soc_jack_new(codec, "Headset Jack",
+			SND_JACK_HEADSET | SND_JACK_HEADPHONE | SND_JACK_BTN_0,
+			 &ctx->jack);
+	if (ret) {
+		pr_err("Jack creation failed\n");
+		return ret;
+	}
+	snd_jack_set_key(ctx->jack.jack, SND_JACK_BTN_0, KEY_MEDIA);
+
+	ret = snd_soc_jack_add_gpios(&ctx->jack, 1, &hs_gpio[0]);
+	if (ret) {
+		pr_err("Adding jack GPIO failed with error %d\n", ret);
+		return ret;
+	}
+	ret = snd_soc_add_card_controls(card, byt_mc_controls,
+					ARRAY_SIZE(byt_mc_controls));
+	if (ret) {
+		pr_err("unable to add card controls\n");
+		return ret;
+	}
+	ret = snd_soc_dapm_sync(&card->dapm);
+	if (ret) {
+		pr_err("unable to sync dapm\n");
+		return ret;
+	}
+	return ret;
+}
+
+
+static unsigned int rates_8000_16000[] = {
+	8000,
+	16000,
+};
+
+static struct snd_pcm_hw_constraint_list constraints_8000_16000 = {
+	.count = ARRAY_SIZE(rates_8000_16000),
+	.list = rates_8000_16000,
+};
+static unsigned int rates_48000[] = {
+	48000,
+};
+
+static struct snd_pcm_hw_constraint_list constraints_48000 = {
+	.count = ARRAY_SIZE(rates_48000),
+	.list  = rates_48000,
+};
+
+static int byt_aif1_startup(struct snd_pcm_substream *substream)
+{
+	return snd_pcm_hw_constraint_list(substream->runtime, 0,
+			SNDRV_PCM_HW_PARAM_RATE,
+			&constraints_48000);
+}
+
+static struct snd_soc_ops byt_aif1_ops = {
+	.startup = byt_aif1_startup,
+};
+
+static int byt_8k_16k_startup(struct snd_pcm_substream *substream)
+{
+	return snd_pcm_hw_constraint_list(substream->runtime, 0,
+		SNDRV_PCM_HW_PARAM_RATE,
+		&constraints_8000_16000);
+}
+
+static struct snd_soc_ops byt_8k_16k_ops = {
+	.startup = byt_8k_16k_startup,
+	.hw_params = byt_aif1_hw_params,
+};
+static struct snd_soc_ops byt_be_ssp2_ops = {
+	.hw_params = byt_aif1_hw_params,
+};
+
+static struct snd_soc_compr_ops byt_compr_ops = {
+/*	.set_params = byt_compr_set_params, */
+};
+
+static struct snd_soc_dai_link byt_dailink[] = {
+	[BYT_DPCM_AUD_AIF1] = {
+		.name = "Baytrail Audio Port",
+		.stream_name = "Baytrail Audio",
+		.cpu_dai_name = "Headset-cpu-dai",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.platform_name = "sst-platform",
+		.init = byt_init,
+		.ignore_suspend = 1,
+		.dynamic = 1,
+		.ops = &byt_aif1_ops,
+	},
+	[BYT_DPCM_DB] = {
+		.name = "Baytrail DB Audio Port",
+		.stream_name = "Deep Buffer Audio",
+		.cpu_dai_name = "Deepbuffer-cpu-dai",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.platform_name = "sst-platform",
+		.ignore_suspend = 1,
+		.dynamic = 1,
+		.ops = &byt_aif1_ops,
+	},
+	[BYT_DPCM_LL] = {
+		.name = "Baytrail LL Audio Port",
+		.stream_name = "Low Latency Audio",
+		.cpu_dai_name = "Lowlatency-cpu-dai",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.platform_name = "sst-platform",
+		.ignore_suspend = 1,
+		.dynamic = 1,
+		.ops = &byt_aif1_ops,
+	},
+	[BYT_DPCM_COMPR] = {
+		.name = "Baytrail Compressed Port",
+		.stream_name = "Baytrail Compress",
+		.cpu_dai_name = "Compress-cpu-dai",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.platform_name = "sst-platform",
+		.compr_ops = &byt_compr_ops,
+	},
+	[BYT_DPCM_VOIP] = {
+		.name = "Baytrail VOIP Port",
+		.stream_name = "Baytrail Voip",
+		.cpu_dai_name = "Voip-cpu-dai",
+		.platform_name = "sst-platform",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.init = NULL,
+		.ignore_suspend = 1,
+		.ops = &byt_8k_16k_ops,
+		.dynamic = 1,
+	},
+	[BYT_DPCM_PROBE] = {
+		.name = "Baytrail Probe Port",
+		.stream_name = "Baytrail Probe",
+		.cpu_dai_name = "Probe-cpu-dai",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.platform_name = "sst-platform",
+		.playback_count = 8,
+		.capture_count = 8,
+	},
+	/* CODEC<->CODEC link */
+	{
+		.name = "Baytrail Codec-Loop Port",
+		.stream_name = "Baytrail Codec-Loop",
+		.cpu_dai_name = "ssp2-port",
+		.platform_name = "sst-platform",
+		.codec_dai_name = "rt5640-aif1",
+		.codec_name = "i2c-10EC5640:00:1c",
+		.dai_fmt = SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_IB_NF
+						| SND_SOC_DAIFMT_CBS_CFS,
+		.params = &byt_dai_params,
+		.dsp_loopback = true,
+	},
+	{
+		.name = "Baytrail Modem-Loop Port",
+		.stream_name = "Baytrail Modem-Loop",
+		.cpu_dai_name = "ssp0-port",
+		.platform_name = "sst-platform",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.params = &byt_dai_params,
+		.dsp_loopback = true,
+	},
+	{
+		.name = "Baytrail BTFM-Loop Port",
+		.stream_name = "Baytrail BTFM-Loop",
+		.cpu_dai_name = "ssp1-port",
+		.platform_name = "sst-platform",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.params = &byt_dai_params,
+		.dsp_loopback = true,
+	},
+		/* back ends */
+	{
+		.name = "SSP2-Codec",
+		.be_id = 1,
+		.cpu_dai_name = "ssp2-port",
+		.platform_name = "sst-platform",
+		.no_pcm = 1,
+		.codec_dai_name = "rt5640-aif1",
+		.codec_name = "i2c-10EC5640:00:1c",
+		.be_hw_params_fixup = byt_codec_fixup,
+		.ignore_suspend = 1,
+		.ops = &byt_be_ssp2_ops,
+	},
+	{
+		.name = "SSP1-BTFM",
+		.be_id = 2,
+		.cpu_dai_name = "snd-soc-dummy-dai",
+		.platform_name = "snd-soc-dummy",
+		.no_pcm = 1,
+		.codec_name = "snd-soc-dummy",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.ignore_suspend = 1,
+	},
+	{
+		.name = "SSP0-Modem",
+		.be_id = 3,
+		.cpu_dai_name = "snd-soc-dummy-dai",
+		.platform_name = "snd-soc-dummy",
+		.no_pcm = 1,
+		.codec_name = "snd-soc-dummy",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.ignore_suspend = 1,
+	},
+};
+
+#ifdef CONFIG_PM_SLEEP
+static int snd_byt_prepare(struct device *dev)
+{
+	pr_debug("In %s device name\n", __func__);
+	return snd_soc_suspend(dev);
+}
+
+static void snd_byt_complete(struct device *dev)
+{
+	pr_debug("In %s\n", __func__);
+	snd_soc_resume(dev);
+}
+
+static int snd_byt_poweroff(struct device *dev)
+{
+	pr_debug("In %s\n", __func__);
+	return snd_soc_poweroff(dev);
+}
+#else
+#define snd_byt_prepare NULL
+#define snd_byt_complete NULL
+#define snd_byt_poweroff NULL
+#endif
+
+/* SoC card */
+static struct snd_soc_card snd_soc_card_byt = {
+	.name = "baytrailcraudio",
+	.dai_link = byt_dailink,
+	.num_links = ARRAY_SIZE(byt_dailink),
+	.set_bias_level = byt_set_bias_level,
+	.dapm_widgets = byt_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(byt_dapm_widgets),
+	.dapm_routes = byt_audio_map,
+	.num_dapm_routes = ARRAY_SIZE(byt_audio_map),
+};
+
+static int snd_byt_mc_probe(struct platform_device *pdev)
+{
+	int ret_val = 0;
+	struct byt_mc_private *drv;
+	int codec_gpio;
+
+	pr_debug("Entry %s\n", __func__);
+	pr_err("My log1\n");
+	drv = devm_kzalloc(&pdev->dev, sizeof(*drv), GFP_ATOMIC);
+	if (!drv) {
+		pr_err("allocation failed\n");
+		return -ENOMEM;
+	}
+	/* get the codec -> SoC GPIO */
+	/* FIXME: Hard coding this to 86. This should come from DSDT. Currently
+	   there is not ACPI entry for machine driver */
+	codec_gpio = 86;
+	pr_info("%s: GPIOs - codec %d", __func__, codec_gpio);
+	hs_gpio[BYT_CODEC_GPIO_IDX].gpio = codec_gpio;
+
+	drv->hs_insert_det_delay = BYT_HS_INSERT_DET_DELAY;
+	drv->hs_remove_det_delay = BYT_HS_REMOVE_DET_DELAY;
+	drv->button_det_delay = BYT_BUTTON_DET_DELAY;
+	drv->hs_det_poll_intrvl = BYT_HS_DET_POLL_INTRVL;
+	drv->hs_det_retry = BYT_HS_DET_RETRY_COUNT;
+	drv->button_en_delay = BYT_BUTTON_EN_DELAY;
+	drv->process_button_events = false;
+
+	INIT_DELAYED_WORK(&drv->hs_insert_work, byt_check_hs_insert_status);
+	INIT_DELAYED_WORK(&drv->hs_remove_work, byt_check_hs_remove_status);
+	INIT_DELAYED_WORK(&drv->hs_button_work, byt_check_hs_button_status);
+	INIT_DELAYED_WORK(&drv->hs_button_en_work, byt_enable_hs_button_events);
+	mutex_init(&drv->jack_mlock);
+	drv->tristate_buffer_gpio = -1;
+	drv->num_jack_gpios = 1;
+	drv->use_soc_jd_gpio = false;
+
+	/* register the soc card */
+	snd_soc_card_byt.dev = &pdev->dev;
+	snd_soc_card_set_drvdata(&snd_soc_card_byt, drv);
+
+	ret_val = snd_soc_register_card(&snd_soc_card_byt);
+	if (ret_val) {
+		pr_err("snd_soc_register_card failed %d\n", ret_val);
+		return ret_val;
+	}
+	platform_set_drvdata(pdev, &snd_soc_card_byt);
+	pr_info("%s successful\n", __func__);
+	return ret_val;
+}
+
+static void snd_byt_unregister_jack(struct byt_mc_private *ctx)
+{
+       /* Set process button events to false so that the button
+	   delayed work will not be scheduled.*/
+	ctx->process_button_events = false;
+	cancel_delayed_work_sync(&ctx->hs_insert_work);
+	cancel_delayed_work_sync(&ctx->hs_button_en_work);
+	cancel_delayed_work_sync(&ctx->hs_button_work);
+	cancel_delayed_work_sync(&ctx->hs_remove_work);
+	snd_soc_jack_free_gpios(&ctx->jack, ctx->num_jack_gpios, hs_gpio);
+
+}
+static int snd_byt_mc_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *soc_card = platform_get_drvdata(pdev);
+	struct byt_mc_private *drv = snd_soc_card_get_drvdata(soc_card);
+
+	pr_debug("In %s\n", __func__);
+
+	snd_byt_unregister_jack(drv);
+	snd_soc_card_set_drvdata(soc_card, NULL);
+	snd_soc_unregister_card(soc_card);
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+static void snd_byt_mc_shutdown(struct platform_device *pdev)
+{
+	struct snd_soc_card *soc_card = platform_get_drvdata(pdev);
+	struct byt_mc_private *drv = snd_soc_card_get_drvdata(soc_card);
+
+	pr_debug("In %s\n", __func__);
+	snd_byt_unregister_jack(drv);
+}
+
+static const struct dev_pm_ops snd_byt_mc_pm_ops = {
+	.prepare = snd_byt_prepare,
+	.complete = snd_byt_complete,
+	.poweroff = snd_byt_poweroff,
+};
+
+static const struct acpi_device_id byt_mc_acpi_ids[] = {
+	{ "AMCR0F28", 0 },
+	{},
+};
+MODULE_DEVICE_TABLE(acpi, byt_mc_acpi_ids);
+
+static struct platform_driver snd_byt_mc_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "byt_rt5640",
+		.pm = &snd_byt_mc_pm_ops,
+	},
+	.probe = snd_byt_mc_probe,
+	.remove = snd_byt_mc_remove,
+	.shutdown = snd_byt_mc_shutdown,
+};
+
+static int __init snd_byt_driver_init(void)
+{
+	int ret;
+	ret = platform_driver_register(&snd_byt_mc_driver);
+	if (ret)
+		pr_err("Fail to register Baytrail Machine driver byt_rt5640\n");
+	else
+		pr_info("Baytrail Machine Driver byt_rt5640 registerd\n");
+	return ret;
+}
+late_initcall(snd_byt_driver_init);
+
+static void __exit snd_byt_driver_exit(void)
+{
+	pr_debug("In %s\n", __func__);
+	platform_driver_unregister(&snd_byt_mc_driver);
+}
+module_exit(snd_byt_driver_exit);
+
+MODULE_DESCRIPTION("ASoC Intel(R) Baytrail CR Machine driver");
+MODULE_AUTHOR("Subhransu S. Prusty <subhransu.s.prusty@intel.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:bytrt5640-audio");
diff --git a/sound/soc/intel/compress.c b/sound/soc/intel/compress.c
new file mode 100644
index 0000000..1938c11
--- /dev/null
+++ b/sound/soc/intel/compress.c
@@ -0,0 +1,250 @@
+/*
+ *  compress.c - Intel MID Platform driver for Compress stream operations
+ *
+ *  Copyright (C) 2010-2013 Intel Corp
+ *  Author: Vinod Koul <vinod.koul@intel.com>
+ *  Author: Harsha Priya <priya.harsha@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *
+ */
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <sound/soc.h>
+#include <sound/intel_sst_ioctl.h>
+#include "platform_ipc_v2.h"
+#include "sst_platform.h"
+#include "sst_platform_pvt.h"
+
+static void sst_compr_fragment_elapsed(void *arg)
+{
+	struct snd_compr_stream *cstream = (struct snd_compr_stream *)arg;
+
+	pr_debug("fragment elapsed by driver\n");
+	if (cstream)
+		snd_compr_fragment_elapsed(cstream);
+}
+
+static void sst_drain_notify(void *arg)
+{
+	struct snd_compr_stream *cstream = (struct snd_compr_stream *)arg;
+
+	pr_debug("drain notify by driver\n");
+	if (cstream)
+		snd_compr_drain_notify(cstream);
+}
+
+static int sst_platform_compr_open(struct snd_compr_stream *cstream)
+{
+
+	int ret_val = 0;
+	struct snd_compr_runtime *runtime = cstream->runtime;
+	struct sst_runtime_stream *stream;
+	struct snd_soc_pcm_runtime *rtd = cstream->private_data;
+	struct snd_soc_dai_link *dai_link = rtd->dai_link;
+
+	pr_debug("%s called:%s\n", __func__, dai_link->cpu_dai_name);
+
+	stream = kzalloc(sizeof(*stream), GFP_KERNEL);
+	if (!stream)
+		return -ENOMEM;
+
+	spin_lock_init(&stream->status_lock);
+
+	/* get the sst ops */
+	if (!sst_dsp || !try_module_get(sst_dsp->dev->driver->owner)) {
+		pr_err("no device available to run\n");
+		ret_val = -ENODEV;
+		goto out_ops;
+	}
+	stream->compr_ops = sst_dsp->compr_ops;
+
+	stream->id = 0;
+	sst_set_stream_status(stream, SST_PLATFORM_INIT);
+	runtime->private_data = stream;
+	return 0;
+out_ops:
+	kfree(stream);
+	return ret_val;
+}
+
+static int sst_platform_compr_free(struct snd_compr_stream *cstream)
+{
+	struct sst_runtime_stream *stream;
+	struct snd_soc_pcm_runtime *rtd = cstream->private_data;
+	struct snd_soc_dai_link *dai_link = rtd->dai_link;
+	int ret_val = 0, str_id;
+
+	stream = cstream->runtime->private_data;
+	/*need to check*/
+	str_id = stream->id;
+	if (str_id)
+		ret_val = stream->compr_ops->close(str_id);
+	module_put(sst_dsp->dev->driver->owner);
+	kfree(stream);
+	pr_debug("%s called for dai %s: ret = %d\n", __func__,
+				dai_link->cpu_dai_name, ret_val);
+	return 0;
+}
+
+static int sst_platform_compr_set_params(struct snd_compr_stream *cstream,
+					struct snd_compr_params *params)
+{
+	struct sst_runtime_stream *stream;
+	int retval = 0;
+	struct snd_sst_params str_params;
+	struct sst_compress_cb cb;
+	struct snd_soc_pcm_runtime *rtd = cstream->private_data;
+	struct snd_soc_platform *platform = rtd->platform;
+	struct sst_data *ctx = snd_soc_platform_get_drvdata(platform);
+
+	pr_debug("In function %s\n", __func__);
+	stream = cstream->runtime->private_data;
+	/* construct fw structure for this*/
+	memset(&str_params, 0, sizeof(str_params));
+
+	/* fill the device type and stream id to pass to SST driver */
+	retval = sst_fill_stream_params(cstream, ctx, &str_params, true);
+	pr_debug("compr_set_params: fill stream params ret_val = 0x%x\n", retval);
+	if (retval < 0)
+		return retval;
+
+	switch (params->codec.id) {
+	case SND_AUDIOCODEC_MP3: {
+		str_params.codec = SST_CODEC_TYPE_MP3;
+		str_params.sparams.uc.mp3_params.num_chan = params->codec.ch_in;
+		str_params.sparams.uc.mp3_params.pcm_wd_sz = 16;
+		break;
+	}
+
+	case SND_AUDIOCODEC_AAC: {
+		str_params.codec = SST_CODEC_TYPE_AAC;
+		str_params.sparams.uc.aac_params.num_chan = params->codec.ch_in;
+		str_params.sparams.uc.aac_params.pcm_wd_sz = 16;
+		if (params->codec.format == SND_AUDIOSTREAMFORMAT_MP4ADTS)
+			str_params.sparams.uc.aac_params.bs_format =
+							AAC_BIT_STREAM_ADTS;
+		else if (params->codec.format == SND_AUDIOSTREAMFORMAT_RAW)
+			str_params.sparams.uc.aac_params.bs_format =
+							AAC_BIT_STREAM_RAW;
+		else {
+			pr_err("Undefined format%d\n", params->codec.format);
+			return -EINVAL;
+		}
+		str_params.sparams.uc.aac_params.externalsr =
+						params->codec.sample_rate;
+		break;
+	}
+
+	default:
+		pr_err("codec not supported, id =%d\n", params->codec.id);
+		return -EINVAL;
+	}
+
+	str_params.aparams.ring_buf_info[0].addr  =
+					virt_to_phys(cstream->runtime->buffer);
+	str_params.aparams.ring_buf_info[0].size =
+					cstream->runtime->buffer_size;
+	str_params.aparams.sg_count = 1;
+	str_params.aparams.frag_size = cstream->runtime->fragment_size;
+
+	cb.param = cstream;
+	cb.compr_cb = sst_compr_fragment_elapsed;
+	cb.drain_cb_param = cstream;
+	cb.drain_notify = sst_drain_notify;
+
+	retval = stream->compr_ops->open(&str_params, &cb);
+	if (retval < 0) {
+		pr_err("stream allocation failed %d\n", retval);
+		return retval;
+	}
+
+	stream->id = retval;
+	return 0;
+}
+
+static int sst_platform_compr_trigger(struct snd_compr_stream *cstream, int cmd)
+{
+	struct sst_runtime_stream *stream =
+		cstream->runtime->private_data;
+
+	return stream->compr_ops->control(cmd, stream->id);
+}
+
+static int sst_platform_compr_pointer(struct snd_compr_stream *cstream,
+					struct snd_compr_tstamp *tstamp)
+{
+	struct sst_runtime_stream *stream;
+
+	stream  = cstream->runtime->private_data;
+	stream->compr_ops->tstamp(stream->id, tstamp);
+	tstamp->byte_offset = tstamp->copied_total %
+				 (u32)cstream->runtime->buffer_size;
+	pr_debug("calc bytes offset/copied bytes as %d\n", tstamp->byte_offset);
+	return 0;
+}
+
+static int sst_platform_compr_ack(struct snd_compr_stream *cstream,
+					size_t bytes)
+{
+	struct sst_runtime_stream *stream;
+
+	stream  = cstream->runtime->private_data;
+	stream->compr_ops->ack(stream->id, (unsigned long)bytes);
+	stream->bytes_written += bytes;
+
+	return 0;
+}
+
+static int sst_platform_compr_get_caps(struct snd_compr_stream *cstream,
+					struct snd_compr_caps *caps)
+{
+	struct sst_runtime_stream *stream =
+		cstream->runtime->private_data;
+
+	return stream->compr_ops->get_caps(caps);
+}
+
+static int sst_platform_compr_get_codec_caps(struct snd_compr_stream *cstream,
+					struct snd_compr_codec_caps *codec)
+{
+	struct sst_runtime_stream *stream =
+		cstream->runtime->private_data;
+
+	return stream->compr_ops->get_codec_caps(codec);
+}
+
+static int sst_platform_compr_set_metadata(struct snd_compr_stream *cstream,
+					struct snd_compr_metadata *metadata)
+{
+	struct sst_runtime_stream *stream  =
+		 cstream->runtime->private_data;
+
+	return stream->compr_ops->set_metadata(stream->id, metadata);
+}
+
+struct snd_compr_ops sst_platform_compr_ops = {
+
+	.open = sst_platform_compr_open,
+	.free = sst_platform_compr_free,
+	.set_params = sst_platform_compr_set_params,
+	.set_metadata = sst_platform_compr_set_metadata,
+	.trigger = sst_platform_compr_trigger,
+	.pointer = sst_platform_compr_pointer,
+	.ack = sst_platform_compr_ack,
+	.get_caps = sst_platform_compr_get_caps,
+	.get_codec_caps = sst_platform_compr_get_codec_caps,
+};
diff --git a/sound/soc/intel/effects.c b/sound/soc/intel/effects.c
new file mode 100644
index 0000000..51500e4
--- /dev/null
+++ b/sound/soc/intel/effects.c
@@ -0,0 +1,402 @@
+/*
+ *  effects.c - platform file for effects interface
+ *
+ *  Copyright (C) 2013 Intel Corporation
+ *  Authors:	Samreen Nilofer <samreen.nilofer@intel.com>
+ *		Vinod Koul <vinod.koul@intel.com>
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ */
+#include <linux/slab.h>
+#include <asm/platform_sst_audio.h>
+#include "platform_ipc_v2.h"
+#include "sst_platform.h"
+#include "sst_platform_pvt.h"
+
+extern struct sst_device *sst_dsp;
+extern struct device *sst_pdev;
+
+struct effect_uuid {
+	uint32_t timeLow;
+	uint16_t timeMid;
+	uint16_t timeHiAndVersion;
+	uint16_t clockSeq;
+	uint8_t node[6];
+};
+
+#define EFFECT_STRING_LEN_MAX 64
+
+enum sst_effect {
+	EFFECTS_CREATE = 0,
+	EFFECTS_DESTROY,
+	EFFECTS_SET_PARAMS,
+	EFFECTS_GET_PARAMS,
+};
+
+enum sst_mixer_output_mode {
+	SST_MEDIA0_OUT,
+	SST_MEDIA1_OUT,
+};
+
+static inline void sst_fill_byte_stream(struct snd_sst_bytes_v2 *bytes, u8 type,
+			u8 msg, u8 block, u8 task, u8 pipe_id, u16 len,
+			struct ipc_effect_payload *payload)
+{
+	u32 size = sizeof(struct ipc_effect_dsp_hdr);
+
+	bytes->type = type;
+	bytes->ipc_msg = msg;
+	bytes->block = block;
+	bytes->task_id = task;
+	bytes->pipe_id = pipe_id;
+	bytes->len = len;
+
+	/* Copy the ipc_effect_dsp_hdr followed by the data */
+	memcpy(bytes->bytes, payload, size);
+	memcpy(bytes->bytes + size, payload->data, len - size);
+}
+
+static int sst_send_effects(struct ipc_effect_payload *dsp_payload, int data_len,
+					enum sst_effect effect_type)
+{
+	struct snd_sst_bytes_v2 *bytes;
+	u32 len;
+	int ret;
+	u8 type, msg = IPC_INVALID, pipe, payload_len;
+	struct sst_data *sst;
+
+	if (!sst_pdev)
+		return -ENODEV;
+	sst =  dev_get_drvdata(sst_pdev);
+
+	len = sizeof(*bytes) + sizeof(struct ipc_effect_dsp_hdr) + data_len;
+
+	bytes = kzalloc(len, GFP_KERNEL);
+	if (!bytes) {
+		pr_err("kzalloc failed allocate bytes\n");
+		return -ENOMEM;
+	}
+
+	switch (effect_type) {
+	case EFFECTS_CREATE:
+	case EFFECTS_DESTROY:
+		type = SND_SST_BYTES_SET;
+		msg = IPC_CMD;
+		break;
+
+	case EFFECTS_SET_PARAMS:
+		type = SND_SST_BYTES_SET;
+		msg = IPC_SET_PARAMS;
+		break;
+
+	case EFFECTS_GET_PARAMS:
+		type = SND_SST_BYTES_GET;
+		msg =  IPC_GET_PARAMS;
+		break;
+	default:
+		pr_err("No such effect %#x", effect_type);
+		ret = -EINVAL;
+		goto free_bytes;
+	}
+
+	pipe = dsp_payload->dsp_hdr.pipe_id;
+	payload_len = sizeof(struct ipc_effect_dsp_hdr) + data_len;
+	sst_fill_byte_stream(bytes, type, msg, 1, SST_TASK_ID_MEDIA,
+				pipe, payload_len, dsp_payload);
+
+	mutex_lock(&sst->lock);
+	ret = sst_dsp->ops->set_generic_params(SST_SET_BYTE_STREAM, bytes);
+	mutex_unlock(&sst->lock);
+
+	if (ret) {
+		pr_err("byte_stream failed err %d pipe_id %#x\n", ret,
+				dsp_payload->dsp_hdr.pipe_id);
+		goto free_bytes;
+	}
+
+	/* Copy only the data - skip the dsp header */
+	if (msg == IPC_GET_PARAMS)
+		memcpy(dsp_payload->data, bytes->bytes, data_len);
+
+free_bytes:
+	kfree(bytes);
+	return ret;
+}
+
+static int sst_get_algo_id(const struct sst_dev_effects *pdev_effs,
+					char *uuid, u16 *algo_id)
+{
+	int i, len;
+
+	len = pdev_effs->effs_num_map;
+
+	for (i = 0; i < len; i++) {
+		if (!strncmp(pdev_effs->effs_map[i].uuid, uuid, sizeof(struct effect_uuid))) {
+			*algo_id = pdev_effs->effs_map[i].algo_id;
+			return 0;
+		}
+	}
+	pr_err("no such uuid\n");
+	return -EINVAL;
+}
+
+static int sst_fill_effects_info(const struct sst_dev_effects *pdev_effs,
+					char *uuid, u16 pos,
+					struct ipc_dsp_effects_info *effs_info, u16 cmd_id)
+{
+	int i, len;
+
+	len = pdev_effs->effs_num_map;
+
+	for (i = 0; i < len; i++) {
+		if (!strncmp(pdev_effs->effs_map[i].uuid, uuid, sizeof(struct effect_uuid))) {
+
+			effs_info->cmd_id = cmd_id;
+			effs_info->length = (sizeof(struct ipc_dsp_effects_info) -
+						offsetof(struct ipc_dsp_effects_info, sel_pos));
+			effs_info->sel_pos = pos;
+			effs_info->sel_algo_id = pdev_effs->effs_map[i].algo_id;
+			effs_info->cpu_load = pdev_effs->effs_res_map[i].cpuLoad;
+			effs_info->memory_usage = pdev_effs->effs_res_map[i].memoryUsage;
+			effs_info->flags = pdev_effs->effs_res_map[i].flags;
+
+			return 0;
+		}
+	}
+
+	pr_err("no such uuid\n");
+	return -EINVAL;
+}
+
+static inline void sst_fill_dsp_payload(struct ipc_effect_payload *dsp_payload,
+					u8 pipe_id, u16 mod_id, char *data)
+{
+	dsp_payload->dsp_hdr.mod_index_id = 0xFF;
+	dsp_payload->dsp_hdr.pipe_id = pipe_id;
+	dsp_payload->dsp_hdr.mod_id = mod_id;
+	dsp_payload->data = data;
+}
+
+static int sst_get_pipe_id(struct sst_dev_stream_map *map, int map_size,
+				u32 dev, u32 mode, u8 *pipe_id)
+{
+	int index;
+
+	if (map == NULL)
+		return -EINVAL;
+
+	/* In case of global effects, dev will be 0xff */
+	if (dev == 0xFF) {
+		*pipe_id = (mode == SST_MEDIA0_OUT) ? PIPE_MEDIA0_OUT : PIPE_MEDIA1_OUT;
+		return 0;
+	}
+
+	for (index = 1; index < map_size; index++) {
+		if (map[index].dev_num == dev) {
+			*pipe_id = map[index].device_id;
+			break;
+		}
+	}
+
+	if (index == map_size) {
+		pr_err("no such device %d\n", dev);
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static int sst_effects_create(struct snd_card *card, struct snd_effect *effect)
+{
+	int ret = 0;
+	u8 pipe_id;
+	struct ipc_effect_payload dsp_payload;
+	struct ipc_dsp_effects_info effects_info;
+	struct sst_data *sst;
+
+	if (!sst_pdev)
+		return -ENODEV;
+	sst =  dev_get_drvdata(sst_pdev);
+
+	ret = sst_fill_effects_info(&sst->pdata->pdev_effs, effect->uuid, effect->pos,
+				 &effects_info, IPC_EFFECTS_CREATE);
+	if (ret < 0)
+		return ret;
+
+	ret = sst_get_pipe_id(sst->pdata->pdev_strm_map,
+				sst->pdata->strm_map_size,
+				effect->device, effect->mode, &pipe_id);
+	if (ret < 0)
+		return ret;
+
+	sst_fill_dsp_payload(&dsp_payload, pipe_id, 0xFF, (char *)&effects_info);
+
+	ret = sst_send_effects(&dsp_payload, sizeof(effects_info), EFFECTS_CREATE);
+
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int sst_effects_destroy(struct snd_card *card, struct snd_effect *effect)
+{
+	int ret = 0;
+	u8 pipe_id;
+	struct ipc_effect_payload dsp_payload;
+	struct ipc_dsp_effects_info effects_info;
+	struct sst_data *sst;
+
+	if (!sst_pdev)
+		return -ENODEV;
+	sst =  dev_get_drvdata(sst_pdev);
+
+	ret = sst_fill_effects_info(&sst->pdata->pdev_effs, effect->uuid, effect->pos,
+				&effects_info, IPC_EFFECTS_DESTROY);
+	if (ret < 0)
+		return ret;
+
+	ret = sst_get_pipe_id(sst->pdata->pdev_strm_map,
+				sst->pdata->strm_map_size,
+				effect->device, effect->mode, &pipe_id);
+	if (ret < 0)
+		return ret;
+
+	sst_fill_dsp_payload(&dsp_payload, pipe_id, 0xFF, (char *)&effects_info);
+
+	ret = sst_send_effects(&dsp_payload, sizeof(effects_info), EFFECTS_DESTROY);
+
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int sst_effects_set_params(struct snd_card *card,
+					struct snd_effect_params *params)
+{
+	int ret = 0;
+	u8 pipe_id;
+	u16 algo_id;
+	struct ipc_effect_payload dsp_payload;
+	struct sst_data *sst;
+
+	if (!sst_pdev)
+		return -ENODEV;
+	sst =  dev_get_drvdata(sst_pdev);
+
+	ret = sst_get_algo_id(&sst->pdata->pdev_effs, params->uuid, &algo_id);
+	if (ret < 0)
+		return ret;
+
+	ret = sst_get_pipe_id(sst->pdata->pdev_strm_map,
+				sst->pdata->strm_map_size,
+				params->device, SST_MEDIA0_OUT, &pipe_id);
+	if (ret < 0)
+		return ret;
+
+	sst_fill_dsp_payload(&dsp_payload, pipe_id, algo_id,
+			(void *)(unsigned long)params->buffer_ptr);
+
+	ret = sst_send_effects(&dsp_payload, params->size, EFFECTS_SET_PARAMS);
+
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int sst_effects_get_params(struct snd_card *card,
+					struct snd_effect_params *params)
+{
+	int ret = 0;
+	u8 pipe_id;
+	u16 algo_id;
+	struct ipc_effect_payload dsp_payload;
+	struct sst_data *sst;
+
+	if (!sst_pdev)
+		return -ENODEV;
+	sst =  dev_get_drvdata(sst_pdev);
+
+	ret = sst_get_algo_id(&sst->pdata->pdev_effs, params->uuid, &algo_id);
+	if (ret < 0)
+		return ret;
+
+	ret = sst_get_pipe_id(sst->pdata->pdev_strm_map,
+				sst->pdata->strm_map_size,
+				params->device, SST_MEDIA0_OUT, &pipe_id);
+	if (ret < 0)
+		return ret;
+
+	sst_fill_dsp_payload(&dsp_payload, pipe_id, algo_id,
+			(void *)(unsigned long)params->buffer_ptr);
+
+	ret = sst_send_effects(&dsp_payload, params->size, EFFECTS_GET_PARAMS);
+
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int sst_query_num_effects(struct snd_card *card)
+{
+	struct sst_data *sst;
+
+	if (!sst_pdev)
+		return -ENODEV;
+	sst =  dev_get_drvdata(sst_pdev);
+
+	return sst->pdata->pdev_effs.effs_num_map;
+}
+
+static int sst_query_effects_caps(struct snd_card *card,
+					struct snd_effect_caps *caps)
+{
+	struct sst_data *sst;
+	struct sst_dev_effects_map *effs_map;
+	unsigned int num_effects, offset = 0;
+	char *dstn;
+	int i;
+
+	if (!sst_pdev)
+		return -ENODEV;
+	sst =  dev_get_drvdata(sst_pdev);
+
+	effs_map = sst->pdata->pdev_effs.effs_map;
+	num_effects = sst->pdata->pdev_effs.effs_num_map;
+
+	if (caps->size < (num_effects * MAX_DESCRIPTOR_SIZE)) {
+		pr_err("buffer size is insufficient\n");
+		return -ENOMEM;
+	}
+
+	dstn = (void *)(unsigned long)caps->buffer_ptr;
+	for (i = 0; i < num_effects; i++) {
+		memcpy(dstn + offset, effs_map[i].descriptor, MAX_DESCRIPTOR_SIZE);
+		offset += MAX_DESCRIPTOR_SIZE;
+	}
+	caps->size = offset;
+
+	return 0;
+}
+
+struct snd_effect_ops effects_ops = {
+	.create = sst_effects_create,
+	.destroy = sst_effects_destroy,
+	.set_params = sst_effects_set_params,
+	.get_params = sst_effects_get_params,
+	.query_num_effects = sst_query_num_effects,
+	.query_effect_caps = sst_query_effects_caps,
+};
diff --git a/sound/soc/intel/pcm.c b/sound/soc/intel/pcm.c
new file mode 100644
index 0000000..6335c47
--- /dev/null
+++ b/sound/soc/intel/pcm.c
@@ -0,0 +1,1119 @@
+
+/*
+ *  pcm.c - Intel MID Platform driver file implementing PCM functionality
+ *
+ *  Copyright (C) 2010-2013 Intel Corp
+ *  Author: Vinod Koul <vinod.koul@intel.com>
+ *  Author: Harsha Priya <priya.harsha@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *
+ */
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/intel_sst_ioctl.h>
+#include <asm/platform_sst_audio.h>
+#include <asm/intel_sst_mrfld.h>
+#include <asm/intel-mid.h>
+#include "platform_ipc_v2.h"
+#include "sst_platform.h"
+#include "sst_platform_pvt.h"
+
+struct device *sst_pdev;
+struct sst_device *sst_dsp;
+extern struct snd_compr_ops sst_platform_compr_ops;
+extern struct snd_effect_ops effects_ops;
+
+/* module parameters */
+static int dpcm_enable = 1;
+
+/* dpcm_enable should be =0 for mofd_v0 and =1 for mofd_v1 */
+module_param(dpcm_enable, int, 0644);
+MODULE_PARM_DESC(dpcm_enable, "DPCM module parameter");
+
+static DEFINE_MUTEX(sst_dsp_lock);
+
+static struct snd_pcm_hardware sst_platform_pcm_hw = {
+	.info =	(SNDRV_PCM_INFO_INTERLEAVED |
+			SNDRV_PCM_INFO_DOUBLE |
+			SNDRV_PCM_INFO_PAUSE |
+			SNDRV_PCM_INFO_RESUME |
+			SNDRV_PCM_INFO_MMAP|
+			SNDRV_PCM_INFO_MMAP_VALID |
+			SNDRV_PCM_INFO_BLOCK_TRANSFER |
+			SNDRV_PCM_INFO_SYNC_START),
+	.formats = (SNDRV_PCM_FMTBIT_S16 | SNDRV_PCM_FMTBIT_U16 |
+			SNDRV_PCM_FMTBIT_S24 | SNDRV_PCM_FMTBIT_U24 |
+			SNDRV_PCM_FMTBIT_S32 | SNDRV_PCM_FMTBIT_U32),
+	.rates = (SNDRV_PCM_RATE_8000|
+			SNDRV_PCM_RATE_16000 |
+			SNDRV_PCM_RATE_44100 |
+			SNDRV_PCM_RATE_48000),
+	.rate_min = SST_MIN_RATE,
+	.rate_max = SST_MAX_RATE,
+	.channels_min =	SST_MIN_CHANNEL,
+	.channels_max =	SST_MAX_CHANNEL,
+	.buffer_bytes_max = SST_MAX_BUFFER,
+	.period_bytes_min = SST_MIN_PERIOD_BYTES,
+	.period_bytes_max = SST_MAX_PERIOD_BYTES,
+	.periods_min = SST_MIN_PERIODS,
+	.periods_max = SST_MAX_PERIODS,
+	.fifo_size = SST_FIFO_SIZE,
+};
+
+static struct sst_dev_stream_map dpcm_strm_map[] = {
+	{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, /* Reserved, not in use */
+	{MERR_DPCM_AUDIO, 0, SNDRV_PCM_STREAM_PLAYBACK, PIPE_MEDIA1_IN, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_DB,    0, SNDRV_PCM_STREAM_PLAYBACK, PIPE_MEDIA3_IN, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_LL,    0, SNDRV_PCM_STREAM_PLAYBACK, PIPE_LOW_PCM0_IN, SST_TASK_ID_SBA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_COMPR, 0, SNDRV_PCM_STREAM_PLAYBACK, PIPE_MEDIA0_IN, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_VOIP,  0, SNDRV_PCM_STREAM_PLAYBACK, PIPE_VOIP_IN, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 0, SNDRV_PCM_STREAM_PLAYBACK, PIPE_PROBE1_IN, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 1, SNDRV_PCM_STREAM_PLAYBACK, PIPE_PROBE2_IN, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 2, SNDRV_PCM_STREAM_PLAYBACK, PIPE_PROBE3_IN, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 3, SNDRV_PCM_STREAM_PLAYBACK, PIPE_PROBE4_IN, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 4, SNDRV_PCM_STREAM_PLAYBACK, PIPE_PROBE5_IN, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 5, SNDRV_PCM_STREAM_PLAYBACK, PIPE_PROBE6_IN, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 6, SNDRV_PCM_STREAM_PLAYBACK, PIPE_PROBE7_IN, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 7, SNDRV_PCM_STREAM_PLAYBACK, PIPE_PROBE8_IN, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_AUDIO, 0, SNDRV_PCM_STREAM_CAPTURE, PIPE_PCM1_OUT, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_VOIP,  0, SNDRV_PCM_STREAM_CAPTURE, PIPE_VOIP_OUT, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 0, SNDRV_PCM_STREAM_CAPTURE, PIPE_PROBE1_OUT, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 1, SNDRV_PCM_STREAM_CAPTURE, PIPE_PROBE2_OUT, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 2, SNDRV_PCM_STREAM_CAPTURE, PIPE_PROBE3_OUT, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 3, SNDRV_PCM_STREAM_CAPTURE, PIPE_PROBE4_OUT, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 4, SNDRV_PCM_STREAM_CAPTURE, PIPE_PROBE5_OUT, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 5, SNDRV_PCM_STREAM_CAPTURE, PIPE_PROBE6_OUT, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 6, SNDRV_PCM_STREAM_CAPTURE, PIPE_PROBE7_OUT, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 7, SNDRV_PCM_STREAM_CAPTURE, PIPE_PROBE8_OUT, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	/* stream ID 25 used by Aware, but no device exposed to userspace */
+};
+
+static int sst_platform_ihf_set_tdm_slot(struct snd_soc_dai *dai,
+			unsigned int tx_mask, unsigned int rx_mask,
+			int slots, int slot_width) {
+	struct snd_sst_runtime_params params_data;
+	int channels = slots;
+
+	/* registering with SST driver to get access to SST APIs to use */
+	if (!sst_dsp) {
+		pr_err("sst: DSP not registered\n");
+		return -EIO;
+	}
+	params_data.type = SST_SET_CHANNEL_INFO;
+	params_data.str_id = SND_SST_DEVICE_IHF;
+	params_data.size = sizeof(channels);
+	params_data.addr = &channels;
+	return sst_dsp->ops->set_generic_params(SST_SET_RUNTIME_PARAMS,
+							(void *)&params_data);
+}
+
+static int sst_media_digital_mute(struct snd_soc_dai *dai, int mute, int stream)
+{
+
+	pr_debug("%s: enter, mute=%d dai-name=%s dir=%d\n", __func__, mute, dai->name, stream);
+
+	if (dpcm_enable == 1)
+		sst_send_pipe_gains(dai, stream, mute);
+
+	return 0;
+}
+
+/* helper functions */
+void sst_set_stream_status(struct sst_runtime_stream *stream,
+					int state)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&stream->status_lock, flags);
+	stream->stream_status = state;
+	spin_unlock_irqrestore(&stream->status_lock, flags);
+}
+
+static inline int sst_get_stream_status(struct sst_runtime_stream *stream)
+{
+	int state;
+	unsigned long flags;
+
+	spin_lock_irqsave(&stream->status_lock, flags);
+	state = stream->stream_status;
+	spin_unlock_irqrestore(&stream->status_lock, flags);
+	return state;
+}
+
+static void sst_fill_alloc_params(struct snd_pcm_substream *substream,
+				struct snd_sst_alloc_params_ext *alloc_param)
+{
+	unsigned int channels;
+	snd_pcm_uframes_t period_size;
+	ssize_t periodbytes;
+	ssize_t buffer_bytes = snd_pcm_lib_buffer_bytes(substream);
+
+	u32 buffer_addr = virt_to_phys(substream->dma_buffer.area);
+
+	pr_err("phy_to_virt: %p\n", phys_to_virt(buffer_addr));
+	pr_err("Virtual address: %p\n", substream->dma_buffer.area);
+
+	channels = substream->runtime->channels;
+	period_size = substream->runtime->period_size;
+	periodbytes = samples_to_bytes(substream->runtime, period_size);
+	alloc_param->ring_buf_info[0].addr = buffer_addr;
+	alloc_param->ring_buf_info[0].size = buffer_bytes;
+	alloc_param->sg_count = 1;
+	alloc_param->reserved = 0;
+	alloc_param->frag_size = periodbytes * channels;
+
+	pr_debug("period_size = %d\n", alloc_param->frag_size);
+	pr_debug("ring_buf_addr = 0x%x\n", alloc_param->ring_buf_info[0].addr);
+}
+static void sst_fill_pcm_params(struct snd_pcm_substream *substream,
+				struct snd_sst_stream_params *param)
+{
+	param->uc.pcm_params.num_chan = (u8) substream->runtime->channels;
+	param->uc.pcm_params.pcm_wd_sz = substream->runtime->sample_bits;
+	param->uc.pcm_params.sfreq = substream->runtime->rate;
+
+	/* PCM stream via ALSA interface */
+	param->uc.pcm_params.use_offload_path = 0;
+	param->uc.pcm_params.reserved2 = 0;
+	memset(param->uc.pcm_params.channel_map, 0, sizeof(u8));
+	pr_debug("sfreq= %d, wd_sz = %d\n",
+	param->uc.pcm_params.sfreq, param->uc.pcm_params.pcm_wd_sz);
+
+}
+
+#define ASSIGN_PIPE_ID(periodtime, lowlatency, deepbuffer) \
+	((periodtime) <= (lowlatency) ? PIPE_LOW_PCM0_IN : \
+	((periodtime) >= (deepbuffer) ? PIPE_MEDIA3_IN : PIPE_MEDIA1_IN))
+
+static int sst_get_stream_mapping(int dev, int sdev, int dir,
+	struct sst_dev_stream_map *map, int size, u8 pipe_id,
+	const struct sst_lowlatency_deepbuff *ll_db)
+{
+	int index;
+	unsigned long pt = 0, ll = 0, db = 0;
+
+	if (map == NULL)
+		return -EINVAL;
+
+	pr_debug("dev %d sdev %d dir %d\n", dev, sdev, dir);
+
+	/* index 0 is not used in stream map */
+	for (index = 1; index < size; index++) {
+		if ((map[index].dev_num == dev) &&
+		    (map[index].subdev_num == sdev) &&
+		    (map[index].direction == dir)) {
+			/* device id for the probe is assigned dynamically */
+			if (map[index].status == SST_DEV_MAP_IN_USE) {
+				return index;
+			} else if (map[index].status == SST_DEV_MAP_FREE) {
+				map[index].status = SST_DEV_MAP_IN_USE;
+
+				if (map[index].dev_num == MERR_SALTBAY_PROBE) {
+					map[index].device_id = pipe_id;
+
+				} else if (map[index].dev_num == MERR_SALTBAY_AUDIO) {
+					if (!ll_db->low_latency || !ll_db->deep_buffer)
+						return -EINVAL;
+
+					pt = ll_db->period_time;
+					ll = *(ll_db->low_latency);
+					db = *(ll_db->deep_buffer);
+
+					pr_debug("PT %lu LL %lu DB %lu\n", pt, ll, db);
+
+					map[index].device_id = ASSIGN_PIPE_ID(pt,
+								ll, db);
+				}
+				pr_debug("%s: pipe_id 0%x index %d", __func__,
+						map[index].device_id, index);
+
+				return index;
+			}
+		}
+	}
+	return 0;
+}
+
+int sst_fill_stream_params(void *substream,
+	const struct sst_data *ctx, struct snd_sst_params *str_params, bool is_compress)
+{
+	int map_size;
+	int index;
+	struct sst_dev_stream_map *map;
+	struct snd_pcm_substream *pstream = NULL;
+	struct snd_compr_stream *cstream = NULL;
+
+	map = ctx->pdata->pdev_strm_map;
+	map_size = ctx->pdata->strm_map_size;
+
+	if (is_compress == true)
+		cstream = (struct snd_compr_stream *)substream;
+	else
+		pstream = (struct snd_pcm_substream *)substream;
+
+	str_params->stream_type = SST_STREAM_TYPE_MUSIC;
+
+	/* For pcm streams */
+	if (pstream) {
+		index = sst_get_stream_mapping(pstream->pcm->device,
+					  pstream->number, pstream->stream,
+					  map, map_size, ctx->pipe_id, &ctx->ll_db);
+		if (index <= 0)
+			return -EINVAL;
+
+		str_params->stream_id = index;
+		str_params->device_type = map[index].device_id;
+		str_params->task = map[index].task_id;
+
+		if (str_params->device_type == SST_PROBE_IN)
+			str_params->stream_type = SST_STREAM_TYPE_PROBE;
+
+		pr_debug("str_id = %d, device_type = 0x%x, task = %d",
+			 str_params->stream_id, str_params->device_type,
+			 str_params->task);
+
+		str_params->ops = (u8)pstream->stream;
+	}
+
+	if (cstream) {
+		/* FIXME: Add support for subdevice number in
+		 * snd_compr_stream */
+		index = sst_get_stream_mapping(cstream->device->device,
+					       0, cstream->direction,
+					       map, map_size, ctx->pipe_id, &ctx->ll_db);
+		if (index <= 0)
+			return -EINVAL;
+		str_params->stream_id = index;
+		str_params->device_type = map[index].device_id;
+		str_params->task = map[index].task_id;
+		pr_debug("compress str_id = %d, device_type = 0x%x, task = %d",
+			 str_params->stream_id, str_params->device_type,
+			 str_params->task);
+
+		str_params->ops = (u8)cstream->direction;
+	}
+	return 0;
+}
+
+#define CALC_PERIODTIME(period_size, rate) (((period_size) * 1000) / (rate))
+
+static int sst_platform_alloc_stream(struct snd_pcm_substream *substream,
+		struct snd_soc_platform *platform)
+{
+	struct sst_runtime_stream *stream =
+			substream->runtime->private_data;
+	struct snd_sst_stream_params param = {{{0,},},};
+	struct snd_sst_params str_params = {0};
+	struct snd_sst_alloc_params_ext alloc_params = {0};
+	int ret_val = 0;
+	struct sst_data *ctx = snd_soc_platform_get_drvdata(platform);
+
+	/* set codec params and inform SST driver the same */
+	sst_fill_pcm_params(substream, &param);
+	sst_fill_alloc_params(substream, &alloc_params);
+	substream->runtime->dma_area = substream->dma_buffer.area;
+	str_params.sparams = param;
+	str_params.aparams = alloc_params;
+	str_params.codec = SST_CODEC_TYPE_PCM;
+
+	ctx->ll_db.period_time = CALC_PERIODTIME(substream->runtime->period_size,
+					substream->runtime->rate);
+
+	/* fill the device type and stream id to pass to SST driver */
+	ret_val = sst_fill_stream_params(substream, ctx, &str_params, false);
+	pr_debug("platform prepare: fill stream params ret_val = 0x%x\n", ret_val);
+	if (ret_val < 0)
+		return ret_val;
+
+	stream->stream_info.str_id = str_params.stream_id;
+
+	ret_val = stream->ops->open(&str_params);
+	pr_debug("platform prepare: stream open ret_val = 0x%x\n", ret_val);
+	if (ret_val <= 0)
+		return ret_val;
+
+	pr_debug("platform allocated strid:  %d\n", stream->stream_info.str_id);
+
+	return ret_val;
+}
+
+static void sst_period_elapsed(void *mad_substream)
+{
+	struct snd_pcm_substream *substream = mad_substream;
+	struct sst_runtime_stream *stream;
+	int status;
+
+	if (!substream || !substream->runtime) {
+		pr_debug("In %s : Null Substream pointer\n", __func__);
+		return;
+	}
+	stream = substream->runtime->private_data;
+	if (!stream) {
+		pr_debug("In %s : Null Stream pointer\n", __func__);
+		return;
+	}
+	status = sst_get_stream_status(stream);
+	if (status != SST_PLATFORM_RUNNING) {
+		pr_debug("In %s : Stream Status=%d\n", __func__, status);
+		return;
+	}
+	snd_pcm_period_elapsed(substream);
+}
+
+static int sst_platform_init_stream(struct snd_pcm_substream *substream)
+{
+	struct sst_runtime_stream *stream =
+			substream->runtime->private_data;
+	int ret_val;
+
+	pr_debug("setting buffer ptr param\n");
+	sst_set_stream_status(stream, SST_PLATFORM_INIT);
+	stream->stream_info.period_elapsed = sst_period_elapsed;
+	stream->stream_info.mad_substream = substream;
+	stream->stream_info.buffer_ptr = 0;
+	stream->stream_info.sfreq = substream->runtime->rate;
+	pr_debug("pcm_substream %p, period_elapsed %p\n",
+			stream->stream_info.mad_substream, stream->stream_info.period_elapsed);
+	ret_val = stream->ops->device_control(
+			SST_SND_STREAM_INIT, &stream->stream_info);
+	if (ret_val)
+		pr_err("control_set ret error %d\n", ret_val);
+	return ret_val;
+
+}
+
+static inline int power_up_sst(struct sst_runtime_stream *sst)
+{
+	return sst->ops->power(true);
+}
+
+static inline int power_down_sst(struct sst_runtime_stream *sst)
+{
+	return sst->ops->power(false);
+}
+/* end -- helper functions */
+
+static int sst_media_open(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	int ret_val = 0;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sst_runtime_stream *stream;
+
+	stream = kzalloc(sizeof(*stream), GFP_KERNEL);
+	if (!stream)
+		return -ENOMEM;
+
+	spin_lock_init(&stream->status_lock);
+
+	/* get the sst ops */
+	mutex_lock(&sst_dsp_lock);
+	if (!sst_dsp ||
+	    !try_module_get(sst_dsp->dev->driver->owner)) {
+		pr_err("no device available to run\n");
+		ret_val = -ENODEV;
+		goto out_ops;
+	}
+	stream->ops = sst_dsp->ops;
+	mutex_unlock(&sst_dsp_lock);
+
+	stream->stream_info.str_id = 0;
+	sst_set_stream_status(stream, SST_PLATFORM_UNINIT);
+	stream->stream_info.mad_substream = substream;
+	runtime->private_data = stream;
+
+	if (strstr(dai->name, "Power-cpu-dai"))
+		return power_up_sst(stream);
+
+	/* Make sure, that the period size is always even */
+	snd_pcm_hw_constraint_step(substream->runtime, 0,
+			   SNDRV_PCM_HW_PARAM_PERIODS, 2);
+
+	pr_debug("buf_ptr %llu\n", stream->stream_info.buffer_ptr);
+	return snd_pcm_hw_constraint_integer(runtime,
+			 SNDRV_PCM_HW_PARAM_PERIODS);
+out_ops:
+	kfree(stream);
+	mutex_unlock(&sst_dsp_lock);
+	return ret_val;
+}
+
+static void sst_free_stream_in_use(struct sst_dev_stream_map *map, int str_id)
+{
+	if (dpcm_enable == 1)
+		return;
+
+	if ((map[str_id].dev_num == MERR_SALTBAY_AUDIO) ||
+			(map[str_id].dev_num == MERR_SALTBAY_PROBE)) {
+		/* Do nothing in capture for audio device */
+		if ((map[str_id].dev_num == MERR_SALTBAY_AUDIO) &&
+				(map[str_id].direction == SNDRV_PCM_STREAM_CAPTURE))
+			return;
+		if ((map[str_id].task_id == SST_TASK_ID_MEDIA) &&
+				(map[str_id].status == SST_DEV_MAP_IN_USE)) {
+			pr_debug("str_id %d device_id 0x%x\n", str_id, map[str_id].device_id);
+			map[str_id].status = SST_DEV_MAP_FREE;
+			map[str_id].device_id = PIPE_RSVD;
+		}
+	}
+	return;
+}
+
+static void sst_media_close(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	struct sst_runtime_stream *stream;
+	int ret_val = 0, str_id;
+	struct sst_data *ctx = snd_soc_platform_get_drvdata(dai->platform);
+
+	stream = substream->runtime->private_data;
+	if (strstr(dai->name, "Power-cpu-dai"))
+		ret_val = power_down_sst(stream);
+
+	str_id = stream->stream_info.str_id;
+	if (str_id)
+		ret_val = stream->ops->close(str_id);
+	sst_free_stream_in_use(ctx->pdata->pdev_strm_map, str_id);
+	module_put(sst_dsp->dev->driver->owner);
+	kfree(stream);
+	pr_debug("%s: %d\n", __func__, ret_val);
+}
+
+static int sst_dpcm_probe_cmd(struct snd_soc_platform *platform,
+		struct snd_pcm_substream *substream, u16 pipe_id, bool on)
+{
+	int ret = 0;
+	if ((dpcm_enable == 1) && (substream->pcm->device == MERR_DPCM_PROBE))
+			ret = sst_dpcm_probe_send(platform, pipe_id, substream->number,
+					substream->stream, on);
+	return ret;
+}
+
+static inline unsigned int get_current_pipe_id(struct snd_soc_platform *platform,
+					       struct snd_pcm_substream *substream)
+{
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	struct sst_dev_stream_map *map = sst->pdata->pdev_strm_map;
+	struct sst_runtime_stream *stream =
+			substream->runtime->private_data;
+	u32 str_id = stream->stream_info.str_id;
+	unsigned int pipe_id;
+	pipe_id = map[str_id].device_id;
+
+	pr_debug("%s: got pipe_id = %#x for str_id = %d\n",
+		 __func__, pipe_id, str_id);
+	return pipe_id;
+}
+
+static void sst_probe_close(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	u16 probe_pipe_id = get_current_pipe_id(dai->platform, substream);
+
+	sst_dpcm_probe_cmd(dai->platform, substream, probe_pipe_id, false);
+	sst_media_close(substream, dai);
+}
+
+static int sst_media_prepare(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	struct sst_runtime_stream *stream;
+	int ret_val = 0, str_id;
+
+	pr_debug("%s\n", __func__);
+
+	stream = substream->runtime->private_data;
+	str_id = stream->stream_info.str_id;
+	if (stream->stream_info.str_id)
+		return ret_val;
+
+	ret_val = sst_platform_alloc_stream(substream, dai->platform);
+	if (ret_val <= 0)
+		return ret_val;
+	snprintf(substream->pcm->id, sizeof(substream->pcm->id),
+			"%d", stream->stream_info.str_id);
+
+	ret_val = sst_platform_init_stream(substream);
+	if (ret_val)
+		return ret_val;
+	substream->runtime->hw.info = SNDRV_PCM_INFO_BLOCK_TRANSFER;
+
+	return ret_val;
+}
+
+static int sst_probe_prepare(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	u16 probe_pipe_id;
+
+	sst_media_prepare(substream, dai);
+	probe_pipe_id = get_current_pipe_id(dai->platform, substream);
+
+	return sst_dpcm_probe_cmd(dai->platform, substream, probe_pipe_id, true);
+}
+
+static int sst_media_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params,
+				struct snd_soc_dai *dai)
+{
+	pr_debug("%s\n", __func__);
+
+	snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
+	memset(substream->runtime->dma_area, 0, params_buffer_bytes(params));
+	return 0;
+}
+
+static int sst_media_hw_free(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	return snd_pcm_lib_free_pages(substream);
+}
+
+static int sst_enable_ssp(struct snd_pcm_substream *substream,
+			struct snd_soc_dai *dai)
+{
+	pr_debug("In %s :dai=%s pb=%d cp= %d dai_active=%d id=%d\n", __func__,
+		dai->name, dai->playback_active, dai->capture_active, dai->active,  dai->id);
+	if (!dai->active) {
+		sst_handle_vb_timer(dai->platform, true);
+		send_ssp_cmd(dai->platform, dai->name, 1);
+	}
+	return 0;
+}
+
+static void sst_disable_ssp(struct snd_pcm_substream *substream,
+			struct snd_soc_dai *dai)
+{
+	pr_debug("In %s :dai=%s pb=%d cp= %d dai_active=%d id=%d\n", __func__,
+		dai->name, dai->playback_active, dai->capture_active, dai->active, dai->id);
+	if (!dai->active) {
+		send_ssp_cmd(dai->platform, dai->name, 0);
+		sst_handle_vb_timer(dai->platform, false);
+	}
+}
+
+static struct snd_soc_dai_ops sst_media_dai_ops = {
+	.startup = sst_media_open,
+	.shutdown = sst_media_close,
+	.prepare = sst_media_prepare,
+	.hw_params = sst_media_hw_params,
+	.hw_free = sst_media_hw_free,
+	.set_tdm_slot = sst_platform_ihf_set_tdm_slot,
+	.mute_stream = sst_media_digital_mute,
+};
+
+static struct snd_soc_dai_ops sst_probe_dai_ops = {
+	.startup = sst_media_open,
+	.hw_params = sst_media_hw_params,
+	.hw_free = sst_media_hw_free,
+	.shutdown = sst_probe_close,
+	.prepare = sst_probe_prepare,
+};
+
+static struct snd_soc_dai_ops sst_loopback_dai_ops = {
+	.startup = sst_media_open,
+	.shutdown = sst_media_close,
+	.prepare = sst_media_prepare,
+};
+
+static struct snd_soc_dai_ops sst_compr_dai_ops = {
+	.mute_stream = sst_media_digital_mute,
+};
+
+static struct snd_soc_dai_ops sst_be_dai_ops = {
+	.startup = sst_enable_ssp,
+	.shutdown = sst_disable_ssp,
+};
+
+static struct snd_soc_dai_driver sst_platform_dai[] = {
+{
+	.name = SST_HEADSET_DAI,
+	.ops = &sst_media_dai_ops,
+	.playback = {
+		.stream_name = "Headset Playback",
+		.channels_min = SST_STEREO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_44100|SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.capture = {
+		.stream_name = "Headset Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_44100|SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+},
+{
+	.name = SST_DEEPBUFFER_DAI,
+	.ops = &sst_media_dai_ops,
+	.playback = {
+		.stream_name = "Deepbuffer Playback",
+		.channels_min = SST_STEREO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+},
+{
+	.name = SST_LOWLATENCY_DAI,
+	.ops = &sst_media_dai_ops,
+	.playback = {
+		.stream_name = "Low Latency Playback",
+		.channels_min = SST_STEREO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+},
+{
+	.name = SST_SPEAKER_DAI,
+	.ops = &sst_media_dai_ops,
+	.playback = {
+		.stream_name = "Speaker Playback",
+		.channels_min = SST_MONO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_44100|SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+},
+{
+	.name = SST_VOICE_DAI,
+	.playback = {
+		.stream_name = "Voice Downlink",
+		.channels_min = SST_MONO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_8000|SNDRV_PCM_RATE_16000|SNDRV_PCM_RATE_44100|SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.capture = {
+		.stream_name = "Voice Uplink",
+		.channels_min = SST_MONO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_8000|SNDRV_PCM_RATE_16000|SNDRV_PCM_RATE_44100|SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+},
+{
+	.name = SST_COMPRESS_DAI,
+	.compress_dai = 1,
+	.ops = &sst_compr_dai_ops,
+	.playback = {
+		.stream_name = "Compress Playback",
+		.channels_min = SST_STEREO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+},
+{
+	.name = SST_VIRTUAL_DAI,
+	.playback = {
+		.stream_name = "Virtual Playback",
+		.channels_min = SST_STEREO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+},
+{
+	.name = SST_POWER_DAI,
+	.ops = &sst_media_dai_ops,
+	.playback = {
+		.stream_name = "Dummy Power Stream",
+		.channels_min = SST_MONO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_8000_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,
+	},
+},
+{
+	.name = SST_PROBE_DAI,
+	.ops = &sst_probe_dai_ops,
+	.playback = {
+		.stream_name = "Probe Playback",
+		.channels_min = SST_MONO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_8000 |
+				SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |
+			   SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.capture = {
+		.stream_name = "Probe Capture",
+		.channels_min = SST_MONO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_8000 |
+				SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |
+			   SNDRV_PCM_FMTBIT_S32_LE,
+	},
+},
+{
+	.name = SST_VOIP_DAI,
+	.ops = &sst_media_dai_ops,
+	.playback = {
+		.stream_name = "VOIP Playback",
+		.channels_min = SST_MONO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.capture = {
+		.stream_name = "VOIP Capture",
+		.channels_min = SST_MONO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+},
+{
+	.name = SST_LOOPBACK_DAI,
+	.ops = &sst_loopback_dai_ops,
+	.capture = {
+		.stream_name = "Loopback Capture",
+		.channels_min = SST_MONO,
+		.channels_max = SST_MONO,
+		.rates = SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+},
+/*BE CPU  Dais */
+{
+	.name = "ssp0-port",
+	.ops = &sst_be_dai_ops,
+	.playback = {
+		.stream_name = "ssp0 Tx",
+		.channels_min = SST_STEREO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.capture = {
+		.stream_name = "ssp0 Rx",
+		.channels_min = SST_STEREO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+},
+{
+	.name = "ssp1-port",
+	.ops = &sst_be_dai_ops,
+	.playback = {
+		.stream_name = "ssp1 Tx",
+		.channels_min = SST_STEREO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_8000|SNDRV_PCM_RATE_16000|SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.capture = {
+		.stream_name = "ssp1 Rx",
+		.channels_min = SST_STEREO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_8000|SNDRV_PCM_RATE_16000|SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+},
+{
+	.name = "ssp2-port",
+	.ops = &sst_be_dai_ops,
+	.playback = {
+		.stream_name = "ssp2 Tx",
+		.channels_min = SST_STEREO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.capture = {
+		.stream_name = "ssp2 Rx",
+		.channels_min = SST_STEREO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+},
+};
+
+static int sst_platform_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai_link *dai_link = rtd->dai_link;
+
+	pr_debug("sst_platform_open called:%s\n", dai_link->cpu_dai_name);
+	if (substream->pcm->internal)
+		return 0;
+	runtime = substream->runtime;
+	runtime->hw = sst_platform_pcm_hw;
+	return 0;
+}
+
+static int sst_platform_close(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai_link *dai_link = rtd->dai_link;
+	pr_debug("sst_platform_close called:%s\n", dai_link->cpu_dai_name);
+	return 0;
+}
+
+static int sst_platform_pcm_trigger(struct snd_pcm_substream *substream,
+					int cmd)
+{
+	int ret_val = 0, str_id;
+	struct sst_runtime_stream *stream;
+	int str_cmd, status, alsa_state;
+
+	if (substream->pcm->internal)
+		return 0;
+	pr_debug("sst_platform_pcm_trigger called\n");
+	stream = substream->runtime->private_data;
+	str_id = stream->stream_info.str_id;
+	alsa_state = substream->runtime->status->state;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		pr_debug("Trigger Start\n");
+		str_cmd = SST_SND_START;
+		status = SST_PLATFORM_RUNNING;
+		stream->stream_info.mad_substream = substream;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		pr_debug("Trigger stop\n");
+		str_cmd = SST_SND_DROP;
+		status = SST_PLATFORM_DROPPED;
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		pr_debug("Trigger pause\n");
+		str_cmd = SST_SND_PAUSE;
+		status = SST_PLATFORM_PAUSED;
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		pr_debug("Trigger pause release\n");
+		str_cmd = SST_SND_RESUME;
+		status = SST_PLATFORM_RUNNING;
+		break;
+	default:
+		return -EINVAL;
+	}
+	ret_val = stream->ops->device_control(str_cmd, &str_id);
+	if (!ret_val)
+		sst_set_stream_status(stream, status);
+
+	return ret_val;
+}
+
+
+static snd_pcm_uframes_t sst_platform_pcm_pointer
+			(struct snd_pcm_substream *substream)
+{
+	struct sst_runtime_stream *stream;
+	int ret_val, status;
+	struct pcm_stream_info *str_info;
+
+	stream = substream->runtime->private_data;
+	status = sst_get_stream_status(stream);
+	if (status == SST_PLATFORM_INIT)
+		return 0;
+	str_info = &stream->stream_info;
+	ret_val = stream->ops->device_control(
+				SST_SND_BUFFER_POINTER, str_info);
+	if (ret_val) {
+		pr_err("sst: error code = %d\n", ret_val);
+		return ret_val;
+	}
+	substream->runtime->soc_delay = str_info->pcm_delay;
+	return str_info->buffer_ptr;
+}
+
+static struct snd_pcm_ops sst_platform_ops = {
+	.open = sst_platform_open,
+	.close = sst_platform_close,
+	.ioctl = snd_pcm_lib_ioctl,
+	.trigger = sst_platform_pcm_trigger,
+	.pointer = sst_platform_pcm_pointer,
+};
+
+static void sst_pcm_free(struct snd_pcm *pcm)
+{
+	pr_debug("sst_pcm_free called\n");
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+}
+
+static int sst_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_dai *dai = rtd->cpu_dai;
+	struct snd_pcm *pcm = rtd->pcm;
+	int retval = 0;
+
+	pr_debug("sst_pcm_new called\n");
+	if (dai->driver->playback.channels_min ||
+			dai->driver->capture.channels_min) {
+		retval =  snd_pcm_lib_preallocate_pages_for_all(pcm,
+			SNDRV_DMA_TYPE_CONTINUOUS,
+			snd_dma_continuous_data(GFP_DMA),
+			SST_MAX_BUFFER, SST_MAX_BUFFER);
+		if (retval) {
+			pr_err("dma buffer allocationf fail\n");
+			return retval;
+		}
+	}
+	return retval;
+}
+
+static int sst_soc_probe(struct snd_soc_platform *platform)
+{
+	int ret = 0;
+
+	pr_debug("Enter:%s\n", __func__);
+
+#ifdef CONFIG_SST_DPCM
+	if (dpcm_enable == 1)
+			ret = sst_dsp_init_v2_dpcm(platform);
+#endif
+	if (ret)
+		pr_err("Dsp init failed: %d\n", ret);
+	return ret;
+}
+
+static int sst_soc_remove(struct snd_soc_platform *platform)
+{
+	pr_debug("%s called\n", __func__);
+	return 0;
+}
+
+static struct snd_soc_platform_driver sst_soc_platform_drv  = {
+	.probe		= sst_soc_probe,
+	.remove		= sst_soc_remove,
+	.ops		= &sst_platform_ops,
+	.compr_ops	= &sst_platform_compr_ops,
+	.pcm_new	= sst_pcm_new,
+	.pcm_free	= sst_pcm_free,
+	.read		= sst_soc_read,
+	.write		= sst_soc_write,
+};
+
+int sst_register_dsp(struct sst_device *sst_dev)
+{
+	if (!sst_dev)
+		return -ENODEV;
+	mutex_lock(&sst_dsp_lock);
+	if (sst_dsp) {
+		pr_err("we already have a device %s\n", sst_dsp->name);
+		mutex_unlock(&sst_dsp_lock);
+		return -EEXIST;
+	}
+	pr_debug("registering device %s\n", sst_dev->name);
+
+	sst_dsp = sst_dev;
+	mutex_unlock(&sst_dsp_lock);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sst_register_dsp);
+
+int sst_unregister_dsp(struct sst_device *dev)
+{
+	if (dev != sst_dsp)
+		return -EINVAL;
+
+	mutex_lock(&sst_dsp_lock);
+	if (sst_dsp) {
+		pr_debug("unregister %s\n", sst_dsp->name);
+		mutex_unlock(&sst_dsp_lock);
+		return -EIO;
+	}
+
+	sst_dsp = NULL;
+	mutex_unlock(&sst_dsp_lock);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sst_unregister_dsp);
+
+static const struct snd_soc_component_driver pcm_component = {
+	.name           = "pcm",
+};
+
+static int sst_platform_probe(struct platform_device *pdev)
+{
+	struct sst_data *sst;
+	int ret;
+	struct sst_platform_data *pdata = pdev->dev.platform_data;
+
+	pr_debug("sst_platform_probe called\n");
+	sst = devm_kzalloc(&pdev->dev, sizeof(*sst), GFP_KERNEL);
+	if (sst == NULL) {
+		pr_err("kzalloc failed\n");
+		return -ENOMEM;
+	}
+
+	if (dpcm_enable == 1) {
+		pr_info("dpcm enabled; overriding stream map\n");
+		pdata->pdev_strm_map = dpcm_strm_map;
+		pdata->strm_map_size = ARRAY_SIZE(dpcm_strm_map);
+	}
+	sst_pdev = &pdev->dev;
+	sst->pdata = pdata;
+	mutex_init(&sst->lock);
+	dev_set_drvdata(&pdev->dev, sst);
+
+	ret = snd_soc_register_platform(&pdev->dev,
+					 &sst_soc_platform_drv);
+	if (ret) {
+		pr_err("registering soc platform failed\n");
+		return ret;
+	}
+	ret = snd_soc_register_component(&pdev->dev, &pcm_component,
+				sst_platform_dai, ARRAY_SIZE(sst_platform_dai));
+	if (ret) {
+		pr_err("registering cpu dais failed\n");
+		snd_soc_unregister_platform(&pdev->dev);
+	}
+
+	return ret;
+}
+
+static int sst_platform_remove(struct platform_device *pdev)
+{
+
+	snd_soc_unregister_component(&pdev->dev);
+	snd_soc_unregister_platform(&pdev->dev);
+	pr_debug("sst_platform_remove success\n");
+	return 0;
+}
+
+static struct platform_driver sst_platform_driver = {
+	.driver		= {
+		.name		= "sst-platform",
+		.owner		= THIS_MODULE,
+	},
+	.probe		= sst_platform_probe,
+	.remove		= sst_platform_remove,
+};
+
+module_platform_driver(sst_platform_driver);
+
+MODULE_DESCRIPTION("ASoC Intel(R) MID Platform driver");
+MODULE_AUTHOR("Vinod Koul <vinod.koul@intel.com>");
+MODULE_AUTHOR("Harsha Priya <priya.harsha@intel.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:sst-platform");
diff --git a/sound/soc/intel/platform-libs/controls_v2.c b/sound/soc/intel/platform-libs/controls_v2.c
new file mode 100644
index 0000000..0528384
--- /dev/null
+++ b/sound/soc/intel/platform-libs/controls_v2.c
@@ -0,0 +1,1763 @@
+
+/*
+ *  controls_v2.c - Intel MID Platform driver ALSA controls for Mrfld
+ *
+ *  Copyright (C) 2012 Intel Corp
+ *  Author: Vinod Koul <vinod.koul@ilinux.intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *
+ */
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <sound/soc.h>
+#include <sound/asound.h>
+#include <asm/platform_sst_audio.h>
+#include "../platform_ipc_v2.h"
+#include "../sst_platform.h"
+#include "../sst_platform_pvt.h"
+#include "ipc_lib.h"
+#include "controls_v2.h"
+
+
+#define SST_ALGO_KCONTROL_INT(xname, xreg, xshift, xmax, xinvert,\
+	xhandler_get, xhandler_put, xmod, xpipe, xinstance, default_val) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = sst_algo_int_ctl_info, \
+	.get = xhandler_get, .put = xhandler_put, \
+	.private_value = (unsigned long)&(struct sst_algo_int_control_v2) \
+		{.mc.reg = xreg, .mc.rreg = xreg, .mc.shift = xshift, \
+		.mc.rshift = xshift, .mc.max = xmax, .mc.platform_max = xmax, \
+		.mc.invert = xinvert, .module_id = xmod, .pipe_id = xpipe, \
+		.instance_id = xinstance, .value = default_val } }
+/* Thresholds for Low Latency & Deep Buffer*/
+#define DEFAULT_LOW_LATENCY 10 /* In Ms */
+#define DEFAULT_DEEP_BUFFER 96
+
+unsigned long ll_threshold = DEFAULT_LOW_LATENCY;
+unsigned long db_threshold = DEFAULT_DEEP_BUFFER;
+
+int sst_algo_int_ctl_info(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	struct sst_algo_int_control_v2 *amc = (void *)kcontrol->private_value;
+	struct soc_mixer_control *mc = &amc->mc;
+	int platform_max;
+
+	if (!mc->platform_max)
+		mc->platform_max = mc->max;
+	platform_max = mc->platform_max;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = platform_max;
+	return 0;
+}
+
+unsigned int sst_soc_read(struct snd_soc_platform *platform,
+			unsigned int reg)
+{
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+
+	pr_debug("%s: reg[%d] = %#x\n", __func__, reg, sst->widget[reg]);
+	BUG_ON(reg > (SST_NUM_WIDGETS - 1));
+	return sst->widget[reg];
+}
+
+int sst_soc_write(struct snd_soc_platform *platform,
+		  unsigned int reg, unsigned int val)
+{
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+
+	pr_debug("%s: reg[%d] = %#x\n", __func__, reg, val);
+	BUG_ON(reg > (SST_NUM_WIDGETS - 1));
+	sst->widget[reg] = val;
+	return 0;
+}
+
+unsigned int sst_reg_read(struct sst_data *sst, unsigned int reg,
+			  unsigned int shift, unsigned int max)
+{
+	unsigned int mask = (1 << fls(max)) - 1;
+
+	return (sst->widget[reg] >> shift) & mask;
+}
+
+unsigned int sst_reg_write(struct sst_data *sst, unsigned int reg,
+			   unsigned int shift, unsigned int max, unsigned int val)
+{
+	unsigned int mask = (1 << fls(max)) - 1;
+
+	val &= mask;
+	val <<= shift;
+	sst->widget[reg] &= ~(mask << shift);
+	sst->widget[reg] |= val;
+	return val;
+}
+
+int sst_mix_put(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_widget_list *wlist = dapm_kcontrol_get_wlist(kcontrol);
+	struct snd_soc_dapm_widget *widget = wlist->widgets[0];
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	struct sst_data *sst = snd_soc_platform_get_drvdata(widget->platform);
+	unsigned int mask = (1 << fls(mc->max)) - 1;
+	unsigned int val;
+	int connect;
+	struct snd_soc_dapm_update update;
+
+	pr_debug("%s called set %#lx for %s\n", __func__,
+			ucontrol->value.integer.value[0], widget->name);
+	val = sst_reg_write(sst, mc->reg, mc->shift, mc->max, ucontrol->value.integer.value[0]);
+	connect = !!val;
+
+	dapm_kcontrol_set_value(kcontrol, val);
+	update.kcontrol = kcontrol;
+	update.reg = mc->reg;
+	update.mask = mask;
+	update.val = val;
+
+	snd_soc_dapm_mixer_update_power(widget->dapm, kcontrol, connect, &update);
+	return 0;
+}
+
+int sst_mix_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_widget_list *wlist = dapm_kcontrol_get_wlist(kcontrol);
+	struct snd_soc_dapm_widget *w = wlist->widgets[0];
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	struct sst_data *sst = snd_soc_platform_get_drvdata(w->platform);
+
+	ucontrol->value.integer.value[0] = !!sst_reg_read(sst, mc->reg, mc->shift, mc->max);
+	return 0;
+}
+
+static const struct snd_kcontrol_new sst_mix_modem_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_MODEM, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_MODEM, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_MODEM, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_MODEM, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_MODEM, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_MODEM, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_MODEM, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_MODEM, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_MODEM, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_MODEM, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_MODEM, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_MODEM, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_MODEM, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_MODEM, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_MODEM, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_MODEM, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_MODEM, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_MODEM, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_MODEM, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_codec0_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_CODEC0, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_CODEC0, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_CODEC0, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_CODEC0, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_CODEC0, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_CODEC0, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_CODEC0, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_CODEC0, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_CODEC0, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_CODEC0, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_CODEC0, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_CODEC0, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_CODEC0, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_CODEC0, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_CODEC0, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_CODEC0, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_CODEC0, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_CODEC0, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_CODEC0, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_codec1_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_CODEC1, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_CODEC1, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_CODEC1, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_CODEC1, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_CODEC1, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_CODEC1, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_CODEC1, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_CODEC1, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_CODEC1, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_CODEC1, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_CODEC1, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_CODEC1, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_CODEC1, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_CODEC1, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_CODEC1, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_CODEC1, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_CODEC1, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_CODEC1, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_CODEC1, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_sprot_l0_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_LOOP0, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_LOOP0, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_LOOP0, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_LOOP0, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_LOOP0, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_LOOP0, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_LOOP0, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_LOOP0, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_LOOP0, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_LOOP0, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_LOOP0, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_LOOP0, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_LOOP0, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_LOOP0, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_LOOP0, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_LOOP0, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_LOOP0, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_LOOP0, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_LOOP0, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_media_l1_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_LOOP1, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_LOOP1, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_LOOP1, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_LOOP1, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_LOOP1, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_LOOP1, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_LOOP1, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_LOOP1, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_LOOP1, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_LOOP1, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_LOOP1, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_LOOP1, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_LOOP1, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_LOOP1, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_LOOP1, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_LOOP1, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_LOOP1, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_LOOP1, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_LOOP1, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_media_l2_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_LOOP2, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_LOOP2, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_LOOP2, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_LOOP2, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_LOOP2, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_LOOP2, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_LOOP2, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_LOOP2, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_LOOP2, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_LOOP2, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_LOOP2, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_LOOP2, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_LOOP2, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_LOOP2, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_LOOP2, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_LOOP2, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_LOOP2, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_LOOP2, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_LOOP2, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_speech_tx_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_SPEECH, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_SPEECH, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_SPEECH, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_SPEECH, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_SPEECH, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_SPEECH, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_SPEECH, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_SPEECH, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_SPEECH, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_SPEECH, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_SPEECH, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_SPEECH, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_SPEECH, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_SPEECH, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_SPEECH, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_SPEECH, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_SPEECH, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_SPEECH, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_SPEECH, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_speech_rx_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_RXSPEECH, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_RXSPEECH, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_RXSPEECH, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_RXSPEECH, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_RXSPEECH, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_RXSPEECH, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_RXSPEECH, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_RXSPEECH, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_RXSPEECH, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_RXSPEECH, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_RXSPEECH, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_RXSPEECH, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_RXSPEECH, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_RXSPEECH, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_RXSPEECH, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_RXSPEECH, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_RXSPEECH, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_RXSPEECH, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_RXSPEECH, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_voip_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_VOIP, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_VOIP, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_VOIP, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_VOIP, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_VOIP, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_VOIP, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_VOIP, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_VOIP, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_VOIP, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_VOIP, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_VOIP, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_VOIP, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_VOIP, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_VOIP, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_VOIP, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_VOIP, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_VOIP, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_VOIP, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_VOIP, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_pcm0_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_PCM0, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_PCM0, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_PCM0, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_PCM0, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_PCM0, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_PCM0, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_PCM0, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_PCM0, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_PCM0, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_PCM0, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_PCM0, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_PCM0, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_PCM0, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_PCM0, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_PCM0, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_PCM0, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_PCM0, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_PCM0, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_PCM0, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_pcm1_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_PCM1, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_PCM1, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_PCM1, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_PCM1, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_PCM1, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_PCM1, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_PCM1, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_PCM1, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_PCM1, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_PCM1, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_PCM1, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_PCM1, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_PCM1, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_PCM1, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_PCM1, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_PCM1, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_PCM1, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_PCM1, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_PCM1, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_pcm2_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_PCM2, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_PCM2, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_PCM2, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_PCM2, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_PCM2, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_PCM2, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_PCM2, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_PCM2, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_PCM2, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_PCM2, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_PCM2, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_PCM2, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_PCM2, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_PCM2, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_PCM2, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_PCM2, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_PCM2, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_PCM2, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_PCM2, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_aware_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_AWARE, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_AWARE, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_AWARE, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_AWARE, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_AWARE, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_AWARE, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_AWARE, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_AWARE, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_AWARE, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_AWARE, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_AWARE, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_AWARE, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_AWARE, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_AWARE, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_AWARE, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_AWARE, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_AWARE, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_AWARE, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_AWARE, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_vad_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_VAD, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_VAD, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_VAD, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_VAD, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_VAD, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_VAD, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_VAD, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_VAD, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_VAD, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_VAD, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_VAD, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_VAD, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_VAD, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_VAD, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_VAD, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_VAD, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_VAD, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_VAD, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_VAD, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_media0_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_MEDIA0, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_MEDIA0, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_MEDIA0, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_MEDIA0, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_MEDIA0, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_MEDIA0, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_MEDIA0, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_MEDIA0, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_MEDIA0, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_MEDIA0, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_MEDIA0, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_MEDIA0, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_MEDIA0, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_MEDIA0, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_MEDIA0, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_MEDIA0, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_MEDIA0, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_MEDIA0, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_MEDIA0, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_media1_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_MEDIA1, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_MEDIA1, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_MEDIA1, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_MEDIA1, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_MEDIA1, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_MEDIA1, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_MEDIA1, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_MEDIA1, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_MEDIA1, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_MEDIA1, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_MEDIA1, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_MEDIA1, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_MEDIA1, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_MEDIA1, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_MEDIA1, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_MEDIA1, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_MEDIA1, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_MEDIA1, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_MEDIA1, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_fm_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_FM, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_FM, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_FM, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_FM, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_FM, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_FM, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_FM, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_FM, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_FM, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_FM, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_FM, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_FM, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_FM, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_FM, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_FM, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_FM, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_FM, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_FM, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_FM, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_sw_modem =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 0, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_codec0 =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 1, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_codec1 =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 2, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_sprot_l0 =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 3, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_media_l1 =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 4, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_media_l2 =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 5, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_speech_tx =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 6, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_speech_rx =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 7, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_voip =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 8, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_pcm0 =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 9, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_pcm1 =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 10, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_pcm2 =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 11, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_aware =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 12, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_vad =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 13, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_media0 =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 14, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_media1 =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 15, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_fm =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 16, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_out_sw_modem =
+	SOC_SINGLE_EXT("Switch", SST_OUT_SWITCH, 0, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_out_sw_codec0 =
+	SOC_SINGLE_EXT("Switch", SST_OUT_SWITCH, 1, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_out_sw_codec1 =
+	SOC_SINGLE_EXT("Switch", SST_OUT_SWITCH, 2, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_out_sw_speech_tx =
+	SOC_SINGLE_EXT("Switch", SST_OUT_SWITCH, 6, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_out_sw_speech_rx =
+	SOC_SINGLE_EXT("Switch", SST_OUT_SWITCH, 7, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_out_sw_voip =
+	SOC_SINGLE_EXT("Switch", SST_OUT_SWITCH, 8, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_out_sw_pcm0 =
+	SOC_SINGLE_EXT("Switch", SST_OUT_SWITCH, 9, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_out_sw_pcm1 =
+	SOC_SINGLE_EXT("Switch", SST_OUT_SWITCH, 10, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_out_sw_pcm2 =
+	SOC_SINGLE_EXT("Switch", SST_OUT_SWITCH, 11, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_out_sw_aware =
+	SOC_SINGLE_EXT("Switch", SST_OUT_SWITCH, 12, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_out_sw_vad =
+	SOC_SINGLE_EXT("Switch", SST_OUT_SWITCH, 13, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_out_sw_media0 =
+	SOC_SINGLE_EXT("Switch", SST_OUT_SWITCH, 14, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_out_sw_media1 =
+	SOC_SINGLE_EXT("Switch", SST_OUT_SWITCH, 15, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_out_sw_fm =
+	SOC_SINGLE_EXT("Switch", SST_OUT_SWITCH, 16, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_in_sw_modem =
+	SOC_SINGLE_EXT("Switch", SST_IN_SWITCH, 0, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_in_sw_codec0 =
+	SOC_SINGLE_EXT("Switch", SST_IN_SWITCH, 1, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_in_sw_codec1 =
+	SOC_SINGLE_EXT("Switch", SST_IN_SWITCH, 2, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_in_sw_sidetone =
+	SOC_SINGLE_EXT("Switch", SST_IN_SWITCH, 3, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_in_sw_speech_tx =
+	SOC_SINGLE_EXT("Switch", SST_IN_SWITCH, 4, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_in_sw_speech_rx  =
+	SOC_SINGLE_EXT("Switch", SST_IN_SWITCH, 5, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_in_sw_tone =
+	SOC_SINGLE_EXT("Switch", SST_IN_SWITCH, 6, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_in_sw_voip =
+	SOC_SINGLE_EXT("Switch", SST_IN_SWITCH, 7, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_in_sw_pcm0 =
+	SOC_SINGLE_EXT("Switch", SST_IN_SWITCH, 8, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_in_sw_pcm1 =
+	SOC_SINGLE_EXT("Switch", SST_IN_SWITCH, 9, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_in_sw_media0 =
+	SOC_SINGLE_EXT("Switch", SST_IN_SWITCH, 10, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_in_sw_media1 =
+	SOC_SINGLE_EXT("Switch", SST_IN_SWITCH, 11, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_in_sw_media2 =
+	SOC_SINGLE_EXT("Switch", SST_IN_SWITCH, 12, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_in_sw_fm =
+	SOC_SINGLE_EXT("Switch", SST_IN_SWITCH, 13, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_soc_dapm_widget sst_dapm_widgets[] = {
+	SND_SOC_DAPM_INPUT("Modem IN"),
+	SND_SOC_DAPM_INPUT("Codec IN0"),
+	SND_SOC_DAPM_INPUT("Codec IN1"),
+	SND_SOC_DAPM_INPUT("Tone IN"),
+	SND_SOC_DAPM_INPUT("FM IN"),
+	SND_SOC_DAPM_OUTPUT("Modem OUT"),
+	SND_SOC_DAPM_OUTPUT("Codec OUT0"),
+	SND_SOC_DAPM_OUTPUT("Codec OUT1"),
+	SND_SOC_DAPM_OUTPUT("FM OUT"),
+	SND_SOC_DAPM_AIF_IN("Voip IN", "VoIP", 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_IN("Media IN0", "Compress", 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_IN("Media IN1", "PCM", 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_OUT("Voip OUT", "VoIP", 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_OUT("PCM1 OUT", "Capture", 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_OUT("Aware OUT", "Aware", 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_OUT("VAD OUT", "VAD", 0, SND_SOC_NOPM, 0, 0),
+
+	/* output mixers */
+	SND_SOC_DAPM_MIXER("MIX Modem", SND_SOC_NOPM, 0, 0,
+		sst_mix_modem_controls, ARRAY_SIZE(sst_mix_modem_controls)),
+	SND_SOC_DAPM_MIXER("MIX Codec0", SND_SOC_NOPM, 0, 0,
+		sst_mix_codec0_controls , ARRAY_SIZE(sst_mix_codec0_controls)),
+	SND_SOC_DAPM_MIXER("MIX Codec1", SND_SOC_NOPM, 0, 0,
+		sst_mix_codec1_controls, ARRAY_SIZE(sst_mix_codec1_controls)),
+	SND_SOC_DAPM_MIXER("MIX Sprot L0", SND_SOC_NOPM, 0, 0,
+		sst_mix_sprot_l0_controls, ARRAY_SIZE(sst_mix_sprot_l0_controls)),
+	SND_SOC_DAPM_MIXER("MIX Media L1", SND_SOC_NOPM, 0, 0,
+		sst_mix_media_l1_controls, ARRAY_SIZE(sst_mix_media_l1_controls)),
+	SND_SOC_DAPM_MIXER("MIX Media L2", SND_SOC_NOPM, 0, 0,
+		sst_mix_media_l2_controls, ARRAY_SIZE(sst_mix_media_l2_controls)),
+	SND_SOC_DAPM_MIXER("MIX Speech Tx", SND_SOC_NOPM, 0, 0,
+		sst_mix_speech_tx_controls, ARRAY_SIZE(sst_mix_speech_tx_controls)),
+	SND_SOC_DAPM_MIXER("MIX Speech Rx", SND_SOC_NOPM, 0, 0,
+		sst_mix_speech_rx_controls, ARRAY_SIZE(sst_mix_speech_rx_controls)),
+	SND_SOC_DAPM_MIXER("MIX Voip", SND_SOC_NOPM, 0, 0,
+		sst_mix_voip_controls, ARRAY_SIZE(sst_mix_voip_controls)),
+	SND_SOC_DAPM_MIXER("MIX PCM0", SND_SOC_NOPM, 0, 0,
+		sst_mix_pcm0_controls, ARRAY_SIZE(sst_mix_pcm0_controls)),
+	SND_SOC_DAPM_MIXER("MIX PCM1", SND_SOC_NOPM, 0, 0,
+		sst_mix_pcm1_controls, ARRAY_SIZE(sst_mix_pcm1_controls)),
+	SND_SOC_DAPM_MIXER("MIX PCM2", SND_SOC_NOPM, 0, 0,
+		sst_mix_pcm2_controls, ARRAY_SIZE(sst_mix_pcm2_controls)),
+	SND_SOC_DAPM_MIXER("MIX Aware", SND_SOC_NOPM, 0, 0,
+		sst_mix_aware_controls, ARRAY_SIZE(sst_mix_aware_controls)),
+	SND_SOC_DAPM_MIXER("MIX VAD", SND_SOC_NOPM, 0, 0,
+		sst_mix_vad_controls, ARRAY_SIZE(sst_mix_vad_controls)),
+	SND_SOC_DAPM_MIXER("MIX Media0", SND_SOC_NOPM, 0, 0,
+		sst_mix_media0_controls, ARRAY_SIZE(sst_mix_media0_controls)),
+	SND_SOC_DAPM_MIXER("MIX Media1", SND_SOC_NOPM, 0, 0,
+		sst_mix_media1_controls, ARRAY_SIZE(sst_mix_media1_controls)),
+	SND_SOC_DAPM_MIXER("MIX FM", SND_SOC_NOPM, 0, 0,
+		sst_mix_fm_controls, ARRAY_SIZE(sst_mix_fm_controls)),
+
+	/* switches for mixer outputs */
+	SND_SOC_DAPM_SWITCH("Mix Modem Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_modem),
+	SND_SOC_DAPM_SWITCH("Mix Codec0 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_codec0),
+	SND_SOC_DAPM_SWITCH("Mix Codec1 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_codec1),
+	SND_SOC_DAPM_SWITCH("Mix Sprot L0 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_sprot_l0),
+	SND_SOC_DAPM_SWITCH("Mix Media L1 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_media_l1),
+	SND_SOC_DAPM_SWITCH("Mix Media L2 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_media_l2),
+	SND_SOC_DAPM_SWITCH("Mix Speech Tx Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_speech_tx),
+	SND_SOC_DAPM_SWITCH("Mix Speech Rx Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_speech_rx),
+	SND_SOC_DAPM_SWITCH("Mix Voip Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_voip),
+	SND_SOC_DAPM_SWITCH("Mix PCM0 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_pcm0),
+	SND_SOC_DAPM_SWITCH("Mix PCM1 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_pcm1),
+	SND_SOC_DAPM_SWITCH("Mix PCM2 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_pcm2),
+	SND_SOC_DAPM_SWITCH("Mix Aware Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_aware),
+	SND_SOC_DAPM_SWITCH("Mix VAD Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_vad),
+	SND_SOC_DAPM_SWITCH("Mix Media0 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_media0),
+	SND_SOC_DAPM_SWITCH("Mix Media1 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_media1),
+	SND_SOC_DAPM_SWITCH("Mix FM Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_fm),
+
+	/* output pipeline switches */
+	SND_SOC_DAPM_SWITCH("Out Modem Switch", SND_SOC_NOPM, 0, 0,
+			&sst_out_sw_modem),
+	SND_SOC_DAPM_SWITCH("Out Codec0 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_out_sw_codec0),
+	SND_SOC_DAPM_SWITCH("Out Codec1 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_out_sw_codec1),
+	SND_SOC_DAPM_SWITCH("Out Speech Tx Switch", SND_SOC_NOPM, 0, 0,
+			&sst_out_sw_speech_tx),
+	SND_SOC_DAPM_SWITCH("Out Speech Rx Switch", SND_SOC_NOPM, 0, 0,
+			&sst_out_sw_speech_rx),
+	SND_SOC_DAPM_SWITCH("Out Voip Switch", SND_SOC_NOPM, 0, 0,
+			&sst_out_sw_voip),
+	SND_SOC_DAPM_SWITCH("Out PCM0 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_out_sw_pcm0),
+	SND_SOC_DAPM_SWITCH("Out PCM1 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_out_sw_pcm1),
+	SND_SOC_DAPM_SWITCH("Out PCM2 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_out_sw_pcm2),
+	SND_SOC_DAPM_SWITCH("Out Aware Switch", SND_SOC_NOPM, 0, 0,
+			&sst_out_sw_aware),
+	SND_SOC_DAPM_SWITCH("Out VAD Switch", SND_SOC_NOPM, 0, 0,
+			&sst_out_sw_vad),
+	SND_SOC_DAPM_SWITCH("Out Media0 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_out_sw_media0),
+	SND_SOC_DAPM_SWITCH("Out Media1 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_out_sw_media1),
+	SND_SOC_DAPM_SWITCH("Out FM Switch", SND_SOC_NOPM, 0, 0,
+			&sst_out_sw_fm),
+
+	/* Input pipeline switches */
+	SND_SOC_DAPM_SWITCH("In Modem Switch", SND_SOC_NOPM, 0, 0,
+		       &sst_in_sw_modem),
+	SND_SOC_DAPM_SWITCH("In Codec0 Switch", SND_SOC_NOPM, 0, 0,
+		       &sst_in_sw_codec0),
+	SND_SOC_DAPM_SWITCH("In Codec1 Switch", SND_SOC_NOPM, 0, 0,
+		       &sst_in_sw_codec1),
+	SND_SOC_DAPM_SWITCH("In Speech Tx Switch", SND_SOC_NOPM, 0, 0,
+		       &sst_in_sw_speech_tx),
+	SND_SOC_DAPM_SWITCH("In Speech Rx Switch", SND_SOC_NOPM, 0, 0,
+		       &sst_in_sw_speech_rx),
+	SND_SOC_DAPM_SWITCH("In Tone Switch", SND_SOC_NOPM, 0, 0,
+		       &sst_in_sw_tone),
+	SND_SOC_DAPM_SWITCH("In Voip Switch", SND_SOC_NOPM, 0, 0,
+		       &sst_in_sw_voip),
+	SND_SOC_DAPM_SWITCH("In PCM0 Switch", SND_SOC_NOPM, 0, 0,
+		       &sst_in_sw_pcm0),
+	SND_SOC_DAPM_SWITCH("In PCM1 Switch", SND_SOC_NOPM, 0, 0,
+		       &sst_in_sw_pcm1),
+	SND_SOC_DAPM_SWITCH("In Media0 Switch", SND_SOC_NOPM, 0, 0,
+		       &sst_in_sw_media0),
+	SND_SOC_DAPM_SWITCH("In Media1 Switch", SND_SOC_NOPM, 0, 0,
+		       &sst_in_sw_media1),
+	SND_SOC_DAPM_SWITCH("In Media2 Switch", SND_SOC_NOPM, 0, 0,
+		       &sst_in_sw_media2),
+	SND_SOC_DAPM_SWITCH("In FM Switch", SND_SOC_NOPM, 0, 0,
+		       &sst_in_sw_fm),
+};
+
+static const struct snd_soc_dapm_route intercon[] = {
+	/* media mixer settings */
+	{ "In Media0 Switch", "Switch", "Media IN0"},
+	{ "In Media1 Switch", "Switch", "Media IN1"},
+	{ "MIX Media0", "Media0", "In Media0 Switch"},
+	{ "MIX Media0", "Media1", "In Media1 Switch"},
+	{ "MIX Media0", "Media2", "In Media2 Switch"},
+	{ "MIX Media1", "Media0", "In Media0 Switch"},
+	{ "MIX Media1", "Media1", "In Media1 Switch"},
+	{ "MIX Media1", "Media2", "In Media2 Switch"},
+
+	/* media to main mixer intercon */
+	/* two media paths from media to main */
+	{ "Mix Media0 Switch", "Switch", "MIX Media0"},
+	{ "Out Media0 Switch", "Switch", "Mix Media0 Switch"},
+	{ "In PCM0 Switch", "Switch", "Out Media0 Switch"},
+	{ "Mix Media1 Switch", "Switch", "MIX Media1"},
+	{ "Out Media1 Switch", "Switch", "Mix Media1 Switch"},
+	{ "In PCM1 Switch", "Switch", "Out Media1 Switch"},
+	/* one back from main to media */
+	{ "Mix PCM0 Switch", "Switch", "MIX PCM0"},
+	{ "Out PCM0 Switch", "Switch", "Mix PCM0 Switch"},
+	{ "In Media2 Switch", "Switch", "Out PCM0 Switch"},
+
+	/* main mixer inputs - all inputs connect to mixer */
+	{ "MIX Modem", "Modem", "In Modem Switch"},
+	{ "MIX Modem", "Codec0", "In Codec0 Switch"},
+	{ "MIX Modem", "Codec1", "In Codec1 Switch"},
+	{ "MIX Modem", "Speech_Tx", "In Speech Tx Switch"},
+	{ "MIX Modem", "Speech_Rx", "In Speech Rx Switch"},
+	{ "MIX Modem", "Tone", "In Tone Switch"},
+	{ "MIX Modem", "Voip", "In Voip Switch"},
+	{ "MIX Modem", "PCM0", "In PCM0 Switch"},
+	{ "MIX Modem", "PCM1", "In PCM1 Switch"},
+	{ "MIX Modem", "FM", "In FM Switch"},
+	/* loops have output switches coming back to mixers */
+	{ "MIX Modem", "Sprot_L0", "Mix Sprot L0 Switch"},
+	{ "MIX Modem", "Media_L1", "Mix Media L1 Switch"},
+	{ "MIX Modem", "Media_L2", "Mix Media L2 Switch"},
+	/* sidetone comes from speech out */
+	{ "MIX Modem", "Sidetone", "Mix Speech Tx Switch"},
+
+	{ "MIX Codec0", "Modem", "In Modem Switch"},
+	{ "MIX Codec0", "Codec0", "In Codec0 Switch"},
+	{ "MIX Codec0", "Codec1", "In Codec1 Switch"},
+	{ "MIX Codec0", "Speech_Tx", "In Speech Tx Switch"},
+	{ "MIX Codec0", "Speech_Rx", "In Speech Rx Switch"},
+	{ "MIX Codec0", "Tone", "In Tone Switch"},
+	{ "MIX Codec0", "Voip", "In Voip Switch"},
+	{ "MIX Codec0", "PCM0", "In PCM0 Switch"},
+	{ "MIX Codec0", "PCM1", "In PCM1 Switch"},
+	{ "MIX Codec0", "FM", "In FM Switch"},
+	/* loops have output switches coming back to mixers */
+	{ "MIX Codec0", "Sprot_L0", "Mix Sprot L0 Switch"},
+	{ "MIX Codec0", "Media_L1", "Mix Media L1 Switch"},
+	{ "MIX Codec0", "Media_L2", "Mix Media L2 Switch"},
+	/* sidetone comes from speech out */
+	{ "MIX Codec0", "Sidetone", "Mix Speech Tx Switch"},
+
+	{ "MIX Codec1", "Modem", "In Modem Switch"},
+	{ "MIX Codec1", "Codec0", "In Codec0 Switch"},
+	{ "MIX Codec1", "Codec1", "In Codec1 Switch"},
+	{ "MIX Codec1", "Speech_Tx", "In Speech Tx Switch"},
+	{ "MIX Codec1", "Speech_Rx", "In Speech Rx Switch"},
+	{ "MIX Codec1", "Tone", "In Tone Switch"},
+	{ "MIX Codec1", "Voip", "In Voip Switch"},
+	{ "MIX Codec1", "PCM0", "In PCM0 Switch"},
+	{ "MIX Codec1", "PCM1", "In PCM1 Switch"},
+	{ "MIX Codec1", "FM", "In FM Switch"},
+	/* loops have output switches coming back to mixers */
+	{ "MIX Codec1", "Sprot_L0", "Mix Sprot L0 Switch"},
+	{ "MIX Codec1", "Media_L1", "Mix Media L1 Switch"},
+	{ "MIX Codec1", "Media_L2", "Mix Media L2 Switch"},
+	/* sidetone comes from speech out */
+	{ "MIX Codec1", "Sidetone", "Mix Speech Tx Switch"},
+
+	{ "MIX Sprot L0", "Modem", "In Modem Switch"},
+	{ "MIX Sprot L0", "Codec0", "In Codec0 Switch"},
+	{ "MIX Sprot L0", "Codec1", "In Codec1 Switch"},
+	{ "MIX Sprot L0", "Speech_Tx", "In Speech Tx Switch"},
+	{ "MIX Sprot L0", "Speech_Rx", "In Speech Rx Switch"},
+	{ "MIX Sprot L0", "Tone", "In Tone Switch"},
+	{ "MIX Sprot L0", "Voip", "In Voip Switch"},
+	{ "MIX Sprot L0", "PCM0", "In PCM0 Switch"},
+	{ "MIX Sprot L0", "PCM1", "In PCM1 Switch"},
+	{ "MIX Sprot L0", "FM", "In FM Switch"},
+	/* loops have output switches coming back to mixers */
+	{ "MIX Sprot L0", "Sprot_L0", "Mix Sprot L0 Switch"},
+	{ "MIX Sprot L0", "Media_L1", "Mix Media L1 Switch"},
+	{ "MIX Sprot L0", "Media_L2", "Mix Media L2 Switch"},
+	/* sidetone comes from speech out */
+	{ "MIX Sprot L0", "Sidetone", "Mix Speech Tx Switch"},
+
+	{ "MIX Media L1", "Modem", "In Modem Switch"},
+	{ "MIX Media L1", "Codec0", "In Codec0 Switch"},
+	{ "MIX Media L1", "Codec1", "In Codec1 Switch"},
+	{ "MIX Media L1", "Speech_Tx", "In Speech Tx Switch"},
+	{ "MIX Media L1", "Speech_Rx", "In Speech Rx Switch"},
+	{ "MIX Media L1", "Tone", "In Tone Switch"},
+	{ "MIX Media L1", "Voip", "In Voip Switch"},
+	{ "MIX Media L1", "PCM0", "In PCM0 Switch"},
+	{ "MIX Media L1", "PCM1", "In PCM1 Switch"},
+	{ "MIX Media L1", "FM", "In FM Switch"},
+	/* loops have output switches coming back to mixers */
+	{ "MIX Media L1", "Sprot_L0", "Mix Sprot L0 Switch"},
+	{ "MIX Media L1", "Media_L1", "Mix Media L1 Switch"},
+	{ "MIX Media L1", "Media_L2", "Mix Media L2 Switch"},
+	/* sidetone comes from speech out */
+	{ "MIX Media L1", "Sidetone", "Mix Speech Tx Switch"},
+
+	{ "MIX Media L2", "Modem", "In Modem Switch"},
+	{ "MIX Media L2", "Codec0", "In Codec0 Switch"},
+	{ "MIX Media L2", "Codec1", "In Codec1 Switch"},
+	{ "MIX Media L2", "Speech_Tx", "In Speech Tx Switch"},
+	{ "MIX Media L2", "Speech_Rx", "In Speech Rx Switch"},
+	{ "MIX Media L2", "Tone", "In Tone Switch"},
+	{ "MIX Media L2", "Voip", "In Voip Switch"},
+	{ "MIX Media L2", "PCM0", "In PCM0 Switch"},
+	{ "MIX Media L2", "PCM1", "In PCM1 Switch"},
+	{ "MIX Media L2", "FM", "In FM Switch"},
+	/* loops have output switches coming back to mixers */
+	{ "MIX Media L2", "Sprot_L0", "Mix Sprot L0 Switch"},
+	{ "MIX Media L2", "Media_L1", "Mix Media L1 Switch"},
+	{ "MIX Media L2", "Media_L2", "Mix Media L2 Switch"},
+	/* sidetone comes from speech out */
+	{ "MIX Media L2", "Sidetone", "Mix Speech Tx Switch"},
+
+	{ "MIX Speech Rx", "Modem", "In Modem Switch"},
+	{ "MIX Speech Rx", "Codec0", "In Codec0 Switch"},
+	{ "MIX Speech Rx", "Codec1", "In Codec1 Switch"},
+	{ "MIX Speech Rx", "Speech_Tx", "In Speech Tx Switch"},
+	{ "MIX Speech Rx", "Speech_Rx", "In Speech Rx Switch"},
+	{ "MIX Speech Rx", "Tone", "In Tone Switch"},
+	{ "MIX Speech Rx", "Voip", "In Voip Switch"},
+	{ "MIX Speech Rx", "PCM0", "In PCM0 Switch"},
+	{ "MIX Speech Rx", "PCM1", "In PCM1 Switch"},
+	{ "MIX Speech Rx", "FM", "In FM Switch"},
+	/* loops have output switches coming back to mixers */
+	{ "MIX Speech Rx", "Sprot_L0", "Mix Sprot L0 Switch"},
+	{ "MIX Speech Rx", "Media_L1", "Mix Media L1 Switch"},
+	{ "MIX Speech Rx", "Media_L2", "Mix Media L2 Switch"},
+	/* sidetone comes from speech out */
+	{ "MIX Speech Rx", "Sidetone", "Mix Speech Tx Switch"},
+
+	{ "MIX Speech Tx", "Modem", "In Modem Switch"},
+	{ "MIX Speech Tx", "Codec0", "In Codec0 Switch"},
+	{ "MIX Speech Tx", "Codec1", "In Codec1 Switch"},
+	{ "MIX Speech Tx", "Speech_Tx", "In Speech Tx Switch"},
+	{ "MIX Speech Tx", "Speech_Rx", "In Speech Rx Switch"},
+	{ "MIX Speech Tx", "Tone", "In Tone Switch"},
+	{ "MIX Speech Tx", "Voip", "In Voip Switch"},
+	{ "MIX Speech Tx", "PCM0", "In PCM0 Switch"},
+	{ "MIX Speech Tx", "PCM1", "In PCM1 Switch"},
+	{ "MIX Speech Tx", "FM", "In FM Switch"},
+	/* loops have output switches coming back to mixers */
+	{ "MIX Speech Tx", "Sprot_L0", "Mix Sprot L0 Switch"},
+	{ "MIX Speech Tx", "Media_L1", "Mix Media L1 Switch"},
+	{ "MIX Speech Tx", "Media_L2", "Mix Media L2 Switch"},
+	/* sidetone comes from speech out */
+	{ "MIX Speech Tx", "Sidetone", "Mix Speech Tx Switch"},
+
+	{ "MIX Voip", "Modem", "In Modem Switch"},
+	{ "MIX Voip", "Codec0", "In Codec0 Switch"},
+	{ "MIX Voip", "Codec1", "In Codec1 Switch"},
+	{ "MIX Voip", "Speech_Tx", "In Speech Tx Switch"},
+	{ "MIX Voip", "Speech_Rx", "In Speech Rx Switch"},
+	{ "MIX Voip", "Tone", "In Tone Switch"},
+	{ "MIX Voip", "Voip", "In Voip Switch"},
+	{ "MIX Voip", "PCM0", "In PCM0 Switch"},
+	{ "MIX Voip", "PCM1", "In PCM1 Switch"},
+	{ "MIX Voip", "FM", "In FM Switch"},
+	/* loops have output switches coming back to mixers */
+	{ "MIX Voip", "Sprot_L0", "Mix Sprot L0 Switch"},
+	{ "MIX Voip", "Media_L1", "Mix Media L1 Switch"},
+	{ "MIX Voip", "Media_L2", "Mix Media L2 Switch"},
+	/* sidetone comes from speech out */
+	{ "MIX Voip", "Sidetone", "Mix Speech Tx Switch"},
+
+	{ "MIX PCM0", "Modem", "In Modem Switch"},
+	{ "MIX PCM0", "Codec0", "In Codec0 Switch"},
+	{ "MIX PCM0", "Codec1", "In Codec1 Switch"},
+	{ "MIX PCM0", "Speech_Tx", "In Speech Tx Switch"},
+	{ "MIX PCM0", "Speech_Rx", "In Speech Rx Switch"},
+	{ "MIX PCM0", "Tone", "In Tone Switch"},
+	{ "MIX PCM0", "Voip", "In Voip Switch"},
+	{ "MIX PCM0", "PCM0", "In PCM0 Switch"},
+	{ "MIX PCM0", "PCM1", "In PCM1 Switch"},
+	{ "MIX PCM0", "FM", "In FM Switch"},
+	/* loops have output switches coming back to mixers */
+	{ "MIX PCM0", "Sprot_L0", "Mix Sprot L0 Switch"},
+	{ "MIX PCM0", "Media_L1", "Mix Media L1 Switch"},
+	{ "MIX PCM0", "Media_L2", "Mix Media L2 Switch"},
+	/* sidetone comes from speech out */
+	{ "MIX PCM0", "Sidetone", "Mix Speech Tx Switch"},
+
+	{ "MIX PCM1", "Modem", "In Modem Switch"},
+	{ "MIX PCM1", "Codec0", "In Codec0 Switch"},
+	{ "MIX PCM1", "Codec1", "In Codec1 Switch"},
+	{ "MIX PCM1", "Speech_Tx", "In Speech Tx Switch"},
+	{ "MIX PCM1", "Speech_Rx", "In Speech Rx Switch"},
+	{ "MIX PCM1", "Tone", "In Tone Switch"},
+	{ "MIX PCM1", "Voip", "In Voip Switch"},
+	{ "MIX PCM1", "PCM0", "In PCM0 Switch"},
+	{ "MIX PCM1", "PCM1", "In PCM1 Switch"},
+	{ "MIX PCM1", "FM", "In FM Switch"},
+	/* loops have output switches coming back to mixers */
+	{ "MIX PCM1", "Sprot_L0", "Mix Sprot L0 Switch"},
+	{ "MIX PCM1", "Media_L1", "Mix Media L1 Switch"},
+	{ "MIX PCM1", "Media_L2", "Mix Media L2 Switch"},
+	/* sidetone comes from speech out */
+	{ "MIX PCM1", "Sidetone", "Mix Speech Tx Switch"},
+
+	{ "MIX PCM2", "Modem", "In Modem Switch"},
+	{ "MIX PCM2", "Codec0", "In Codec0 Switch"},
+	{ "MIX PCM2", "Codec1", "In Codec1 Switch"},
+	{ "MIX PCM2", "Speech_Tx", "In Speech Tx Switch"},
+	{ "MIX PCM2", "Speech_Rx", "In Speech Rx Switch"},
+	{ "MIX PCM2", "Tone", "In Tone Switch"},
+	{ "MIX PCM2", "Voip", "In Voip Switch"},
+	{ "MIX PCM2", "PCM0", "In PCM0 Switch"},
+	{ "MIX PCM2", "PCM1", "In PCM1 Switch"},
+	{ "MIX PCM2", "FM", "In FM Switch"},
+	/* loops have output switches coming back to mixers */
+	{ "MIX PCM2", "Sprot_L0", "Mix Sprot L0 Switch"},
+	{ "MIX PCM2", "Media_L1", "Mix Media L1 Switch"},
+	{ "MIX PCM2", "Media_L2", "Mix Media L2 Switch"},
+	/* sidetone comes from speech out */
+	{ "MIX PCM2", "Sidetone", "Mix Speech Tx Switch"},
+
+	{ "MIX Aware", "Modem", "In Modem Switch"},
+	{ "MIX Aware", "Codec0", "In Codec0 Switch"},
+	{ "MIX Aware", "Codec1", "In Codec1 Switch"},
+	{ "MIX Aware", "Speech_Tx", "In Speech Tx Switch"},
+	{ "MIX Aware", "Speech_Rx", "In Speech Rx Switch"},
+	{ "MIX Aware", "Tone", "In Tone Switch"},
+	{ "MIX Aware", "Voip", "In Voip Switch"},
+	{ "MIX Aware", "PCM0", "In PCM0 Switch"},
+	{ "MIX Aware", "PCM1", "In PCM1 Switch"},
+	{ "MIX Aware", "FM", "In FM Switch"},
+	/* loops have output switches coming back to mixers */
+	{ "MIX Aware", "Sprot_L0", "Mix Sprot L0 Switch"},
+	{ "MIX Aware", "Media_L1", "Mix Media L1 Switch"},
+	{ "MIX Aware", "Media_L2", "Mix Media L2 Switch"},
+	/* sidetone comes from speech out */
+	{ "MIX Aware", "Sidetone", "Mix Speech Tx Switch"},
+
+	{ "MIX VAD", "Modem", "In Modem Switch"},
+	{ "MIX VAD", "Codec0", "In Codec0 Switch"},
+	{ "MIX VAD", "Codec1", "In Codec1 Switch"},
+	{ "MIX VAD", "Speech_Tx", "In Speech Tx Switch"},
+	{ "MIX VAD", "Speech_Rx", "In Speech Rx Switch"},
+	{ "MIX VAD", "Tone", "In Tone Switch"},
+	{ "MIX VAD", "Voip", "In Voip Switch"},
+	{ "MIX VAD", "PCM0", "In PCM0 Switch"},
+	{ "MIX VAD", "PCM1", "In PCM1 Switch"},
+	{ "MIX VAD", "FM", "In FM Switch"},
+	/* loops have output switches coming back to mixers */
+	{ "MIX VAD", "Sprot_L0", "Mix Sprot L0 Switch"},
+	{ "MIX VAD", "Media_L1", "Mix Media L1 Switch"},
+	{ "MIX VAD", "Media_L2", "Mix Media L2 Switch"},
+	/* sidetone comes from speech out */
+	{ "MIX VAD", "Sidetone", "Mix Speech Tx Switch"},
+
+	{ "MIX FM", "Modem", "In Modem Switch"},
+	{ "MIX FM", "Codec0", "In Codec0 Switch"},
+	{ "MIX FM", "Codec1", "In Codec1 Switch"},
+	{ "MIX FM", "Speech_Tx", "In Speech Tx Switch"},
+	{ "MIX FM", "Speech_Rx", "In Speech Rx Switch"},
+	{ "MIX FM", "Tone", "In Tone Switch"},
+	{ "MIX FM", "Voip", "In Voip Switch"},
+	{ "MIX FM", "PCM0", "In PCM0 Switch"},
+	{ "MIX FM", "PCM1", "In PCM1 Switch"},
+	{ "MIX FM", "FM", "In FM Switch"},
+	/* loops have output switches coming back to mixers */
+	{ "MIX FM", "Sprot_L0", "Mix Sprot L0 Switch"},
+	{ "MIX FM", "Media_L1", "Mix Media L1 Switch"},
+	{ "MIX FM", "Media_L2", "Mix Media L2 Switch"},
+	/* sidetone comes from speech out */
+	{ "MIX FM", "Sidetone", "Mix Speech Tx Switch"},
+
+	/* now connect the mixers to output switches */
+	{ "Mix Modem Switch", "Switch", "MIX Modem"},
+	{ "Out Modem Switch", "Switch", "Mix Modem Switch"},
+	{ "Mix Codec0 Switch", "Switch", "MIX Codec0"},
+	{ "Out Codec0 Switch", "Switch", "Mix Codec0 Switch"},
+	{ "Mix Codec1 Switch", "Switch", "MIX Codec1"},
+	{ "Out Codec1 Switch", "Switch", "Mix Codec1 Switch"},
+	{ "Mix Speech Tx Switch", "Switch", "MIX Speech Tx"},
+	{ "Out Speech Tx Switch", "Switch", "Mix Speech Tx Switch"},
+	{ "Mix Speech Rx Switch", "Switch", "MIX Speech Rx"},
+	{ "Out Speech Rx Switch", "Switch", "Mix Speech Rx Switch"},
+	{ "Mix Voip Switch", "Switch", "MIX Voip"},
+	{ "Out Voip Switch", "Switch", "Mix Voip Switch"},
+	{ "Mix Aware Switch", "Switch", "MIX Aware"},
+	{ "Out Aware Switch", "Switch", "Mix Aware Switch"},
+	{ "Mix VAD Switch", "Switch", "MIX VAD"},
+	{ "Out VAD Switch", "Switch", "Mix VAD Switch"},
+	{ "Mix FM Switch", "Switch", "MIX FM"},
+	{ "Out FM Switch", "Switch", "Mix FM Switch"},
+	{ "Mix PCM1 Switch", "Switch", "MIX PCM1"},
+	{ "Out PCM1 Switch", "Switch", "Mix PCM1 Switch"},
+	{ "Mix PCM2 Switch", "Switch", "MIX PCM2"},
+	{ "Out PCM2 Switch", "Switch", "Mix PCM2 Switch"},
+
+	/* the loops
+	 * media loops dont have i/p o/p switches, just mixer enable
+	 */
+	{ "Mix Sprot L0 Switch", "Switch", "MIX Sprot L0"},
+	{ "Mix Media L1 Switch", "Switch", "MIX Media L1"},
+	{ "Mix Media L2 Switch", "Switch", "MIX Media L2"},
+	/* so no need as mixer switches are
+	 * inputs to all mixers
+	 * need to connect speech loops here
+	 */
+	{ "In Speech Rx Switch", "Switch", "Out Speech Rx Switch"},
+	{ "In Speech Tx Switch", "Switch", "Out Speech Tx Switch"},
+	/* last one, connect the output switches to ip's
+	 * and op's. Also connect the AIFs
+	 */
+	{ "In Modem Switch", "Switch", "Modem IN"},
+	{ "In Codec0 Switch", "Switch", "Codec IN0"},
+	{ "In Codec1 Switch", "Switch", "Codec IN1"},
+	{ "In Tone Switch", "Switch", "Tone IN"},
+	{ "In FM Switch", "Switch", "FM IN"},
+
+	{ "Modem OUT", NULL, "Out Modem Switch"},
+	{ "Codec OUT0", NULL, "Out Codec0 Switch"},
+	{ "Codec OUT1", NULL, "Out Codec1 Switch"},
+	{ "FM OUT", NULL, "Out FM Switch"},
+
+	{ "In Voip Switch", "Switch", "Voip IN"},
+
+	{ "Voip OUT", NULL, "Out Voip Switch"},
+	{ "PCM1 OUT", NULL, "Out PCM1 Switch"},
+	{ "Aware OUT", NULL, "Out Aware Switch"},
+	{ "VAD OUT", NULL, "Out VAD Switch"},
+};
+
+int sst_byte_control_get(struct snd_kcontrol *kcontrol,
+			 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+
+	pr_debug("in %s\n", __func__);
+	memcpy(ucontrol->value.bytes.data, sst->byte_stream, SST_MAX_BIN_BYTES);
+	print_hex_dump_bytes(__func__, DUMP_PREFIX_OFFSET,
+			     (const void *)sst->byte_stream, 32);
+	return 0;
+}
+
+static int sst_check_binary_input(char *stream)
+{
+	struct snd_sst_bytes_v2 *bytes = (struct snd_sst_bytes_v2 *)stream;
+
+	if (bytes->len == 0 || bytes->len > 1000) {
+		pr_err("length out of bounds %d\n", bytes->len);
+		return -EINVAL;
+	}
+	if (bytes->type == 0 || bytes->type > SND_SST_BYTES_GET) {
+		pr_err("type out of bounds: %d\n", bytes->type);
+		return -EINVAL;
+	}
+	if (bytes->block > 1) {
+		pr_err("block invalid %d\n", bytes->block);
+		return -EINVAL;
+	}
+	if (bytes->task_id == SST_TASK_ID_NONE || bytes->task_id > SST_TASK_ID_MAX) {
+		pr_err("taskid invalid %d\n", bytes->task_id);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int sst_byte_control_set(struct snd_kcontrol *kcontrol,
+			 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	int ret = 0;
+
+	pr_debug("in %s\n", __func__);
+	mutex_lock(&sst->lock);
+	memcpy(sst->byte_stream, ucontrol->value.bytes.data, SST_MAX_BIN_BYTES);
+	if (0 != sst_check_binary_input(sst->byte_stream)) {
+		mutex_unlock(&sst->lock);
+		return -EINVAL;
+	}
+	print_hex_dump_bytes(__func__, DUMP_PREFIX_OFFSET,
+			     (const void *)sst->byte_stream, 32);
+	ret = sst_dsp->ops->set_generic_params(SST_SET_BYTE_STREAM, sst->byte_stream);
+	mutex_unlock(&sst->lock);
+
+	return ret;
+}
+
+static int sst_pipe_id_control_get(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	int ret = 0;
+
+	ucontrol->value.integer.value[0] = sst->pipe_id;
+
+	return ret;
+}
+
+static int sst_pipe_id_control_set(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	int ret = 0;
+
+	sst->pipe_id = ucontrol->value.integer.value[0];
+	pr_debug("%s: pipe_id %d", __func__, sst->pipe_id);
+
+	return ret;
+}
+
+/* dB range for mrfld compress volume is -144dB to +36dB.
+ * Gain library expects user input in terms of 0.1dB, for example,
+ * 60 (in decimal) represents 6dB.
+ * MW will pass 2's complement value for negative dB values.
+ */
+static int sst_compr_vol_get(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	struct sst_algo_int_control_v2 *amc = (void *)kcontrol->private_value;
+	u16 gain;
+	unsigned int gain_offset, ret;
+
+	sst_create_compr_vol_ipc(sst->byte_stream, SND_SST_BYTES_GET, amc);
+	mutex_lock(&sst->lock);
+	ret = sst_dsp->ops->set_generic_params(SST_SET_BYTE_STREAM,
+						sst->byte_stream);
+	mutex_unlock(&sst->lock);
+	if (ret) {
+		pr_err("failed to get compress vol from fw: %d\n", ret);
+		return ret;
+	}
+	gain_offset = sizeof(struct snd_sst_bytes_v2) +
+				sizeof(struct ipc_dsp_hdr);
+
+	/* Get params format for vol ctrl lib, size 6 bytes :
+	 * u16 left_gain, u16 right_gain, u16 ramp
+	 */
+	memcpy(&gain,
+		(unsigned int *)(sst->byte_stream + gain_offset),
+		sizeof(u16));
+	pr_debug("%s: cell_gain = %d\n", __func__, gain);
+	amc->value = gain;
+	ucontrol->value.integer.value[0] = gain;
+	return 0;
+}
+
+static int sst_compr_vol_set(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	struct sst_algo_int_control_v2 *amc = (void *)kcontrol->private_value;
+	int ret = 0;
+	unsigned int old_val;
+
+	pr_debug("%s: cell_gain = %ld\n", __func__,\
+				ucontrol->value.integer.value[0]);
+	old_val = amc->value;
+	amc->value = ucontrol->value.integer.value[0];
+	sst_create_compr_vol_ipc(sst->byte_stream, SND_SST_BYTES_SET,
+					amc);
+
+	mutex_lock(&sst->lock);
+	ret = sst_dsp->ops->set_generic_params(SST_SET_BYTE_STREAM,
+						sst->byte_stream);
+	mutex_unlock(&sst->lock);
+	if (ret) {
+		pr_err("failed to set compress vol in fw: %d\n", ret);
+		amc->value = old_val;
+		return ret;
+	}
+	return 0;
+}
+
+int sst_vtsv_enroll_set(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	int ret = 0;
+
+	sst->vtsv_enroll = ucontrol->value.integer.value[0];
+	mutex_lock(&sst->lock);
+	if (sst->vtsv_enroll)
+		ret = sst_dsp->ops->set_generic_params(SST_SET_VTSV_INFO,
+					(void *)&sst->vtsv_enroll);
+	mutex_unlock(&sst->lock);
+	return ret;
+}
+
+int sst_vtsv_enroll_get(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+
+	ucontrol->value.integer.value[0] = sst->vtsv_enroll;
+	return 0;
+}
+
+/* This value corresponds to two's complement value of -10 or -1dB */
+#define SST_COMPR_VOL_MAX_INTEG_GAIN 0xFFF6
+#define SST_COMPR_VOL_MUTE 0xFA60 /* 2's complement of -1440 or -144dB*/
+
+
+static const struct snd_kcontrol_new sst_mrfld_controls[] = {
+	SND_SOC_BYTES_EXT("SST Byte control", SST_MAX_BIN_BYTES,
+		       sst_byte_control_get, sst_byte_control_set),
+	SOC_SINGLE_EXT("SST Pipe_id control", SST_PIPE_CONTROL, 0, 0x9A, 0,
+		sst_pipe_id_control_get, sst_pipe_id_control_set),
+	SST_ALGO_KCONTROL_INT("Compress Volume", SST_COMPRESS_VOL,
+		0, SST_COMPR_VOL_MAX_INTEG_GAIN, 0,
+		sst_compr_vol_get, sst_compr_vol_set,
+		SST_ALGO_VOLUME_CONTROL, PIPE_MEDIA0_IN, 0,
+		SST_COMPR_VOL_MUTE),
+	SOC_SINGLE_BOOL_EXT("SST VTSV Enroll", 0, sst_vtsv_enroll_get,
+		       sst_vtsv_enroll_set),
+};
+
+static DEVICE_ULONG_ATTR(low_latency_threshold, 0644, ll_threshold);
+static DEVICE_ULONG_ATTR(deep_buffer_threshold, 0644, db_threshold);
+
+static struct attribute *device_sysfs_attrs[] = {
+	&dev_attr_low_latency_threshold.attr.attr,
+	&dev_attr_deep_buffer_threshold.attr.attr,
+	NULL,
+};
+
+static struct attribute_group attr_group = {
+	.attrs = device_sysfs_attrs,
+};
+
+int sst_dsp_init(struct snd_soc_platform *platform)
+{
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	int error = 0;
+
+	sst->byte_stream = devm_kzalloc(platform->dev,
+			SST_MAX_BIN_BYTES, GFP_KERNEL);
+	if (sst->byte_stream == NULL) {
+		pr_err("kzalloc failed\n");
+		return -ENOMEM;
+	}
+
+	sst->widget = devm_kzalloc(platform->dev,
+				   SST_NUM_WIDGETS * sizeof(*sst->widget),
+				   GFP_KERNEL);
+	if (sst->widget == NULL) {
+		pr_err("kzalloc failed\n");
+		return -ENOMEM;
+	}
+
+	sst->vtsv_enroll = false;
+	/* Assign the pointer variables */
+	sst->ll_db.low_latency = &ll_threshold;
+	sst->ll_db.deep_buffer = &db_threshold;
+
+	pr_debug("Default ll thres %lu db thres %lu\n", ll_threshold, db_threshold);
+
+	snd_soc_dapm_new_controls(&platform->dapm, sst_dapm_widgets,
+			ARRAY_SIZE(sst_dapm_widgets));
+	snd_soc_dapm_add_routes(&platform->dapm, intercon,
+			ARRAY_SIZE(intercon));
+	snd_soc_dapm_new_widgets(platform->dapm.card);
+	snd_soc_add_platform_controls(platform, sst_mrfld_controls,
+			ARRAY_SIZE(sst_mrfld_controls));
+
+	error = sysfs_create_group(&platform->dev->kobj, &attr_group);
+	if (error)
+		pr_err("failed to create sysfs files  %d\n", error);
+
+	return error;
+}
diff --git a/sound/soc/intel/platform-libs/controls_v2.h b/sound/soc/intel/platform-libs/controls_v2.h
new file mode 100644
index 0000000..52e7447
--- /dev/null
+++ b/sound/soc/intel/platform-libs/controls_v2.h
@@ -0,0 +1,705 @@
+/*
+ *  controls_v2.h - Intel MID Platform driver header file
+ *
+ *  Copyright (C) 2013 Intel Corp
+ *  Author: Ramesh Babu <ramesh.babu.koul@intel.com>
+ *  Author: Omair M Abdullah <omair.m.abdullah@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ */
+
+#ifndef __SST_CONTROLS_V2_H__
+#define __SST_CONTROLS_V2_H__
+
+/*
+ * This section defines the map for the mixer widgets.
+ *
+ * Each mixer will be represented by single value and that value will have each
+ * bit corresponding to one input
+ *
+ * Each out_id will correspond to one mixer and one path. Each input will be
+ * represented by single bit in the register.
+ */
+
+/* mixer register ids here */
+#define SST_MIX(x)		(x)
+
+#define SST_MIX_MODEM		SST_MIX(0)
+#define SST_MIX_BT		SST_MIX(1)
+#define SST_MIX_CODEC0		SST_MIX(2)
+#define SST_MIX_CODEC1		SST_MIX(3)
+#define SST_MIX_LOOP0		SST_MIX(4)
+#define SST_MIX_LOOP1		SST_MIX(5)
+#define SST_MIX_LOOP2		SST_MIX(6)
+#define SST_MIX_PROBE		SST_MIX(7)
+#define SST_MIX_HF_SNS		SST_MIX(8)
+#define SST_MIX_HF		SST_MIX(9)
+#define SST_MIX_SPEECH		SST_MIX(10)
+#define SST_MIX_RXSPEECH	SST_MIX(11)
+#define SST_MIX_VOIP		SST_MIX(12)
+#define SST_MIX_PCM0		SST_MIX(13)
+#define SST_MIX_PCM1		SST_MIX(14)
+#define SST_MIX_PCM2		SST_MIX(15)
+#define SST_MIX_AWARE		SST_MIX(16)
+#define SST_MIX_VAD		SST_MIX(17)
+#define SST_MIX_FM		SST_MIX(18)
+
+#define SST_MIX_MEDIA0		SST_MIX(19)
+#define SST_MIX_MEDIA1		SST_MIX(20)
+
+#define SST_NUM_MIX		(SST_MIX_MEDIA1 + 1)
+
+#define SST_MIX_SWITCH		(SST_NUM_MIX + 1)
+#define SST_OUT_SWITCH		(SST_NUM_MIX + 2)
+#define SST_IN_SWITCH		(SST_NUM_MIX + 3)
+#define SST_MUX_REG		(SST_NUM_MIX + 4)
+#define SST_REG_LAST		(SST_MUX_REG)
+
+/* last entry defines array size */
+#define SST_NUM_WIDGETS		(SST_REG_LAST + 1)
+
+/* in each mixer register we will define one bit for each input */
+#define SST_MIX_IP(x)		(x)
+
+#define SST_IP_MODEM		SST_MIX_IP(0)
+#define SST_IP_BT		SST_MIX_IP(1)
+#define SST_IP_CODEC0		SST_MIX_IP(2)
+#define SST_IP_CODEC1		SST_MIX_IP(3)
+#define SST_IP_LOOP0		SST_MIX_IP(4)
+#define SST_IP_LOOP1		SST_MIX_IP(5)
+#define SST_IP_LOOP2		SST_MIX_IP(6)
+#define SST_IP_PROBE		SST_MIX_IP(7)
+#define SST_IP_SIDETONE		SST_MIX_IP(8)
+#define SST_IP_TXSPEECH		SST_MIX_IP(9)
+#define SST_IP_SPEECH		SST_MIX_IP(10)
+#define SST_IP_TONE		SST_MIX_IP(11)
+#define SST_IP_VOIP		SST_MIX_IP(12)
+#define SST_IP_PCM0		SST_MIX_IP(13)
+#define SST_IP_PCM1		SST_MIX_IP(14)
+#define SST_IP_LOW_PCM0		SST_MIX_IP(15)
+#define SST_IP_FM		SST_MIX_IP(16)
+#define SST_IP_MEDIA0		SST_MIX_IP(17)
+#define SST_IP_MEDIA1		SST_MIX_IP(18)
+#define SST_IP_MEDIA2		SST_MIX_IP(19)
+#define SST_IP_MEDIA3		SST_MIX_IP(20)
+
+#define SST_IP_LAST		SST_IP_MEDIA3
+
+#define SST_SWM_INPUT_COUNT	(SST_IP_LAST + 1)
+#define SST_CMD_SWM_MAX_INPUTS	6
+
+#define SST_PATH_ID_SHIFT	8
+#define SST_DEFAULT_LOCATION_ID	0xFFFF
+#define SST_DEFAULT_CELL_NBR	0xFF
+#define SST_DEFAULT_MODULE_ID	0xFFFF
+
+/*
+ * Audio DSP Path Ids. Specified by the audio DSP FW
+ */
+enum sst_path_index {
+	SST_PATH_INDEX_MODEM_OUT                = (0x00 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_BT_OUT                   = (0x01 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_CODEC_OUT0               = (0x02 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_CODEC_OUT1               = (0x03 << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_SPROT_LOOP_OUT           = (0x04 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_MEDIA_LOOP1_OUT          = (0x05 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_MEDIA_LOOP2_OUT          = (0x06 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PROBE_OUT                = (0x07 << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_HF_SNS_OUT               = (0x08 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_VOICE_UPLINK_REF2	= (0x08 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_HF_OUT                   = (0x09 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_VOICE_UPLINK_REF1	= (0x09 << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_SPEECH_OUT               = (0x0A << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_VOICE_UPLINK		= (0x0A << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_RX_SPEECH_OUT            = (0x0B << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_VOICE_DOWNLINK		= (0x0B << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_VOIP_OUT                 = (0x0C << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PCM0_OUT                 = (0x0D << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PCM1_OUT                 = (0x0E << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PCM2_OUT                 = (0x0F << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_AWARE_OUT                = (0x10 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_VAD_OUT                  = (0x11 << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_MEDIA0_OUT               = (0x12 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_MEDIA1_OUT               = (0x13 << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_FM_OUT                   = (0x14 << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_PROBE1_PIPE_OUT		= (0x15 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PROBE2_PIPE_OUT		= (0x16 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PROBE3_PIPE_OUT		= (0x17 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PROBE4_PIPE_OUT		= (0x18 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PROBE5_PIPE_OUT		= (0x19 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PROBE6_PIPE_OUT		= (0x1A << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PROBE7_PIPE_OUT		= (0x1B << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PROBE8_PIPE_OUT		= (0x1C << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_SIDETONE_OUT		= (0x1D << SST_PATH_ID_SHIFT),
+
+	/* Start of input paths */
+	SST_PATH_INDEX_MODEM_IN                 = (0x80 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_BT_IN                    = (0x81 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_CODEC_IN0                = (0x82 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_CODEC_IN1                = (0x83 << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_SPROT_LOOP_IN            = (0x84 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_MEDIA_LOOP1_IN           = (0x85 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_MEDIA_LOOP2_IN           = (0x86 << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_PROBE_IN                 = (0x87 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_SIDETONE_IN              = (0x88 << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_TX_SPEECH_IN             = (0x89 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_SPEECH_IN                = (0x8A << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_TONE_IN                  = (0x8B << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_VOIP_IN                  = (0x8C << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_PCM0_IN                  = (0x8D << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PCM1_IN                  = (0x8E << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_MEDIA0_IN                = (0x8F << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_MEDIA1_IN                = (0x90 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_MEDIA2_IN                = (0x91 << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_FM_IN                    = (0x92 << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_PROBE1_PIPE_IN           = (0x93 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PROBE2_PIPE_IN           = (0x94 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PROBE3_PIPE_IN           = (0x95 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PROBE4_PIPE_IN           = (0x96 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PROBE5_PIPE_IN           = (0x97 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PROBE6_PIPE_IN           = (0x98 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PROBE7_PIPE_IN           = (0x99 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PROBE8_PIPE_IN           = (0x9A << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_MEDIA3_IN		= (0x9C << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_LOW_PCM0_IN		= (0x9D << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_RESERVED                 = (0xFF << SST_PATH_ID_SHIFT),
+};
+
+/*
+ * switch matrix input path IDs
+ */
+enum sst_swm_inputs {
+	SST_SWM_IN_MODEM	= (SST_PATH_INDEX_MODEM_IN	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_BT		= (SST_PATH_INDEX_BT_IN		  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_CODEC0	= (SST_PATH_INDEX_CODEC_IN0	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_CODEC1	= (SST_PATH_INDEX_CODEC_IN1	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_SPROT_LOOP	= (SST_PATH_INDEX_SPROT_LOOP_IN	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_MEDIA_LOOP1	= (SST_PATH_INDEX_MEDIA_LOOP1_IN  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_MEDIA_LOOP2	= (SST_PATH_INDEX_MEDIA_LOOP2_IN  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_PROBE	= (SST_PATH_INDEX_PROBE_IN	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_SIDETONE	= (SST_PATH_INDEX_SIDETONE_IN	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_TXSPEECH	= (SST_PATH_INDEX_TX_SPEECH_IN	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_SPEECH	= (SST_PATH_INDEX_SPEECH_IN	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_TONE		= (SST_PATH_INDEX_TONE_IN	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_VOIP		= (SST_PATH_INDEX_VOIP_IN	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_PCM0		= (SST_PATH_INDEX_PCM0_IN	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_PCM1		= (SST_PATH_INDEX_PCM1_IN	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_MEDIA0	= (SST_PATH_INDEX_MEDIA0_IN	  | SST_DEFAULT_CELL_NBR), /* Part of Media Mixer */
+	SST_SWM_IN_MEDIA1	= (SST_PATH_INDEX_MEDIA1_IN	  | SST_DEFAULT_CELL_NBR), /* Part of Media Mixer */
+	SST_SWM_IN_MEDIA2	= (SST_PATH_INDEX_MEDIA2_IN	  | SST_DEFAULT_CELL_NBR), /* Part of Media Mixer */
+	SST_SWM_IN_FM		= (SST_PATH_INDEX_FM_IN		  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_MEDIA3	= (SST_PATH_INDEX_MEDIA3_IN	  | SST_DEFAULT_CELL_NBR), /* Part of Media Mixer */
+	SST_SWM_IN_LOW_PCM0	= (SST_PATH_INDEX_LOW_PCM0_IN	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_END		= (SST_PATH_INDEX_RESERVED	  | SST_DEFAULT_CELL_NBR)
+};
+
+/*
+ * switch matrix output path IDs
+ */
+enum sst_swm_outputs {
+	SST_SWM_OUT_MODEM	= (SST_PATH_INDEX_MODEM_OUT	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_BT		= (SST_PATH_INDEX_BT_OUT	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_CODEC0	= (SST_PATH_INDEX_CODEC_OUT0	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_CODEC1	= (SST_PATH_INDEX_CODEC_OUT1	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_SPROT_LOOP	= (SST_PATH_INDEX_SPROT_LOOP_OUT  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_MEDIA_LOOP1	= (SST_PATH_INDEX_MEDIA_LOOP1_OUT | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_MEDIA_LOOP2	= (SST_PATH_INDEX_MEDIA_LOOP2_OUT | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_PROBE	= (SST_PATH_INDEX_PROBE_OUT	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_HF_SNS	= (SST_PATH_INDEX_HF_SNS_OUT	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_HF		= (SST_PATH_INDEX_HF_OUT	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_SPEECH	= (SST_PATH_INDEX_SPEECH_OUT	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_RXSPEECH	= (SST_PATH_INDEX_RX_SPEECH_OUT	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_VOIP	= (SST_PATH_INDEX_VOIP_OUT	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_PCM0	= (SST_PATH_INDEX_PCM0_OUT	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_PCM1	= (SST_PATH_INDEX_PCM1_OUT	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_PCM2	= (SST_PATH_INDEX_PCM2_OUT	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_AWARE	= (SST_PATH_INDEX_AWARE_OUT	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_VAD		= (SST_PATH_INDEX_VAD_OUT	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_MEDIA0	= (SST_PATH_INDEX_MEDIA0_OUT	  | SST_DEFAULT_CELL_NBR), /* Part of Media Mixer */
+	SST_SWM_OUT_MEDIA1	= (SST_PATH_INDEX_MEDIA1_OUT	  | SST_DEFAULT_CELL_NBR), /* Part of Media Mixer */
+	SST_SWM_OUT_FM		= (SST_PATH_INDEX_FM_OUT	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_END		= (SST_PATH_INDEX_RESERVED	  | SST_DEFAULT_CELL_NBR),
+};
+
+enum sst_ipc_msg {
+	SST_IPC_IA_CMD = 1,
+	SST_IPC_IA_SET_PARAMS,
+	SST_IPC_IA_GET_PARAMS,
+};
+
+enum sst_cmd_type {
+	SST_CMD_BYTES_SET = 1,
+	SST_CMD_BYTES_GET = 2,
+};
+
+enum sst_task {
+	SST_TASK_SBA = 1,
+	SST_TASK_FBA_UL,
+	SST_TASK_MMX,
+	SST_TASK_AWARE,
+	SST_TASK_FBA_DL,
+};
+
+enum sst_type {
+	SST_TYPE_CMD = 1,
+	SST_TYPE_PARAMS,
+};
+
+enum sst_flag {
+	SST_FLAG_BLOCKED = 1,
+	SST_FLAG_NONBLOCK,
+};
+
+/*
+ * Enumeration for indexing the gain cells in VB_SET_GAIN DSP command
+ */
+enum sst_gain_index {
+	/* GAIN IDs for SB task start here */
+	SST_GAIN_INDEX_MODEM_OUT,
+	SST_GAIN_INDEX_MODEM_IN,
+	SST_GAIN_INDEX_BT_OUT,
+	SST_GAIN_INDEX_BT_IN,
+	SST_GAIN_INDEX_FM_OUT,
+
+	SST_GAIN_INDEX_FM_IN,
+	SST_GAIN_INDEX_CODEC_OUT0,
+	SST_GAIN_INDEX_CODEC_OUT1,
+	SST_GAIN_INDEX_CODEC_IN0,
+	SST_GAIN_INDEX_CODEC_IN1,
+
+	SST_GAIN_INDEX_SPROT_LOOP_OUT,
+	SST_GAIN_INDEX_MEDIA_LOOP1_OUT,
+	SST_GAIN_INDEX_MEDIA_LOOP2_OUT,
+	SST_GAIN_INDEX_RX_SPEECH_OUT,
+	SST_GAIN_INDEX_TX_SPEECH_IN,
+
+	SST_GAIN_INDEX_SPEECH_OUT,
+	SST_GAIN_INDEX_SPEECH_IN,
+	SST_GAIN_INDEX_HF_OUT,
+	SST_GAIN_INDEX_HF_SNS_OUT,
+	SST_GAIN_INDEX_TONE_IN,
+
+	SST_GAIN_INDEX_SIDETONE_IN,
+	SST_GAIN_INDEX_PROBE_OUT,
+	SST_GAIN_INDEX_PROBE_IN,
+	SST_GAIN_INDEX_PCM0_IN_LEFT,
+	SST_GAIN_INDEX_PCM0_IN_RIGHT,
+
+	SST_GAIN_INDEX_PCM1_OUT_LEFT,
+	SST_GAIN_INDEX_PCM1_OUT_RIGHT,
+	SST_GAIN_INDEX_PCM1_IN_LEFT,
+	SST_GAIN_INDEX_PCM1_IN_RIGHT,
+	SST_GAIN_INDEX_PCM2_OUT_LEFT,
+
+	SST_GAIN_INDEX_PCM2_OUT_RIGHT,
+	SST_GAIN_INDEX_VOIP_OUT,
+	SST_GAIN_INDEX_VOIP_IN,
+	SST_GAIN_INDEX_AWARE_OUT,
+	SST_GAIN_INDEX_VAD_OUT,
+
+	/* Gain IDs for FBA task start here */
+	SST_GAIN_INDEX_VOICE_UL,
+
+	/* Gain IDs for MMX task start here */
+	SST_GAIN_INDEX_MEDIA0_IN_LEFT,
+	SST_GAIN_INDEX_MEDIA0_IN_RIGHT,
+	SST_GAIN_INDEX_MEDIA1_IN_LEFT,
+	SST_GAIN_INDEX_MEDIA1_IN_RIGHT,
+
+	SST_GAIN_INDEX_MEDIA2_IN_LEFT,
+	SST_GAIN_INDEX_MEDIA2_IN_RIGHT,
+
+	SST_GAIN_INDEX_GAIN_END
+};
+
+/*
+ * Audio DSP module IDs specified by FW spec
+ * TODO: Update with all modules
+ */
+enum sst_module_id {
+	SST_MODULE_ID_PCM		  = 0x0001,
+	SST_MODULE_ID_MP3		  = 0x0002,
+	SST_MODULE_ID_MP24		  = 0x0003,
+	SST_MODULE_ID_AAC		  = 0x0004,
+	SST_MODULE_ID_AACP		  = 0x0005,
+	SST_MODULE_ID_EAACP		  = 0x0006,
+	SST_MODULE_ID_WMA9		  = 0x0007,
+	SST_MODULE_ID_WMA10		  = 0x0008,
+	SST_MODULE_ID_WMA10P		  = 0x0009,
+	SST_MODULE_ID_RA		  = 0x000A,
+	SST_MODULE_ID_DDAC3		  = 0x000B,
+	SST_MODULE_ID_TRUE_HD		  = 0x000C,
+	SST_MODULE_ID_HD_PLUS		  = 0x000D,
+
+	SST_MODULE_ID_SRC		  = 0x0064,
+	SST_MODULE_ID_DOWNMIX		  = 0x0066,
+	SST_MODULE_ID_GAIN_CELL		  = 0x0067,
+	SST_MODULE_ID_SPROT		  = 0x006D,
+	SST_MODULE_ID_BASS_BOOST	  = 0x006E,
+	SST_MODULE_ID_STEREO_WDNG	  = 0x006F,
+	SST_MODULE_ID_AV_REMOVAL	  = 0x0070,
+	SST_MODULE_ID_MIC_EQ		  = 0x0071,
+	SST_MODULE_ID_SPL		  = 0x0072,
+	SST_MODULE_ID_ALGO_VTSV           = 0x0073,
+	SST_MODULE_ID_NR		  = 0x0076,
+	SST_MODULE_ID_BWX		  = 0x0077,
+	SST_MODULE_ID_DRP		  = 0x0078,
+	SST_MODULE_ID_MDRP		  = 0x0079,
+
+	SST_MODULE_ID_ANA		  = 0x007A,
+	SST_MODULE_ID_AEC		  = 0x007B,
+	SST_MODULE_ID_NR_SNS		  = 0x007C,
+	SST_MODULE_ID_SER		  = 0x007D,
+	SST_MODULE_ID_AGC		  = 0x007E,
+
+	SST_MODULE_ID_CNI		  = 0x007F,
+	SST_MODULE_ID_CONTEXT_ALGO_AWARE  = 0x0080,
+	SST_MODULE_ID_FIR_24		  = 0x0081,
+	SST_MODULE_ID_IIR_24		  = 0x0082,
+
+	SST_MODULE_ID_ASRC		  = 0x0083,
+	SST_MODULE_ID_TONE_GEN		  = 0x0084,
+	SST_MODULE_ID_BMF		  = 0x0086,
+	SST_MODULE_ID_EDL		  = 0x0087,
+	SST_MODULE_ID_GLC		  = 0x0088,
+
+	SST_MODULE_ID_FIR_16		  = 0x0089,
+	SST_MODULE_ID_IIR_16		  = 0x008A,
+	SST_MODULE_ID_DNR		  = 0x008B,
+
+	SST_MODULE_ID_VIRTUALIZER	  = 0x008C,
+	SST_MODULE_ID_VISUALIZATION	  = 0x008D,
+	SST_MODULE_ID_LOUDNESS_OPTIMIZER  = 0x008E,
+	SST_MODULE_ID_REVERBERATION	  = 0x008F,
+
+	SST_MODULE_ID_CNI_TX		  = 0x0090,
+	SST_MODULE_ID_REF_LINE		  = 0x0091,
+	SST_MODULE_ID_VOLUME		  = 0x0092,
+	SST_MODULE_ID_FILT_DCR		  = 0x0094,
+	SST_MODULE_ID_SLV		  = 0x009A,
+	SST_MODULE_ID_NLF		  = 0x009B,
+	SST_MODULE_ID_TNR		  = 0x009C,
+	SST_MODULE_ID_WNR		  = 0x009D,
+
+	SST_MODULE_ID_LOG		  = 0xFF00,
+
+	SST_MODULE_ID_TASK		  = 0xFFFF,
+};
+
+enum sst_cmd {
+	SBA_IDLE		= 14,
+	SBA_VB_SET_SPEECH_PATH	= 26,
+	MMX_SET_GAIN		= 33,
+	SBA_VB_SET_GAIN		= 33,
+	FBA_VB_RX_CNI		= 35,
+	MMX_SET_GAIN_TIMECONST	= 36,
+	SBA_VB_SET_TIMECONST	= 36,
+	FBA_VB_ANA		= 37,
+	FBA_VB_SET_FIR		= 38,
+	FBA_VB_SET_IIR		= 39,
+	SBA_VB_START_TONE	= 41,
+	SBA_VB_STOP_TONE	= 42,
+	FBA_VB_AEC		= 47,
+	FBA_VB_NR_UL		= 48,
+	FBA_VB_AGC		= 49,
+	FBA_VB_WNR		= 52,
+	FBA_VB_SLV		= 53,
+	FBA_VB_NR_DL		= 55,
+	SBA_PROBE		= 66,
+	MMX_PROBE		= 66,
+	FBA_VB_SET_BIQUAD_D_C	= 69,
+	FBA_VB_DUAL_BAND_COMP	= 70,
+	FBA_VB_SNS		= 72,
+	FBA_VB_SER		= 78,
+	FBA_VB_TX_CNI		= 80,
+	SBA_VB_START		= 85,
+	FBA_VB_SET_REF_LINE	= 94,
+	FBA_VB_SET_DELAY_LINE	= 95,
+	FBA_VB_BWX		= 104,
+	FBA_VB_GMM		= 105,
+	FBA_VB_GLC		= 107,
+	FBA_VB_BMF		= 111,
+	FBA_VB_DNR		= 113,
+	MMX_SET_SWM		= 114,
+	SBA_SET_SWM		= 114,
+	SBA_SET_MDRP            = 116,
+	SBA_HW_SET_SSP		= 117,
+	SBA_SET_MEDIA_LOOP_MAP	= 118,
+	SBA_SET_MEDIA_PATH	= 119,
+	MMX_SET_MEDIA_PATH	= 119,
+	FBA_VB_TNR_UL		= 119,
+	FBA_VB_TNR_DL		= 121,
+	FBA_VB_NLF		= 125,
+	SBA_VB_LPRO		= 126,
+	FBA_VB_MDRP		= 127,
+	SBA_VB_SET_FIR          = 128,
+	SBA_VB_SET_IIR          = 129,
+	SBA_SET_SSP_SLOT_MAP	= 130,
+	AWARE_ENV_CLASS_PARAMS	= 130,
+	VAD_ENV_CLASS_PARAMS	= 2049,
+};
+
+enum sst_dsp_switch {
+	SST_SWITCH_OFF = 0,
+	SST_SWITCH_ON = 3,
+};
+
+enum sst_path_switch {
+	SST_PATH_OFF = 0,
+	SST_PATH_ON = 1,
+};
+
+enum sst_swm_state {
+	SST_SWM_OFF = 0,
+	SST_SWM_ON = 3,
+};
+
+#define SST_FILL_LOCATION_IDS(dst, cell_idx, pipe_id)		do {	\
+		dst.location_id.p.cell_nbr_idx = (cell_idx);		\
+		dst.location_id.p.path_id = (pipe_id);			\
+	} while (0)
+#define SST_FILL_LOCATION_ID(dst, loc_id)				(\
+	dst.location_id.f = (loc_id))
+#define SST_FILL_MODULE_ID(dst, mod_id)					(\
+	dst.module_id = (mod_id))
+
+#define SST_FILL_DESTINATION1(dst, id)				do {	\
+		SST_FILL_LOCATION_ID(dst, (id) & 0xFFFF);		\
+		SST_FILL_MODULE_ID(dst, ((id) & 0xFFFF0000) >> 16);	\
+	} while (0)
+#define SST_FILL_DESTINATION2(dst, loc_id, mod_id)		do {	\
+		SST_FILL_LOCATION_ID(dst, loc_id);			\
+		SST_FILL_MODULE_ID(dst, mod_id);			\
+	} while (0)
+#define SST_FILL_DESTINATION3(dst, cell_idx, path_id, mod_id)	do {	\
+		SST_FILL_LOCATION_IDS(dst, cell_idx, path_id);		\
+		SST_FILL_MODULE_ID(dst, mod_id);			\
+	} while (0)
+
+#define SST_FILL_DESTINATION(level, dst, ...)				\
+	SST_FILL_DESTINATION##level(dst, __VA_ARGS__)
+#define SST_FILL_DEFAULT_DESTINATION(dst)				\
+	SST_FILL_DESTINATION(2, dst, SST_DEFAULT_LOCATION_ID, SST_DEFAULT_MODULE_ID)
+
+struct sst_destination_id {
+	union sst_location_id {
+		struct {
+			u8 cell_nbr_idx;	/* module index */
+			u8 path_id;		/* pipe_id */
+		} __packed	p;		/* part */
+		u16		f;		/* full */
+	} __packed location_id;
+	u16	   module_id;
+} __packed;
+
+struct sst_dsp_header {
+	struct sst_destination_id dst;
+	u16 command_id;
+	u16 length;
+} __packed;
+
+/*
+ *
+ * Common Commands
+ *
+ */
+struct sst_cmd_generic {
+	struct sst_dsp_header header;
+} __packed;
+
+struct swm_input_ids {
+	struct sst_destination_id input_id;
+} __packed;
+
+struct sst_cmd_set_swm {
+	struct sst_dsp_header header;
+	struct sst_destination_id output_id;
+	u16    switch_state;
+	u16    nb_inputs;
+	struct swm_input_ids input[SST_CMD_SWM_MAX_INPUTS];
+} __packed;
+
+struct sst_cmd_set_media_path {
+	struct sst_dsp_header header;
+	u16    switch_state;
+} __packed;
+
+struct pcm_cfg {
+		u8 s_length:2;
+		u8 rate:3;
+		u8 format:3;
+} __packed;
+
+struct sst_cmd_set_speech_path {
+	struct sst_dsp_header header;
+	u16    switch_state;
+	struct {
+		u16 rsvd:8;
+		struct pcm_cfg cfg;
+	} config;
+} __packed;
+
+struct gain_cell {
+	struct sst_destination_id dest;
+	s16 cell_gain_left;
+	s16 cell_gain_right;
+	u16 gain_time_constant;
+} __packed;
+
+#define NUM_GAIN_CELLS 1
+struct sst_cmd_set_gain_dual {
+	struct sst_dsp_header header;
+	u16    gain_cell_num;
+	struct gain_cell cell_gains[NUM_GAIN_CELLS];
+} __packed;
+
+struct sst_cmd_set_params {
+	struct sst_destination_id dst;
+	u16 command_id;
+	char params[0];
+} __packed;
+
+/*
+ *
+ * Media (MMX) commands
+ *
+ */
+
+/*
+ *
+ * SBA commands
+ *
+ */
+struct sst_cmd_sba_vb_start {
+	struct sst_dsp_header header;
+} __packed;
+
+union sba_media_loop_params {
+	struct {
+		u16 rsvd:8;
+		struct pcm_cfg cfg;
+	} part;
+	u16 full;
+} __packed;
+
+struct sst_cmd_sba_set_media_loop_map {
+	struct	sst_dsp_header header;
+	u16	switch_state;
+	union	sba_media_loop_params param;
+	u16	map;
+} __packed;
+
+struct sst_cmd_tone_stop {
+	struct	sst_dsp_header header;
+	u16	switch_state;
+} __packed;
+
+struct sst_cmd_sba_hw_set_ssp {
+	struct sst_dsp_header header;
+	u16 selection;			/* 0:SSP0(def), 1:SSP1, 2:SSP2 */
+
+	u16 switch_state;
+
+	u16 nb_bits_per_slots:6;        /* 0-32 bits, 24 (def) */
+	u16 nb_slots:4;			/* 0-8: slots per frame  */
+	u16 mode:3;			/* 0:Master, 1: Slave  */
+	u16 duplex:3;
+
+	u16 active_tx_slot_map:8;       /* Bit map, 0:off, 1:on */
+	u16 reserved1:8;
+
+	u16 active_rx_slot_map:8;       /* Bit map 0: Off, 1:On */
+	u16 reserved2:8;
+
+	u16 frame_sync_frequency;
+
+	u16 frame_sync_polarity:8;
+	u16 data_polarity:8;
+
+	u16 frame_sync_width;           /* 1 to N clocks */
+	u16 ssp_protocol:8;
+	u16 start_delay:8;		/* Start delay in terms of clock ticks */
+} __packed;
+
+#define SST_MAX_TDM_SLOTS 8
+
+struct sst_param_sba_ssp_slot_map {
+	struct sst_dsp_header header;
+
+	u16 param_id;
+	u16 param_len;
+	u16 ssp_index;
+
+	u8 rx_slot_map[SST_MAX_TDM_SLOTS];
+	u8 tx_slot_map[SST_MAX_TDM_SLOTS];
+} __packed;
+
+enum {
+	SST_PROBE_EXTRACTOR = 0,
+	SST_PROBE_INJECTOR = 1,
+};
+
+struct sst_cmd_probe {
+	struct sst_dsp_header header;
+
+	u16 switch_state;
+	struct sst_destination_id probe_dst;
+
+	u16 shared_mem:1;
+	u16 probe_in:1;
+	u16 probe_out:1;
+	u16 rsvd_1:13;
+
+	u16 rsvd_2:5;
+	u16 probe_mode:2;
+	u16 rsvd_3:1;
+	struct pcm_cfg cfg;
+
+	u16 sm_buf_id;
+
+	u16 gain[6];
+	u16 rsvd_4[9];
+} __packed;
+
+struct sst_probe_config {
+	const char *name;
+	u16 loc_id;
+	u16 mod_id;
+	u8 task_id;
+	struct pcm_cfg cfg;
+};
+
+int sst_mix_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol);
+int sst_mix_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol);
+int sst_vtsv_enroll_set(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol);
+int sst_vtsv_enroll_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol);
+#endif
diff --git a/sound/soc/intel/platform-libs/controls_v2_dpcm.c b/sound/soc/intel/platform-libs/controls_v2_dpcm.c
new file mode 100644
index 0000000..8c4c6bd
--- /dev/null
+++ b/sound/soc/intel/platform-libs/controls_v2_dpcm.c
@@ -0,0 +1,1979 @@
+
+/*
+ *  controls_v2_dpcm.c - Intel MID Platform driver DPCM ALSA controls for Mrfld
+ *
+ *  Copyright (C) 2013 Intel Corp
+ *  Author: Omair Mohammed Abdullah <omair.m.abdullah@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/slab.h>
+#include <asm/platform_sst_audio.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+#include "../platform_ipc_v2.h"
+#include "../sst_platform.h"
+#include "../sst_platform_pvt.h"
+#include "controls_v2.h"
+#include "sst_widgets.h"
+
+static inline void sst_fill_byte_control(char *param,
+					 u8 ipc_msg, u8 block,
+					 u8 task_id, u8 pipe_id,
+					 u16 len, void *cmd_data)
+{
+
+	struct snd_sst_bytes_v2 *byte_data = (struct snd_sst_bytes_v2 *)param;
+	byte_data->type = SST_CMD_BYTES_SET;
+	byte_data->ipc_msg = ipc_msg;
+	byte_data->block = block;
+	byte_data->task_id = task_id;
+	byte_data->pipe_id = pipe_id;
+
+	if (len > SST_MAX_BIN_BYTES - sizeof(*byte_data)) {
+		pr_err("%s: command length too big (%u)", __func__, len);
+		len = SST_MAX_BIN_BYTES - sizeof(*byte_data);
+		WARN_ON(1); /* this happens only if code is wrong */
+	}
+	byte_data->len = len;
+	memcpy(byte_data->bytes, cmd_data, len);
+	print_hex_dump_bytes("writing to lpe: ", DUMP_PREFIX_OFFSET,
+			     byte_data, len + sizeof(*byte_data));
+}
+
+static int sst_fill_and_send_cmd_unlocked(struct sst_data *sst,
+				 u8 ipc_msg, u8 block, u8 task_id, u8 pipe_id,
+				 void *cmd_data, u16 len)
+{
+	sst_fill_byte_control(sst->byte_stream, ipc_msg, block, task_id, pipe_id,
+			      len, cmd_data);
+	return sst_dsp->ops->set_generic_params(SST_SET_BYTE_STREAM,
+						sst->byte_stream);
+}
+
+/**
+ * sst_fill_and_send_cmd - generate the IPC message and send it to the FW
+ * @ipc_msg:	type of IPC (CMD, SET_PARAMS, GET_PARAMS)
+ * @cmd_data:	the IPC payload
+ */
+static int sst_fill_and_send_cmd(struct sst_data *sst,
+				 u8 ipc_msg, u8 block, u8 task_id, u8 pipe_id,
+				 void *cmd_data, u16 len)
+{
+	int ret;
+
+	mutex_lock(&sst->lock);
+	ret = sst_fill_and_send_cmd_unlocked(sst, ipc_msg, block, task_id, pipe_id,
+					     cmd_data, len);
+	mutex_unlock(&sst->lock);
+
+	return ret;
+}
+
+static int sst_probe_get(struct snd_kcontrol *kcontrol,
+			 struct snd_ctl_elem_value *ucontrol)
+{
+	struct sst_probe_value *v = (void *)kcontrol->private_value;
+
+	ucontrol->value.enumerated.item[0] = v->val;
+	return 0;
+}
+
+static int sst_probe_put(struct snd_kcontrol *kcontrol,
+			 struct snd_ctl_elem_value *ucontrol)
+{
+	struct sst_probe_value *v = (void *)kcontrol->private_value;
+	const struct soc_enum *e = v->p_enum;
+
+	if (ucontrol->value.enumerated.item[0] > e->items - 1)
+		return -EINVAL;
+	v->val = ucontrol->value.enumerated.item[0];
+	return 0;
+}
+
+int sst_probe_enum_info(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	struct sst_probe_value *v = (void *)kcontrol->private_value;
+	const struct soc_enum *e = v->p_enum;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = e->items;
+
+	if (uinfo->value.enumerated.item > e->items - 1)
+		uinfo->value.enumerated.item = e->items - 1;
+	strcpy(uinfo->value.enumerated.name,
+		e->texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+/*
+ * slot map value is a bitfield where each bit represents a FW channel
+ *
+ *			3 2 1 0		# 0 = codec0, 1 = codec1
+ *			RLRLRLRL	# 3, 4 = reserved
+ *
+ * e.g. slot 0 rx map =	00001100b -> data from slot 0 goes into codec_in1 L,R
+ */
+static u8 sst_ssp_slot_map[SST_MAX_TDM_SLOTS] = {
+	0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, /* default rx map */
+};
+
+/*
+ * channel map value is a bitfield where each bit represents a slot
+ *
+ *			  76543210	# 0 = slot 0, 1 = slot 1
+ *
+ * e.g. codec1_0 tx map = 00000101b -> data from codec_out1_0 goes into slot 0, 2
+ */
+static u8 sst_ssp_channel_map[SST_MAX_TDM_SLOTS] = {
+	0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, /* default tx map */
+};
+
+static void sst_send_slot_map(struct sst_data *sst)
+{
+	struct sst_param_sba_ssp_slot_map cmd;
+
+	pr_debug("Enter: %s\n", __func__);
+
+	SST_FILL_DEFAULT_DESTINATION(cmd.header.dst);
+	cmd.header.command_id = SBA_SET_SSP_SLOT_MAP;
+	cmd.header.length = sizeof(struct sst_param_sba_ssp_slot_map)
+				- sizeof(struct sst_dsp_header);
+
+	cmd.param_id = SBA_SET_SSP_SLOT_MAP;
+	cmd.param_len = sizeof(cmd.rx_slot_map) + sizeof(cmd.tx_slot_map) + sizeof(cmd.ssp_index);
+	cmd.ssp_index = SSP_CODEC;
+
+	memcpy(cmd.rx_slot_map, &sst_ssp_slot_map[0], sizeof(cmd.rx_slot_map));
+	memcpy(cmd.tx_slot_map, &sst_ssp_channel_map[0], sizeof(cmd.tx_slot_map));
+
+	sst_fill_and_send_cmd(sst, SST_IPC_IA_SET_PARAMS, SST_FLAG_BLOCKED,
+			      SST_TASK_SBA, 0, &cmd,
+			      sizeof(cmd.header) + cmd.header.length);
+}
+
+int sst_slot_enum_info(struct snd_kcontrol *kcontrol,
+		       struct snd_ctl_elem_info *uinfo)
+{
+	struct sst_enum *e = (struct sst_enum *)kcontrol->private_value;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = e->max;
+
+	if (uinfo->value.enumerated.item > e->max - 1)
+		uinfo->value.enumerated.item = e->max - 1;
+	strcpy(uinfo->value.enumerated.name,
+		e->texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+/**
+ * sst_slot_get - get the status of the interleaver/deinterleaver control
+ *
+ * Searches the map where the control status is stored, and gets the
+ * channel/slot which is currently set for this enumerated control. Since it is
+ * an enumerated control, there is only one possible value.
+ */
+static int sst_slot_get(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct sst_enum *e = (void *)kcontrol->private_value;
+	unsigned int ctl_no = e->reg;
+	unsigned int is_tx = e->tx;
+	unsigned int val, mux;
+	u8 *map = is_tx ? sst_ssp_channel_map : sst_ssp_slot_map;
+
+	val = 1 << ctl_no;
+	/* search which slot/channel has this bit set - there should be only one */
+	for (mux = e->max; mux > 0;  mux--)
+		if (map[mux - 1] & val)
+			break;
+
+	ucontrol->value.enumerated.item[0] = mux;
+	pr_debug("%s: %s - %s map = %#x\n", __func__, is_tx ? "tx channel" : "rx slot",
+		 e->texts[mux], mux ? map[mux - 1] : -1);
+	return 0;
+}
+
+/**
+ * sst_slot_put - set the status of interleaver/deinterleaver control
+ *
+ * (de)interleaver controls are defined in opposite sense to be user-friendly
+ *
+ * Instead of the enum value being the value written to the register, it is the
+ * register address; and the kcontrol number (register num) is the value written
+ * to the register. This is so that there can be only one value for each
+ * slot/channel since there is only one control for each slot/channel.
+ *
+ * This means that whenever an enum is set, we need to clear the bit
+ * for that kcontrol_no for all the interleaver OR deinterleaver registers
+ */
+static int sst_slot_put(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	struct sst_enum *e = (void *)kcontrol->private_value;
+	int i;
+	unsigned int ctl_no = e->reg;
+	unsigned int is_tx = e->tx;
+	unsigned int slot_channel_no;
+	unsigned int val, mux;
+
+	u8 *map = is_tx ? sst_ssp_channel_map : sst_ssp_slot_map;
+
+	val = 1 << ctl_no;
+	mux = ucontrol->value.enumerated.item[0];
+	if (mux > e->max - 1)
+		return -EINVAL;
+
+	/* first clear all registers of this bit */
+	for (i = 0; i < e->max; i++)
+		map[i] &= ~val;
+
+	if (mux == 0) /* kctl set to 'none' */
+		return 0;
+
+	/* offset by one to take "None" into account */
+	slot_channel_no = mux - 1;
+	map[slot_channel_no] |= val;
+
+	pr_debug("%s: %s %s map = %#x\n", __func__, is_tx ? "tx channel" : "rx slot",
+		 e->texts[mux], map[slot_channel_no]);
+
+	if (e->w && e->w->power)
+		sst_send_slot_map(sst);
+	return 0;
+}
+
+/* assumes a boolean mux */
+static inline bool get_mux_state(struct sst_data *sst, unsigned int reg, unsigned int shift)
+{
+	return sst_reg_read(sst, reg, shift, 1) == 1;
+}
+
+static int sst_mux_get(struct snd_kcontrol *kcontrol,
+		       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_widget_list *wlist = dapm_kcontrol_get_wlist(kcontrol);
+	struct snd_soc_dapm_widget *widget = wlist->widgets[0];
+	struct sst_data *sst = snd_soc_platform_get_drvdata(widget->platform);
+	struct soc_enum *e = (void *)kcontrol->private_value;
+	unsigned int max = e->items - 1;
+
+	ucontrol->value.enumerated.item[0] = sst_reg_read(sst, e->reg, e->shift_l, max);
+	return 0;
+}
+
+static int sst_mux_put(struct snd_kcontrol *kcontrol,
+		       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_widget_list *wlist = dapm_kcontrol_get_wlist(kcontrol);
+	struct snd_soc_dapm_widget *widget = wlist->widgets[0];
+	struct sst_data *sst = snd_soc_platform_get_drvdata(widget->platform);
+	struct soc_enum *e = (void *)kcontrol->private_value;
+	struct snd_soc_dapm_update update;
+	unsigned int max = e->items - 1;
+	unsigned int mask = (1 << fls(max)) - 1;
+	unsigned int mux, val;
+
+	if (ucontrol->value.enumerated.item[0] > e->items - 1)
+		return -EINVAL;
+
+	mux = ucontrol->value.enumerated.item[0];
+	val = sst_reg_write(sst, e->reg, e->shift_l, max, mux);
+
+	pr_debug("%s: reg[%d] = %#x\n", __func__, e->reg, val);
+
+	dapm_kcontrol_set_value(kcontrol, val);
+	update.kcontrol = kcontrol;
+	update.reg = e->reg;
+	update.mask = mask;
+	update.val = val;
+
+	snd_soc_dapm_mux_update_power(widget->dapm, kcontrol, mux, e, &update);
+	return 0;
+}
+
+static int sst_mode_get(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	struct soc_enum *e = (void *)kcontrol->private_value;
+	unsigned int max = e->items - 1;
+
+	ucontrol->value.enumerated.item[0] = sst_reg_read(sst, e->reg, e->shift_l, max);
+	return 0;
+}
+
+static int sst_mode_put(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	struct soc_enum *e = (void *)kcontrol->private_value;
+	unsigned int max = e->items - 1;
+	unsigned int val;
+
+	if (ucontrol->value.enumerated.item[0] > e->items - 1)
+		return -EINVAL;
+
+	val = sst_reg_write(sst, e->reg, e->shift_l, max, ucontrol->value.enumerated.item[0]);
+	pr_debug("%s: reg[%d] - %#x\n", __func__, e->reg, val);
+	return 0;
+}
+
+static void sst_send_algo_cmd(struct sst_data *sst,
+			      struct sst_algo_control *bc)
+{
+	int len;
+	struct sst_cmd_set_params *cmd;
+
+	if (bc->params == NULL)
+		return;
+
+	/* bc->max includes sizeof algos + length field */
+	len = sizeof(cmd->dst) + sizeof(cmd->command_id) + bc->max;
+
+	cmd = kzalloc(len, GFP_KERNEL);
+	if (cmd == NULL) {
+		pr_err("Failed to send cmd, kzalloc failed\n");
+		return;
+	}
+
+	SST_FILL_DESTINATION(2, cmd->dst, bc->pipe_id, bc->module_id);
+	cmd->command_id = bc->cmd_id;
+	memcpy(cmd->params, bc->params, bc->max);
+
+	sst_fill_and_send_cmd(sst, SST_IPC_IA_SET_PARAMS, SST_FLAG_BLOCKED,
+			      bc->task_id, 0, cmd, len);
+	kfree(cmd);
+}
+
+/**
+ * sst_find_and_send_pipe_algo - send all the algo parameters for a pipe
+ *
+ * The algos which are in each pipeline are sent to the firmware one by one
+ */
+static void sst_find_and_send_pipe_algo(struct sst_data *sst,
+					const char *pipe, struct sst_ids *ids)
+{
+	struct sst_algo_control *bc;
+	struct module *algo = NULL;
+
+	pr_debug("Enter: %s, widget=%s\n", __func__, pipe);
+
+	list_for_each_entry(algo, &ids->algo_list, node) {
+		bc = (void *)algo->kctl->private_value;
+
+		pr_debug("Found algo control name=%s pipe=%s\n", algo->kctl->id.name, pipe);
+		sst_send_algo_cmd(sst, bc);
+	}
+}
+
+int sst_algo_bytes_ctl_info(struct snd_kcontrol *kcontrol,
+			    struct snd_ctl_elem_info *uinfo)
+{
+	struct sst_algo_control *bc = (void *)kcontrol->private_value;
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
+	uinfo->count = bc->max;
+
+	/* allocate space to cache the algo parameters in the driver */
+	if (bc->params == NULL) {
+		bc->params = devm_kzalloc(platform->dev, bc->max, GFP_KERNEL);
+		if (bc->params == NULL) {
+			pr_err("kzalloc failed\n");
+			return -ENOMEM;
+		}
+	}
+	return 0;
+}
+
+static int sst_algo_control_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct sst_algo_control *bc = (void *)kcontrol->private_value;
+
+	switch (bc->type) {
+	case SST_ALGO_PARAMS:
+		if (bc->params)
+			memcpy(ucontrol->value.bytes.data, bc->params, bc->max);
+		break;
+	case SST_ALGO_BYPASS:
+		ucontrol->value.integer.value[0] = bc->bypass ? 1 : 0;
+		pr_debug("%s: bypass  %d\n", __func__, bc->bypass);
+		break;
+	default:
+		pr_err("Invalid Input- algo type:%d\n", bc->type);
+		return -EINVAL;
+
+	}
+	return 0;
+}
+
+static int sst_algo_control_set(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	struct sst_algo_control *bc = (void *)kcontrol->private_value;
+
+	pr_debug("in %s control_name=%s\n", __func__, kcontrol->id.name);
+	switch (bc->type) {
+	case SST_ALGO_PARAMS:
+		if (bc->params)
+			memcpy(bc->params, ucontrol->value.bytes.data, bc->max);
+		break;
+	case SST_ALGO_BYPASS:
+		bc->bypass = !!ucontrol->value.integer.value[0];
+		break;
+	default:
+		pr_err("Invalid Input- algo type:%ld\n", ucontrol->value.integer.value[0]);
+		return -EINVAL;
+	}
+	/*if pipe is enabled, need to send the algo params from here */
+	if (bc->w && bc->w->power)
+		sst_send_algo_cmd(sst, bc);
+
+	return 0;
+}
+
+static int sst_gain_ctl_info(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	struct sst_gain_mixer_control *mc = (void *)kcontrol->private_value;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = mc->stereo ? 2 : 1;
+	uinfo->value.integer.min = mc->min;
+	uinfo->value.integer.max = mc->max;
+	return 0;
+}
+
+/**
+ * sst_send_gain_cmd - send the gain algorithm IPC to the FW
+ * @gv:		the stored value of gain (also contains rampduration)
+ * @mute:	flag that indicates whether this was called from the
+ *		digital_mute callback or directly. If called from the
+ *		digital_mute callback, module will be muted/unmuted based on this
+ *		flag. The flag is always 0 if called directly.
+ *
+ * The user-set gain value is sent only if the user-controllable 'mute' control
+ * is OFF (indicated by gv->mute). Otherwise, the mute value (MIN value) is
+ * sent.
+ */
+static void sst_send_gain_cmd(struct sst_data *sst, struct sst_gain_value *gv,
+			      u16 task_id, u16 loc_id, u16 module_id, int mute)
+{
+	struct sst_cmd_set_gain_dual cmd;
+	pr_debug("%s\n", __func__);
+
+	cmd.header.command_id = MMX_SET_GAIN;
+	SST_FILL_DEFAULT_DESTINATION(cmd.header.dst);
+	cmd.gain_cell_num = 1;
+
+	if (mute || gv->mute) {
+		cmd.cell_gains[0].cell_gain_left = SST_GAIN_MIN_VALUE;
+		cmd.cell_gains[0].cell_gain_right = SST_GAIN_MIN_VALUE;
+	} else {
+		cmd.cell_gains[0].cell_gain_left = gv->l_gain;
+		cmd.cell_gains[0].cell_gain_right = gv->r_gain;
+	}
+	SST_FILL_DESTINATION(2, cmd.cell_gains[0].dest,
+			     loc_id, module_id);
+	cmd.cell_gains[0].gain_time_constant = gv->ramp_duration;
+
+	cmd.header.length = sizeof(struct sst_cmd_set_gain_dual)
+				- sizeof(struct sst_dsp_header);
+
+	sst_fill_and_send_cmd(sst, SST_IPC_IA_SET_PARAMS, SST_FLAG_BLOCKED,
+			      task_id, 0, &cmd,
+			      sizeof(cmd.header) + cmd.header.length);
+}
+
+static int sst_gain_get(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct sst_gain_mixer_control *mc = (void *)kcontrol->private_value;
+	struct sst_gain_value *gv = mc->gain_val;
+
+	switch (mc->type) {
+	case SST_GAIN_TLV:
+		ucontrol->value.integer.value[0] = gv->l_gain;
+		ucontrol->value.integer.value[1] = gv->r_gain;
+		break;
+	case SST_GAIN_MUTE:
+		ucontrol->value.integer.value[0] = gv->mute ? 1 : 0;
+		break;
+	case SST_GAIN_RAMP_DURATION:
+		ucontrol->value.integer.value[0] = gv->ramp_duration;
+		break;
+	default:
+		pr_err("Invalid Input- gain type:%d\n", mc->type);
+		return -EINVAL;
+	};
+	return 0;
+}
+
+static int sst_gain_put(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	struct sst_gain_mixer_control *mc = (void *)kcontrol->private_value;
+	struct sst_gain_value *gv = mc->gain_val;
+
+	switch (mc->type) {
+	case SST_GAIN_TLV:
+		gv->l_gain = ucontrol->value.integer.value[0];
+		gv->r_gain = ucontrol->value.integer.value[1];
+		pr_debug("%s: %s: Volume %d, %d\n", __func__, mc->pname, gv->l_gain, gv->r_gain);
+		break;
+	case SST_GAIN_MUTE:
+		gv->mute = !!ucontrol->value.integer.value[0];
+		pr_debug("%s: %s: Mute %d\n", __func__, mc->pname, gv->mute);
+		break;
+	case SST_GAIN_RAMP_DURATION:
+		gv->ramp_duration = ucontrol->value.integer.value[0];
+		pr_debug("%s: %s: RampDuration %d\n", __func__, mc->pname, gv->ramp_duration);
+		break;
+	default:
+		pr_err("Invalid Input- gain type:%d\n", mc->type);
+		return -EINVAL;
+	};
+
+	if (mc->w && mc->w->power)
+		sst_send_gain_cmd(sst, gv, mc->task_id,
+				mc->pipe_id | mc->instance_id, mc->module_id, 0);
+	return 0;
+}
+
+static void sst_set_pipe_gain(struct sst_ids *ids, struct sst_data *sst, int mute);
+
+static void sst_send_pipe_module_params(struct snd_soc_dapm_widget *w)
+{
+	struct sst_data *sst = snd_soc_platform_get_drvdata(w->platform);
+	struct sst_ids *ids = w->priv;
+
+	sst_find_and_send_pipe_algo(sst, w->name, ids);
+	sst_set_pipe_gain(ids, sst, 0);
+}
+
+static int sst_generic_modules_event(struct snd_soc_dapm_widget *w,
+				     struct snd_kcontrol *k, int event)
+{
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		sst_send_pipe_module_params(w);
+	return 0;
+}
+
+static const DECLARE_TLV_DB_SCALE(sst_gain_tlv_common, SST_GAIN_MIN_VALUE * 10, 10, 0);
+
+/* Look up table to convert MIXER SW bit regs to SWM inputs */
+static const uint swm_mixer_input_ids[SST_SWM_INPUT_COUNT] = {
+	[SST_IP_MODEM]		= SST_SWM_IN_MODEM,
+	[SST_IP_BT]		= SST_SWM_IN_BT,
+	[SST_IP_CODEC0]		= SST_SWM_IN_CODEC0,
+	[SST_IP_CODEC1]		= SST_SWM_IN_CODEC1,
+	[SST_IP_LOOP0]		= SST_SWM_IN_SPROT_LOOP,
+	[SST_IP_LOOP1]		= SST_SWM_IN_MEDIA_LOOP1,
+	[SST_IP_LOOP2]		= SST_SWM_IN_MEDIA_LOOP2,
+	[SST_IP_SIDETONE]	= SST_SWM_IN_SIDETONE,
+	[SST_IP_TXSPEECH]	= SST_SWM_IN_TXSPEECH,
+	[SST_IP_SPEECH]		= SST_SWM_IN_SPEECH,
+	[SST_IP_TONE]		= SST_SWM_IN_TONE,
+	[SST_IP_VOIP]		= SST_SWM_IN_VOIP,
+	[SST_IP_PCM0]		= SST_SWM_IN_PCM0,
+	[SST_IP_PCM1]		= SST_SWM_IN_PCM1,
+	[SST_IP_LOW_PCM0]	= SST_SWM_IN_LOW_PCM0,
+	[SST_IP_FM]		= SST_SWM_IN_FM,
+	[SST_IP_MEDIA0]		= SST_SWM_IN_MEDIA0,
+	[SST_IP_MEDIA1]		= SST_SWM_IN_MEDIA1,
+	[SST_IP_MEDIA2]		= SST_SWM_IN_MEDIA2,
+	[SST_IP_MEDIA3]		= SST_SWM_IN_MEDIA3,
+};
+
+/**
+ * fill_swm_input - fill in the SWM input ids given the register
+ *
+ * The register value is a bit-field inicated which mixer inputs are ON. Use the
+ * lookup table to get the input-id and fill it in the structure.
+ */
+static int fill_swm_input(struct swm_input_ids *swm_input, unsigned int reg)
+{
+	uint i, is_set, nb_inputs = 0;
+	u16 input_loc_id;
+
+	pr_debug("%s: reg: %#x\n", __func__, reg);
+	for (i = 0; i < SST_SWM_INPUT_COUNT; i++) {
+		is_set = reg & BIT(i);
+		if (!is_set)
+			continue;
+
+		input_loc_id = swm_mixer_input_ids[i];
+		SST_FILL_DESTINATION(2, swm_input->input_id,
+				     input_loc_id, SST_DEFAULT_MODULE_ID);
+		nb_inputs++;
+		swm_input++;
+		pr_debug("input id: %#x, nb_inputs: %d\n", input_loc_id, nb_inputs);
+
+		if (nb_inputs == SST_CMD_SWM_MAX_INPUTS) {
+			pr_warn("%s: SET_SWM cmd max inputs reached", __func__);
+			break;
+		}
+	}
+	return nb_inputs;
+}
+
+static void sst_set_pipe_gain(struct sst_ids *ids, struct sst_data *sst, int mute)
+{
+	struct sst_gain_mixer_control *mc;
+	struct sst_gain_value *gv;
+	struct module *gain = NULL;
+
+	list_for_each_entry(gain, &ids->gain_list, node) {
+		struct snd_kcontrol *kctl = gain->kctl;
+
+		pr_debug("control name=%s\n", kctl->id.name);
+		mc = (void *)kctl->private_value;
+		gv = mc->gain_val;
+
+		sst_send_gain_cmd(sst, gv, mc->task_id,
+				mc->pipe_id | mc->instance_id, mc->module_id, mute);
+	}
+}
+
+static int sst_swm_mixer_event(struct snd_soc_dapm_widget *w,
+			struct snd_kcontrol *k, int event)
+{
+	struct sst_cmd_set_swm cmd;
+	struct sst_data *sst = snd_soc_platform_get_drvdata(w->platform);
+	struct sst_ids *ids = w->priv;
+	bool set_mixer = false;
+	int val = sst->widget[ids->reg];
+
+	pr_debug("%s: widget = %s\n", __func__, w->name);
+	pr_debug("%s: reg[%d] = %#x\n", __func__, ids->reg, val);
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+	case SND_SOC_DAPM_POST_PMD:
+		set_mixer = true;
+		break;
+	case SND_SOC_DAPM_POST_REG:
+		if (w->power)
+			set_mixer = true;
+		break;
+	default:
+		set_mixer = false;
+	}
+
+	if (set_mixer == false)
+		return 0;
+
+	if (SND_SOC_DAPM_EVENT_ON(event) ||
+	    event == SND_SOC_DAPM_POST_REG)
+		cmd.switch_state = SST_SWM_ON;
+	else
+		cmd.switch_state = SST_SWM_OFF;
+
+	SST_FILL_DEFAULT_DESTINATION(cmd.header.dst);
+	/* MMX_SET_SWM == SBA_SET_SWM */
+	cmd.header.command_id = SBA_SET_SWM;
+
+	SST_FILL_DESTINATION(2, cmd.output_id,
+			     ids->location_id, SST_DEFAULT_MODULE_ID);
+	cmd.nb_inputs =	fill_swm_input(&cmd.input[0], val);
+	cmd.header.length = offsetof(struct sst_cmd_set_swm, input) - sizeof(struct sst_dsp_header)
+				+ (cmd.nb_inputs * sizeof(cmd.input[0]));
+
+	sst_fill_and_send_cmd(sst, SST_IPC_IA_CMD, SST_FLAG_BLOCKED,
+			      ids->task_id, 0, &cmd,
+			      sizeof(cmd.header) + cmd.header.length);
+	return 0;
+}
+
+/* SBA mixers - 16 inputs */
+#define SST_SBA_DECLARE_MIX_CONTROLS(kctl_name, mixer_reg)			\
+	static const struct snd_kcontrol_new kctl_name[] = {			\
+		SOC_SINGLE_EXT("modem_in", mixer_reg, SST_IP_MODEM, 1, 0,	\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("bt_in", mixer_reg, SST_IP_BT, 1, 0,		\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("codec_in0", mixer_reg, SST_IP_CODEC0, 1, 0,	\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("codec_in1", mixer_reg, SST_IP_CODEC1, 1, 0,	\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("sprot_loop_in", mixer_reg, SST_IP_LOOP0, 1, 0,	\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("media_loop1_in", mixer_reg, SST_IP_LOOP1, 1, 0,	\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("media_loop2_in", mixer_reg, SST_IP_LOOP2, 1, 0,	\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("sidetone_in", mixer_reg, SST_IP_SIDETONE, 1, 0,	\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("txspeech_in", mixer_reg, SST_IP_TXSPEECH, 1, 0,	\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("speech_in", mixer_reg, SST_IP_SPEECH, 1, 0,	\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("tone_in", mixer_reg, SST_IP_TONE, 1, 0,		\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("voip_in", mixer_reg, SST_IP_VOIP, 1, 0,		\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("pcm0_in", mixer_reg, SST_IP_PCM0, 1, 0,		\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("pcm1_in", mixer_reg, SST_IP_PCM1, 1, 0,		\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("low_pcm0_in", mixer_reg, SST_IP_LOW_PCM0, 1, 0,	\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("fm_in", mixer_reg, SST_IP_FM, 1, 0,		\
+				sst_mix_get, sst_mix_put),			\
+	}
+
+#define SST_SBA_MIXER_GRAPH_MAP(mix_name)			\
+	{ mix_name, "modem_in",		"modem_in" },		\
+	{ mix_name, "bt_in",		"bt_in" },		\
+	{ mix_name, "codec_in0",	"codec_in0" },		\
+	{ mix_name, "codec_in1",	"codec_in1" },		\
+	{ mix_name, "sprot_loop_in",	"sprot_loop_in" },	\
+	{ mix_name, "media_loop1_in",	"media_loop1_in" },	\
+	{ mix_name, "media_loop2_in",	"media_loop2_in" },	\
+	{ mix_name, "sidetone_in",	"sidetone_in" },	\
+	{ mix_name, "txspeech_in",	"txspeech_in" },	\
+	{ mix_name, "speech_in",	"speech_in" },		\
+	{ mix_name, "tone_in",		"tone_in" },		\
+	{ mix_name, "voip_in",		"voip_in" },		\
+	{ mix_name, "pcm0_in",		"pcm0_in" },		\
+	{ mix_name, "pcm1_in",		"pcm1_in" },		\
+	{ mix_name, "low_pcm0_in",	"low_pcm0_in" },	\
+	{ mix_name, "fm_in",		"fm_in" }
+
+#define SST_MMX_DECLARE_MIX_CONTROLS(kctl_name, mixer_reg)			\
+	static const struct snd_kcontrol_new kctl_name[] = {			\
+		SOC_SINGLE_EXT("media0_in", mixer_reg, SST_IP_MEDIA0, 1, 0,	\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("media1_in", mixer_reg, SST_IP_MEDIA1, 1, 0,	\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("media2_in", mixer_reg, SST_IP_MEDIA2, 1, 0,	\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("media3_in", mixer_reg, SST_IP_MEDIA3, 1, 0,	\
+				sst_mix_get, sst_mix_put),			\
+	}
+
+SST_MMX_DECLARE_MIX_CONTROLS(sst_mix_media0_controls, SST_MIX_MEDIA0);
+SST_MMX_DECLARE_MIX_CONTROLS(sst_mix_media1_controls, SST_MIX_MEDIA1);
+
+/* 18 SBA mixers */
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_pcm0_controls, SST_MIX_PCM0);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_pcm1_controls, SST_MIX_PCM1);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_pcm2_controls, SST_MIX_PCM2);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_sprot_l0_controls, SST_MIX_LOOP0);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_media_l1_controls, SST_MIX_LOOP1);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_media_l2_controls, SST_MIX_LOOP2);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_voip_controls, SST_MIX_VOIP);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_aware_controls, SST_MIX_AWARE);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_vad_controls, SST_MIX_VAD);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_hf_sns_controls, SST_MIX_HF_SNS);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_hf_controls, SST_MIX_HF);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_speech_controls, SST_MIX_SPEECH);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_rxspeech_controls, SST_MIX_RXSPEECH);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_codec0_controls, SST_MIX_CODEC0);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_codec1_controls, SST_MIX_CODEC1);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_bt_controls, SST_MIX_BT);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_fm_controls, SST_MIX_FM);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_modem_controls, SST_MIX_MODEM);
+
+void sst_handle_vb_timer(struct snd_soc_platform *p, bool enable)
+{
+	struct sst_cmd_generic cmd;
+	struct sst_data *sst = snd_soc_platform_get_drvdata(p);
+	static int timer_usage;
+
+	if (enable)
+		cmd.header.command_id = SBA_VB_START;
+	else
+		cmd.header.command_id = SBA_IDLE;
+	pr_debug("%s: enable=%u, usage=%d\n", __func__, enable, timer_usage);
+
+	SST_FILL_DEFAULT_DESTINATION(cmd.header.dst);
+	cmd.header.length = 0;
+
+	if (enable)
+		sst_dsp->ops->power(true);
+
+	mutex_lock(&sst->lock);
+	if (enable)
+		timer_usage++;
+	else
+		timer_usage--;
+
+	/* Send the command only if this call is the first enable or last
+	 * disable
+	 */
+	if ((enable && (timer_usage == 1)) ||
+	    (!enable && (timer_usage == 0)))
+		sst_fill_and_send_cmd_unlocked(sst, SST_IPC_IA_CMD, SST_FLAG_BLOCKED,
+				      SST_TASK_SBA, 0, &cmd,
+				      sizeof(cmd.header) + cmd.header.length);
+	mutex_unlock(&sst->lock);
+
+	if (!enable)
+		sst_dsp->ops->power(false);
+}
+
+void send_ssp_cmd(struct snd_soc_platform *platform, const char *id, bool enable)
+{
+	struct sst_cmd_sba_hw_set_ssp cmd;
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	unsigned int domain, mux;
+	int domain_shift, mux_shift, ssp_no;
+	const struct sst_ssp_config *config;
+
+	pr_err("Enter:%s, enable=%d port_name=%s\n", __func__, enable, id);
+
+	if (strcmp(id, "ssp0-port") == 0)
+		ssp_no = SST_SSP0;
+	else if (strcmp(id, "ssp1-port") == 0)
+		ssp_no = SST_SSP1;
+	else if (strcmp(id, "ssp2-port") == 0)
+		ssp_no = SST_SSP2;
+	else
+		return;
+
+	SST_FILL_DEFAULT_DESTINATION(cmd.header.dst);
+	cmd.header.command_id = SBA_HW_SET_SSP;
+	cmd.header.length = sizeof(struct sst_cmd_sba_hw_set_ssp)
+				- sizeof(struct sst_dsp_header);
+	mux_shift = sst->pdata->mux_shift[ssp_no];
+	mux = (mux_shift == -1) ? 0 : get_mux_state(sst, SST_MUX_REG, mux_shift);
+	domain_shift = sst->pdata->domain_shift[ssp_no][mux];
+	domain = (domain_shift == -1) ? 0 : get_mux_state(sst, SST_MUX_REG, domain_shift);
+
+	config = &(sst->pdata->ssp_config)[ssp_no][mux][domain];
+	pr_debug("%s: ssp_id: %u, mux: %d, domain: %d\n", __func__,
+		 config->ssp_id, mux, domain);
+
+	if (enable)
+		cmd.switch_state = SST_SWITCH_ON;
+	else
+		cmd.switch_state = SST_SWITCH_OFF;
+
+	cmd.selection = config->ssp_id;
+	cmd.nb_bits_per_slots = config->bits_per_slot;
+	cmd.nb_slots = config->slots;
+	cmd.mode = config->ssp_mode | (config->pcm_mode << 1);
+	cmd.duplex = config->duplex;
+	cmd.active_tx_slot_map = config->active_slot_map;
+	cmd.active_rx_slot_map = config->active_slot_map;
+	cmd.frame_sync_frequency = config->fs_frequency;
+	cmd.frame_sync_polarity = SSP_FS_ACTIVE_HIGH;
+	cmd.data_polarity = config->data_polarity;
+	cmd.frame_sync_width = config->fs_width;
+	cmd.ssp_protocol = config->ssp_protocol;
+	cmd.start_delay = config->start_delay;
+	cmd.reserved1 = cmd.reserved2 = 0xFF;
+
+	sst_fill_and_send_cmd(sst, SST_IPC_IA_CMD, SST_FLAG_BLOCKED,
+				SST_TASK_SBA, 0, &cmd,
+				sizeof(cmd.header) + cmd.header.length);
+}
+
+static int sst_set_be_modules(struct snd_soc_dapm_widget *w,
+			 struct snd_kcontrol *k, int event)
+{
+	struct sst_data *sst = snd_soc_platform_get_drvdata(w->platform);
+
+	pr_debug("Enter: %s, widget=%s\n", __func__, w->name);
+
+	if (SND_SOC_DAPM_EVENT_ON(event)) {
+		sst_send_slot_map(sst);
+		sst_send_pipe_module_params(w);
+	}
+	return 0;
+}
+
+/**
+ * sst_set_speech_path - send SPEECH_UL/DL enable/disable IPC
+ *
+ * The SPEECH_PATH IPC enables more than one pipeline (speech uplink, downlink,
+ * sidetone etc.). Since the command should be sent only once, use a refcount to
+ * send the command only on first enable/last disable.
+ */
+static int sst_set_speech_path(struct snd_soc_dapm_widget *w,
+			       struct snd_kcontrol *k, int event)
+{
+	struct sst_cmd_set_speech_path cmd;
+	struct sst_data *sst = snd_soc_platform_get_drvdata(w->platform);
+	bool is_wideband;
+	static int speech_active;
+
+	pr_debug("%s: widget=%s\n", __func__, w->name);
+
+	if (SND_SOC_DAPM_EVENT_ON(event)) {
+		speech_active++;
+		cmd.switch_state = SST_SWITCH_ON;
+	} else {
+		speech_active--;
+		cmd.switch_state = SST_SWITCH_OFF;
+	}
+
+	SST_FILL_DEFAULT_DESTINATION(cmd.header.dst);
+
+	cmd.header.command_id = SBA_VB_SET_SPEECH_PATH;
+	cmd.header.length = sizeof(struct sst_cmd_set_speech_path)
+				- sizeof(struct sst_dsp_header);
+	cmd.config.cfg.s_length = 0;
+	cmd.config.cfg.rate = 0;		/* 8 khz */
+	cmd.config.cfg.format = 0;
+
+	is_wideband = get_mux_state(sst, SST_MUX_REG, SST_VOICE_MODE_SHIFT);
+	if (is_wideband)
+		cmd.config.cfg.rate = 1;	/* 16 khz */
+
+	if ((SND_SOC_DAPM_EVENT_ON(event) && (speech_active == 1)) ||
+	    (SND_SOC_DAPM_EVENT_OFF(event) && (speech_active == 0)))
+		sst_fill_and_send_cmd(sst, SST_IPC_IA_CMD, SST_FLAG_BLOCKED,
+				SST_TASK_SBA, 0, &cmd,
+				sizeof(cmd.header) + cmd.header.length);
+
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		sst_send_pipe_module_params(w);
+	return 0;
+}
+
+/**
+ * sst_set_linked_pipe - send gain/algo for a linked input/output
+ *
+ * A linked pipe is dependent on the power status of its parent widget since it
+ * itself does not have any enabling command.
+ */
+static int sst_set_linked_pipe(struct snd_soc_dapm_widget *w,
+		       struct snd_kcontrol *k, int event)
+{
+	struct sst_data *sst = snd_soc_platform_get_drvdata(w->platform);
+	struct sst_ids *ids = w->priv;
+	pr_debug("%s: widget=%s\n", __func__, w->name);
+	if (SND_SOC_DAPM_EVENT_ON(event)) {
+		if (ids->parent_w && ids->parent_w->power)
+			sst_find_and_send_pipe_algo(sst, w->name, ids);
+			sst_set_pipe_gain(ids, sst, 0);
+	}
+	return 0;
+}
+
+static int sst_set_media_path(struct snd_soc_dapm_widget *w,
+			      struct snd_kcontrol *k, int event)
+{
+	struct sst_cmd_set_media_path cmd;
+	struct sst_data *sst = snd_soc_platform_get_drvdata(w->platform);
+	struct sst_ids *ids = w->priv;
+
+	pr_debug("%s: widget=%s\n", __func__, w->name);
+	pr_debug("%s: task=%u, location=%#x\n", __func__,
+				ids->task_id, ids->location_id);
+
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		cmd.switch_state = SST_PATH_ON;
+	else
+		cmd.switch_state = SST_PATH_OFF;
+
+	SST_FILL_DESTINATION(2, cmd.header.dst,
+			     ids->location_id, SST_DEFAULT_MODULE_ID);
+
+	/* MMX_SET_MEDIA_PATH == SBA_SET_MEDIA_PATH */
+	cmd.header.command_id = MMX_SET_MEDIA_PATH;
+	cmd.header.length = sizeof(struct sst_cmd_set_media_path)
+				- sizeof(struct sst_dsp_header);
+
+	sst_fill_and_send_cmd(sst, SST_IPC_IA_CMD, SST_FLAG_BLOCKED,
+			      ids->task_id, 0, &cmd,
+			      sizeof(cmd.header) + cmd.header.length);
+
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		sst_send_pipe_module_params(w);
+	return 0;
+}
+
+static int sst_set_media_loop(struct snd_soc_dapm_widget *w,
+			struct snd_kcontrol *k, int event)
+{
+	struct sst_cmd_sba_set_media_loop_map cmd;
+	struct sst_data *sst = snd_soc_platform_get_drvdata(w->platform);
+	struct sst_ids *ids = w->priv;
+
+	pr_debug("Enter:%s, widget=%s\n", __func__, w->name);
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		cmd.switch_state = SST_SWITCH_ON;
+	else
+		cmd.switch_state = SST_SWITCH_OFF;
+
+	SST_FILL_DESTINATION(2, cmd.header.dst,
+			     ids->location_id, SST_DEFAULT_MODULE_ID);
+
+	cmd.header.command_id = SBA_SET_MEDIA_LOOP_MAP;
+	cmd.header.length = sizeof(struct sst_cmd_sba_set_media_loop_map)
+				 - sizeof(struct sst_dsp_header);
+	cmd.param.part.cfg.rate = 2; /* 48khz */
+
+	cmd.param.part.cfg.format = ids->format; /* stereo/Mono */
+	cmd.param.part.cfg.s_length = 1; /* 24bit left justified*/
+	cmd.map = 0; /* Algo sequence: Gain - DRP - FIR - IIR  */
+
+	sst_fill_and_send_cmd(sst, SST_IPC_IA_CMD, SST_FLAG_BLOCKED,
+			      SST_TASK_SBA, 0, &cmd,
+			      sizeof(cmd.header) + cmd.header.length);
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		sst_send_pipe_module_params(w);
+	return 0;
+}
+
+static int sst_tone_generator_event(struct snd_soc_dapm_widget *w,
+				    struct snd_kcontrol *k, int event)
+{
+	struct sst_cmd_tone_stop cmd;
+	struct sst_data *sst = snd_soc_platform_get_drvdata(w->platform);
+	struct sst_ids *ids = w->priv;
+
+	pr_debug("Enter:%s, widget=%s\n", __func__, w->name);
+	/* in case of tone generator, the params are combined with the ON cmd */
+	if (SND_SOC_DAPM_EVENT_ON(event)) {
+		int len;
+		struct module *algo;
+		struct sst_algo_control *bc;
+		struct sst_cmd_set_params *cmd;
+
+		algo = list_first_entry(&ids->algo_list, struct module, node);
+		if (algo == NULL)
+			return -EINVAL;
+		bc = (void *)algo->kctl->private_value;
+		len = sizeof(cmd->dst) + sizeof(cmd->command_id) + bc->max;
+
+		cmd = kzalloc(len, GFP_KERNEL);
+		if (cmd == NULL) {
+			pr_err("Failed to send cmd, kzalloc failed\n");
+			return -ENOMEM;
+		}
+
+		SST_FILL_DESTINATION(2, cmd->dst, bc->pipe_id, bc->module_id);
+		cmd->command_id = bc->cmd_id;
+		memcpy(cmd->params, bc->params, bc->max);
+
+		sst_fill_and_send_cmd(sst, SST_IPC_IA_CMD, SST_FLAG_BLOCKED,
+				      bc->task_id, 0, cmd, len);
+		kfree(cmd);
+		sst_set_pipe_gain(ids, sst, 0);
+	} else {
+		SST_FILL_DESTINATION(2, cmd.header.dst,
+				     SST_PATH_INDEX_RESERVED, SST_MODULE_ID_TONE_GEN);
+
+		cmd.header.command_id = SBA_VB_STOP_TONE;
+		cmd.header.length = sizeof(struct sst_cmd_tone_stop)
+					 - sizeof(struct sst_dsp_header);
+		cmd.switch_state = SST_SWITCH_OFF;
+		sst_fill_and_send_cmd(sst, SST_IPC_IA_CMD, SST_FLAG_BLOCKED,
+				      SST_TASK_SBA, 0, &cmd,
+				      sizeof(cmd.header) + cmd.header.length);
+	}
+	return 0;
+}
+
+static int sst_send_probe_cmd(struct sst_data *sst, u16 probe_pipe_id,
+			      int mode, int switch_state,
+			      const struct sst_probe_config *probe_cfg)
+{
+	struct sst_cmd_probe cmd;
+
+	memset(&cmd, 0, sizeof(cmd));
+
+	SST_FILL_DESTINATION(3, cmd.header.dst, SST_DEFAULT_CELL_NBR,
+			     probe_pipe_id, SST_DEFAULT_MODULE_ID);
+	cmd.header.command_id = SBA_PROBE;
+	cmd.header.length = sizeof(struct sst_cmd_probe)
+				 - sizeof(struct sst_dsp_header);
+	cmd.switch_state = switch_state;
+
+	SST_FILL_DESTINATION(2, cmd.probe_dst,
+			     probe_cfg->loc_id, probe_cfg->mod_id);
+
+	cmd.shared_mem = 1;
+	cmd.probe_in = 0;
+	cmd.probe_out = 0;
+
+	cmd.probe_mode = mode;
+	cmd.cfg.s_length = probe_cfg->cfg.s_length;
+	cmd.cfg.rate = probe_cfg->cfg.rate;
+	cmd.cfg.format = probe_cfg->cfg.format;
+	cmd.sm_buf_id = 1;
+
+	return sst_fill_and_send_cmd(sst, SST_IPC_IA_CMD, SST_FLAG_BLOCKED,
+				     probe_cfg->task_id, 0, &cmd,
+				     sizeof(cmd.header) + cmd.header.length);
+}
+
+static const struct snd_kcontrol_new sst_probe_controls[];
+static const struct sst_probe_config sst_probes[];
+
+#define SST_MAX_PROBE_STREAMS 8
+int sst_dpcm_probe_send(struct snd_soc_platform *platform, u16 probe_pipe_id,
+			int substream, int direction, bool on)
+{
+	int switch_state = on ? SST_SWITCH_ON : SST_SWITCH_OFF;
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	const struct sst_probe_config *probe_cfg;
+	struct sst_probe_value *probe_val;
+	char *type;
+	int offset;
+	int mode;
+
+	if (direction == SNDRV_PCM_STREAM_CAPTURE) {
+		mode = SST_PROBE_EXTRACTOR;
+		offset = 0;
+		type = "extractor";
+	} else {
+		mode = SST_PROBE_INJECTOR;
+		offset = SST_MAX_PROBE_STREAMS;
+		type = "injector";
+	}
+	/* get the value of the probe connection kcontrol */
+	probe_val = (void *)sst_probe_controls[substream + offset].private_value;
+	probe_cfg = &sst_probes[probe_val->val];
+
+	pr_debug("%s: substream=%d, direction=%d\n", __func__, substream, direction);
+	pr_debug("%s: %s probe point at %s\n", __func__, type, probe_cfg->name);
+
+	return sst_send_probe_cmd(sst, probe_pipe_id, mode, switch_state, probe_cfg);
+}
+
+/**
+ * sst_alloc_hostless_stream - send ALLOC for a stream
+ *
+ * The stream does not send data to IA. The data is consumed by an internal
+ * sink.
+ */
+static int sst_alloc_hostless_stream(const struct sst_pcm_format *pcm_params,
+				     int str_id, uint pipe_id, uint task_id)
+{
+	struct snd_sst_stream_params param;
+	struct snd_sst_params str_params = {0};
+	struct snd_sst_alloc_params_ext alloc_params = {0};
+	int ret_val = 0;
+
+	memset(&param.uc.pcm_params, 0, sizeof(param.uc.pcm_params));
+	param.uc.pcm_params.num_chan = pcm_params->channels_max;
+	param.uc.pcm_params.pcm_wd_sz = pcm_params->sample_bits;
+	param.uc.pcm_params.sfreq = pcm_params->rate_min;
+	pr_debug("%s: sfreq= %d, wd_sz = %d\n", __func__,
+		 param.uc.pcm_params.sfreq, param.uc.pcm_params.pcm_wd_sz);
+
+	str_params.sparams = param;
+	str_params.aparams = alloc_params;
+	str_params.codec = SST_CODEC_TYPE_PCM;
+
+	/* fill the pipe_id and stream id to pass to SST driver */
+	str_params.stream_type = SST_STREAM_TYPE_MUSIC;
+	str_params.stream_id = str_id;
+	str_params.device_type = pipe_id;
+	str_params.task = task_id;
+	str_params.ops = STREAM_OPS_CAPTURE;
+
+	ret_val = sst_dsp->ops->open(&str_params);
+	pr_debug("platform prepare: stream open ret_val = 0x%x\n", ret_val);
+	if (ret_val <= 0)
+		return ret_val;
+
+	return ret_val;
+}
+
+static int sst_hostless_stream_event(struct snd_soc_dapm_widget *w,
+					struct snd_kcontrol *k, int event)
+{
+	struct sst_ids *ids = w->priv;
+
+#define MERR_DPCM_HOSTLESS_STRID 25
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		/* ALLOC */
+		/* FIXME: HACK - FW shouldn't require alloc for aware */
+		return sst_alloc_hostless_stream(ids->pcm_fmt,
+						 MERR_DPCM_HOSTLESS_STRID,
+						 ids->location_id >> SST_PATH_ID_SHIFT,
+						 ids->task_id);
+	else
+		/* FREE */
+		return sst_dsp->ops->close(MERR_DPCM_HOSTLESS_STRID);
+}
+
+static const struct snd_kcontrol_new sst_mix_sw_aware =
+	SOC_SINGLE_EXT("switch", SST_MIX_SWITCH, 0, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_vad =
+	SOC_SINGLE_EXT("switch", SST_MIX_SWITCH, 0, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_vad_enroll[] = {
+	SOC_SINGLE_BOOL_EXT("SST VTSV Enroll", 0, sst_vtsv_enroll_get,
+					sst_vtsv_enroll_set),
+};
+
+static const struct snd_kcontrol_new sst_mix_sw_tone_gen =
+	SOC_SINGLE_EXT("switch", SST_MIX_SWITCH, 1, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const char * const sst_bt_fm_texts[] = {
+	"fm", "bt",
+};
+
+static const struct snd_kcontrol_new sst_bt_fm_mux =
+	SST_SSP_MUX_CTL("ssp1_out", 0, SST_MUX_REG, SST_BT_FM_MUX_SHIFT, sst_bt_fm_texts,
+			sst_mux_get, sst_mux_put);
+
+static const struct sst_pcm_format aware_stream_fmt = {
+	.sample_bits = 24,
+	.rate_min = 8000,
+	.channels_max = 1,
+};
+
+static const struct sst_pcm_format vad_stream_fmt = {
+	.sample_bits = 16,
+	.rate_min = 16000,
+	.channels_max = 1,
+};
+
+static const struct snd_soc_dapm_widget sst_dapm_widgets[] = {
+	SND_SOC_DAPM_INPUT("tone"),
+	SST_DAPM_OUTPUT("aware", SST_PATH_INDEX_AWARE_OUT, SST_TASK_AWARE, &aware_stream_fmt, sst_hostless_stream_event),
+	SST_DAPM_OUTPUT("vad", SST_PATH_INDEX_VAD_OUT, SST_TASK_AWARE, &vad_stream_fmt, sst_hostless_stream_event),
+	SST_AIF_IN("modem_in",  sst_set_be_modules),
+	SST_AIF_IN("codec_in0", sst_set_be_modules),
+	SST_AIF_IN("codec_in1", sst_set_be_modules),
+	SST_AIF_IN("bt_fm_in", sst_set_be_modules),
+	SST_AIF_OUT("modem_out", sst_set_be_modules),
+	SST_AIF_OUT("codec_out0", sst_set_be_modules),
+	SST_AIF_OUT("codec_out1", sst_set_be_modules),
+	SST_AIF_OUT("bt_fm_out", sst_set_be_modules),
+
+	/* Media Paths */
+	/* MediaX IN paths are set via ALLOC, so no SET_MEDIA_PATH command */
+	SST_PATH_INPUT("media0_in", SST_TASK_MMX, SST_SWM_IN_MEDIA0, sst_generic_modules_event),
+	SST_PATH_INPUT("media1_in", SST_TASK_MMX, SST_SWM_IN_MEDIA1, NULL),
+	SST_PATH_INPUT("media2_in", SST_TASK_MMX, SST_SWM_IN_MEDIA2, sst_set_media_path),
+	SST_PATH_INPUT("media3_in", SST_TASK_MMX, SST_SWM_IN_MEDIA3, NULL),
+	SST_PATH_OUTPUT("media0_out", SST_TASK_MMX, SST_SWM_OUT_MEDIA0, sst_set_media_path),
+	SST_PATH_OUTPUT("media1_out", SST_TASK_MMX, SST_SWM_OUT_MEDIA1, sst_set_media_path),
+
+	/* SBA PCM Paths */
+	SST_PATH_INPUT("pcm0_in", SST_TASK_SBA, SST_SWM_IN_PCM0, sst_set_media_path),
+	SST_PATH_INPUT("pcm1_in", SST_TASK_SBA, SST_SWM_IN_PCM1, sst_set_media_path),
+	SST_PATH_OUTPUT("pcm0_out", SST_TASK_SBA, SST_SWM_OUT_PCM0, sst_set_media_path),
+	SST_PATH_OUTPUT("pcm1_out", SST_TASK_SBA, SST_SWM_OUT_PCM1, sst_set_media_path),
+	SST_PATH_OUTPUT("pcm2_out", SST_TASK_SBA, SST_SWM_OUT_PCM2, sst_set_media_path),
+	/* TODO: check if this needs SET_MEDIA_PATH command*/
+	SST_PATH_INPUT("low_pcm0_in", SST_TASK_SBA, SST_SWM_IN_LOW_PCM0, NULL),
+
+	SST_PATH_INPUT("voip_in", SST_TASK_SBA, SST_SWM_IN_VOIP, sst_set_media_path),
+	SST_PATH_OUTPUT("voip_out", SST_TASK_SBA, SST_SWM_OUT_VOIP, sst_set_media_path),
+	SST_PATH_OUTPUT("aware_out", SST_TASK_SBA, SST_SWM_OUT_AWARE, sst_set_media_path),
+	SST_PATH_OUTPUT("vad_out", SST_TASK_SBA, SST_SWM_OUT_VAD, sst_set_media_path),
+
+	/* SBA Loops */
+	SST_PATH_INPUT("sprot_loop_in", SST_TASK_SBA, SST_SWM_IN_SPROT_LOOP, NULL),
+	SST_PATH_INPUT("media_loop1_in", SST_TASK_SBA, SST_SWM_IN_MEDIA_LOOP1, NULL),
+	SST_PATH_INPUT("media_loop2_in", SST_TASK_SBA, SST_SWM_IN_MEDIA_LOOP2, NULL),
+	SST_PATH_MEDIA_LOOP_OUTPUT("sprot_loop_out", SST_TASK_SBA, SST_SWM_OUT_SPROT_LOOP, SST_FMT_MONO, sst_set_media_loop),
+	SST_PATH_MEDIA_LOOP_OUTPUT("media_loop1_out", SST_TASK_SBA, SST_SWM_OUT_MEDIA_LOOP1, SST_FMT_MONO, sst_set_media_loop),
+	SST_PATH_MEDIA_LOOP_OUTPUT("media_loop2_out", SST_TASK_SBA, SST_SWM_OUT_MEDIA_LOOP2, SST_FMT_STEREO, sst_set_media_loop),
+
+	SST_PATH_INPUT("tone_in", SST_TASK_SBA, SST_SWM_IN_TONE, sst_tone_generator_event),
+
+	SST_PATH_LINKED_INPUT("bt_in", SST_TASK_SBA, SST_SWM_IN_BT, "bt_fm_in", sst_set_linked_pipe),
+	SST_PATH_LINKED_INPUT("fm_in", SST_TASK_SBA, SST_SWM_IN_FM, "bt_fm_in", sst_set_linked_pipe),
+	SST_PATH_LINKED_OUTPUT("bt_out", SST_TASK_SBA, SST_SWM_OUT_BT, "bt_fm_out", sst_set_linked_pipe),
+	SST_PATH_LINKED_OUTPUT("fm_out", SST_TASK_SBA, SST_SWM_OUT_FM, "bt_fm_out", sst_set_linked_pipe),
+
+	/* SBA Voice Paths */
+	SST_PATH_LINKED_INPUT("sidetone_in", SST_TASK_SBA, SST_SWM_IN_SIDETONE, "speech_out", sst_set_linked_pipe),
+	SST_PATH_INPUT("speech_in", SST_TASK_SBA, SST_SWM_IN_SPEECH, sst_set_speech_path),
+	SST_PATH_INPUT("txspeech_in", SST_TASK_SBA, SST_SWM_IN_TXSPEECH, sst_set_speech_path),
+	SST_PATH_OUTPUT("hf_sns_out", SST_TASK_SBA, SST_SWM_OUT_HF_SNS, sst_set_speech_path),
+	SST_PATH_OUTPUT("hf_out", SST_TASK_SBA, SST_SWM_OUT_HF, sst_set_speech_path),
+	SST_PATH_OUTPUT("speech_out", SST_TASK_SBA, SST_SWM_OUT_SPEECH, sst_set_speech_path),
+	SST_PATH_OUTPUT("rxspeech_out", SST_TASK_SBA, SST_SWM_OUT_RXSPEECH, sst_set_speech_path),
+
+	/* Media Mixers */
+	SST_SWM_MIXER("media0_out mix 0", SST_MIX_MEDIA0, SST_TASK_MMX, SST_SWM_OUT_MEDIA0,
+		      sst_mix_media0_controls, sst_swm_mixer_event),
+	SST_SWM_MIXER("media1_out mix 0", SST_MIX_MEDIA1, SST_TASK_MMX, SST_SWM_OUT_MEDIA1,
+		      sst_mix_media1_controls, sst_swm_mixer_event),
+
+	/* SBA PCM mixers */
+	SST_SWM_MIXER("pcm0_out mix 0", SST_MIX_PCM0, SST_TASK_SBA, SST_SWM_OUT_PCM0,
+		      sst_mix_pcm0_controls, sst_swm_mixer_event),
+	SST_SWM_MIXER("pcm1_out mix 0", SST_MIX_PCM1, SST_TASK_SBA, SST_SWM_OUT_PCM1,
+		      sst_mix_pcm1_controls, sst_swm_mixer_event),
+	SST_SWM_MIXER("pcm2_out mix 0", SST_MIX_PCM2, SST_TASK_SBA, SST_SWM_OUT_PCM2,
+		      sst_mix_pcm2_controls, sst_swm_mixer_event),
+
+	/* SBA Loop mixers */
+	SST_SWM_MIXER("sprot_loop_out mix 0", SST_MIX_LOOP0, SST_TASK_SBA, SST_SWM_OUT_SPROT_LOOP,
+		      sst_mix_sprot_l0_controls, sst_swm_mixer_event),
+	SST_SWM_MIXER("media_loop1_out mix 0", SST_MIX_LOOP1, SST_TASK_SBA, SST_SWM_OUT_MEDIA_LOOP1,
+		      sst_mix_media_l1_controls, sst_swm_mixer_event),
+	SST_SWM_MIXER("media_loop2_out mix 0", SST_MIX_LOOP2, SST_TASK_SBA, SST_SWM_OUT_MEDIA_LOOP2,
+		      sst_mix_media_l2_controls, sst_swm_mixer_event),
+
+	SST_SWM_MIXER("voip_out mix 0", SST_MIX_VOIP, SST_TASK_SBA, SST_SWM_OUT_VOIP,
+		      sst_mix_voip_controls, sst_swm_mixer_event),
+	SST_SWM_MIXER("aware_out mix 0", SST_MIX_AWARE, SST_TASK_SBA, SST_SWM_OUT_AWARE,
+		      sst_mix_aware_controls, sst_swm_mixer_event),
+	SST_SWM_MIXER("vad_out mix 0", SST_MIX_VAD, SST_TASK_SBA, SST_SWM_OUT_VAD,
+		      sst_mix_vad_controls, sst_swm_mixer_event),
+
+	/* SBA Voice mixers */
+	SST_SWM_MIXER("hf_sns_out mix 0", SST_MIX_HF_SNS, SST_TASK_SBA, SST_SWM_OUT_HF_SNS,
+		      sst_mix_hf_sns_controls, sst_swm_mixer_event),
+	SST_SWM_MIXER("hf_out mix 0", SST_MIX_HF, SST_TASK_SBA, SST_SWM_OUT_HF,
+		      sst_mix_hf_controls, sst_swm_mixer_event),
+	SST_SWM_MIXER("speech_out mix 0", SST_MIX_SPEECH, SST_TASK_SBA, SST_SWM_OUT_SPEECH,
+		      sst_mix_speech_controls, sst_swm_mixer_event),
+	SST_SWM_MIXER("rxspeech_out mix 0", SST_MIX_RXSPEECH, SST_TASK_SBA, SST_SWM_OUT_RXSPEECH,
+		      sst_mix_rxspeech_controls, sst_swm_mixer_event),
+
+	/* SBA Backend mixers */
+	SST_SWM_MIXER("codec_out0 mix 0", SST_MIX_CODEC0, SST_TASK_SBA, SST_SWM_OUT_CODEC0,
+		      sst_mix_codec0_controls, sst_swm_mixer_event),
+	SST_SWM_MIXER("codec_out1 mix 0", SST_MIX_CODEC1, SST_TASK_SBA, SST_SWM_OUT_CODEC1,
+		      sst_mix_codec1_controls, sst_swm_mixer_event),
+	SST_SWM_MIXER("bt_out mix 0", SST_MIX_BT, SST_TASK_SBA, SST_SWM_OUT_BT,
+		      sst_mix_bt_controls, sst_swm_mixer_event),
+	SST_SWM_MIXER("fm_out mix 0", SST_MIX_FM, SST_TASK_SBA, SST_SWM_OUT_FM,
+		      sst_mix_fm_controls, sst_swm_mixer_event),
+	SST_SWM_MIXER("modem_out mix 0", SST_MIX_MODEM, SST_TASK_SBA, SST_SWM_OUT_MODEM,
+		      sst_mix_modem_controls, sst_swm_mixer_event),
+
+	SND_SOC_DAPM_MUX("ssp1_out mux 0", SND_SOC_NOPM, 0, 0, &sst_bt_fm_mux),
+	SND_SOC_DAPM_SWITCH("aware_out aware 0", SND_SOC_NOPM, 0, 0, &sst_mix_sw_aware),
+	SND_SOC_DAPM_SWITCH("vad_out vad 0", SND_SOC_NOPM, 0, 0, &sst_mix_sw_vad),
+
+	SND_SOC_DAPM_SWITCH("tone_in tone_generator 0", SND_SOC_NOPM, 0, 0, &sst_mix_sw_tone_gen),
+};
+
+static const struct snd_soc_dapm_route intercon[] = {
+	{"media0_in", NULL, "Compress Playback"},
+	{"media1_in", NULL, "Headset Playback"},
+	{"media2_in", NULL, "pcm0_out"},
+	{"media3_in", NULL, "Deepbuffer Playback"},
+
+	{"media0_out mix 0", "media0_in", "media0_in"},
+	{"media0_out mix 0", "media1_in", "media1_in"},
+	{"media0_out mix 0", "media2_in", "media2_in"},
+	{"media0_out mix 0", "media3_in", "media3_in"},
+	{"media1_out mix 0", "media0_in", "media0_in"},
+	{"media1_out mix 0", "media1_in", "media1_in"},
+	{"media1_out mix 0", "media2_in", "media2_in"},
+	{"media1_out mix 0", "media3_in", "media3_in"},
+
+	{"media0_out", NULL, "media0_out mix 0"},
+	{"media1_out", NULL, "media1_out mix 0"},
+	{"pcm0_in", NULL, "media0_out"},
+	{"pcm1_in", NULL, "media1_out"},
+
+	{"Headset Capture", NULL, "pcm1_out"},
+	{"Headset Capture", NULL, "pcm2_out"},
+	{"pcm0_out", NULL, "pcm0_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("pcm0_out mix 0"),
+	{"pcm1_out", NULL, "pcm1_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("pcm1_out mix 0"),
+	{"pcm2_out", NULL, "pcm2_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("pcm2_out mix 0"),
+
+	{"media_loop1_in", NULL, "media_loop1_out"},
+	{"media_loop1_out", NULL, "media_loop1_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("media_loop1_out mix 0"),
+	{"media_loop2_in", NULL, "media_loop2_out"},
+	{"media_loop2_out", NULL, "media_loop2_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("media_loop2_out mix 0"),
+	{"sprot_loop_in", NULL, "sprot_loop_out"},
+	{"sprot_loop_out", NULL, "sprot_loop_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("sprot_loop_out mix 0"),
+
+	{"voip_in", NULL, "VOIP Playback"},
+	{"VOIP Capture", NULL, "voip_out"},
+	{"voip_out", NULL, "voip_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("voip_out mix 0"),
+
+	{"aware", NULL, "aware_out"},
+	{"aware_out", NULL, "aware_out aware 0"},
+	{"aware_out aware 0", "switch", "aware_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("aware_out mix 0"),
+	{"vad", NULL, "vad_out"},
+	{"vad_out", NULL, "vad_out vad 0"},
+	{"vad_out vad 0", "switch", "vad_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("vad_out mix 0"),
+
+	{"codec_out0", NULL, "codec_out0 mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("codec_out0 mix 0"),
+	{"codec_out1", NULL, "codec_out1 mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("codec_out1 mix 0"),
+	{"modem_out", NULL, "modem_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("modem_out mix 0"),
+
+	{"bt_fm_out", NULL, "ssp1_out mux 0"},
+	{"ssp1_out mux 0", "bt", "bt_out"},
+	{"ssp1_out mux 0", "fm", "fm_out"},
+	{"bt_out", NULL, "bt_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("bt_out mix 0"),
+	{"fm_out", NULL, "fm_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("fm_out mix 0"),
+	{"bt_in", NULL, "bt_fm_in"},
+	{"fm_in", NULL, "bt_fm_in"},
+
+	/* Uplink processing */
+	{"txspeech_in", NULL, "hf_sns_out"},
+	{"txspeech_in", NULL, "hf_out"},
+	{"txspeech_in", NULL, "speech_out"},
+	{"sidetone_in", NULL, "speech_out"},
+
+	{"hf_sns_out", NULL, "hf_sns_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("hf_sns_out mix 0"),
+	{"hf_out", NULL, "hf_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("hf_out mix 0"),
+	{"speech_out", NULL, "speech_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("speech_out mix 0"),
+
+	/* Downlink processing */
+	{"speech_in", NULL, "rxspeech_out"},
+	{"rxspeech_out", NULL, "rxspeech_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("rxspeech_out mix 0"),
+
+	{"tone_in", NULL, "tone_in tone_generator 0"},
+	{"tone_in tone_generator 0", "switch", "tone"},
+
+	/* TODO: add sidetone inputs */
+	/* TODO: add Low Latency stream support */
+};
+
+static const char * const sst_nb_wb_texts[] = {
+	"narrowband", "wideband",
+};
+
+static const struct snd_kcontrol_new sst_mux_controls[] = {
+	SST_SSP_MUX_CTL("domain voice mode", 0, SST_MUX_REG, SST_VOICE_MODE_SHIFT, sst_nb_wb_texts,
+			sst_mode_get, sst_mode_put),
+	SST_SSP_MUX_CTL("domain bt mode", 0, SST_MUX_REG, SST_BT_MODE_SHIFT, sst_nb_wb_texts,
+			sst_mode_get, sst_mode_put),
+};
+
+static const char * const slot_names[] = {
+	"none",
+	"slot 0", "slot 1", "slot 2", "slot 3",
+	"slot 4", "slot 5", "slot 6", "slot 7", /* not supported by FW */
+};
+
+static const char * const channel_names[] = {
+	"none",
+	"codec_out0_0", "codec_out0_1", "codec_out1_0", "codec_out1_1",
+	"codec_out2_0", "codec_out2_1", "codec_out3_0", "codec_out3_1", /* not supported by FW */
+};
+
+#define SST_INTERLEAVER(xpname, slot_name, slotno) \
+	SST_SSP_SLOT_CTL(xpname, "interleaver", slot_name, slotno, true, \
+			 channel_names, sst_slot_get, sst_slot_put)
+
+#define SST_DEINTERLEAVER(xpname, channel_name, channel_no) \
+	SST_SSP_SLOT_CTL(xpname, "deinterleaver", channel_name, channel_no, false, \
+			 slot_names, sst_slot_get, sst_slot_put)
+
+static const struct snd_kcontrol_new sst_slot_controls[] = {
+	SST_INTERLEAVER("codec_out", "slot 0", 0),
+	SST_INTERLEAVER("codec_out", "slot 1", 1),
+	SST_INTERLEAVER("codec_out", "slot 2", 2),
+	SST_INTERLEAVER("codec_out", "slot 3", 3),
+	SST_DEINTERLEAVER("codec_in", "codec_in0_0", 0),
+	SST_DEINTERLEAVER("codec_in", "codec_in0_1", 1),
+	SST_DEINTERLEAVER("codec_in", "codec_in1_0", 2),
+	SST_DEINTERLEAVER("codec_in", "codec_in1_1", 3),
+};
+
+#include "probe_point_dpcm.c"
+
+/* initialized based on names in sst_probes array */
+static const char *sst_probe_enum_texts[ARRAY_SIZE(sst_probes)];
+static const SOC_ENUM_SINGLE_EXT_DECL(sst_probe_enum, sst_probe_enum_texts);
+
+#define SST_PROBE_CTL(name, num)						\
+	SST_PROBE_ENUM(SST_PROBE_CTL_NAME(name, num, "connection"),		\
+		       sst_probe_enum, sst_probe_get, sst_probe_put)
+	/* TODO: implement probe gains
+	SOC_SINGLE_EXT_TLV(SST_PROBE_CTL_NAME(name, num, "gains"), xreg, xshift,
+		xmax, xinv, xget, xput, sst_gain_tlv_common)
+	*/
+
+static const struct snd_kcontrol_new sst_probe_controls[] = {
+	SST_PROBE_CTL("probe out", 0),
+	SST_PROBE_CTL("probe out", 1),
+	SST_PROBE_CTL("probe out", 2),
+	SST_PROBE_CTL("probe out", 3),
+	SST_PROBE_CTL("probe out", 4),
+	SST_PROBE_CTL("probe out", 5),
+	SST_PROBE_CTL("probe out", 6),
+	SST_PROBE_CTL("probe out", 7),
+	SST_PROBE_CTL("probe in", 0),
+	SST_PROBE_CTL("probe in", 1),
+	SST_PROBE_CTL("probe in", 2),
+	SST_PROBE_CTL("probe in", 3),
+	SST_PROBE_CTL("probe in", 4),
+	SST_PROBE_CTL("probe in", 5),
+	SST_PROBE_CTL("probe in", 6),
+	SST_PROBE_CTL("probe in", 7),
+};
+
+/* Gain helper with min/max set */
+#define SST_GAIN(name, path_id, task_id, instance, gain_var)				\
+	SST_GAIN_KCONTROLS(name, "gain", SST_GAIN_MIN_VALUE, SST_GAIN_MAX_VALUE,	\
+		SST_GAIN_TC_MIN, SST_GAIN_TC_MAX,					\
+		sst_gain_get, sst_gain_put,						\
+		SST_MODULE_ID_GAIN_CELL, path_id, instance, task_id,			\
+		sst_gain_tlv_common, gain_var)
+
+#define SST_VOLUME(name, path_id, task_id, instance, gain_var)				\
+	SST_GAIN_KCONTROLS(name, "volume", SST_GAIN_MIN_VALUE, SST_GAIN_MAX_VALUE,	\
+		SST_GAIN_TC_MIN, SST_GAIN_TC_MAX,					\
+		sst_gain_get, sst_gain_put,						\
+		SST_MODULE_ID_VOLUME, path_id, instance, task_id,			\
+		sst_gain_tlv_common, gain_var)
+
+#define SST_NUM_GAINS 36
+static struct sst_gain_value sst_gains[SST_NUM_GAINS];
+
+static const struct snd_kcontrol_new sst_gain_controls[] = {
+	SST_GAIN("media0_in", SST_PATH_INDEX_MEDIA0_IN, SST_TASK_MMX, 0, &sst_gains[0]),
+	SST_GAIN("media1_in", SST_PATH_INDEX_MEDIA1_IN, SST_TASK_MMX, 0, &sst_gains[1]),
+	SST_GAIN("media2_in", SST_PATH_INDEX_MEDIA2_IN, SST_TASK_MMX, 0, &sst_gains[2]),
+	SST_GAIN("media3_in", SST_PATH_INDEX_MEDIA3_IN, SST_TASK_MMX, 0, &sst_gains[3]),
+
+	SST_GAIN("pcm0_in", SST_PATH_INDEX_PCM0_IN, SST_TASK_SBA, 0, &sst_gains[4]),
+	SST_GAIN("pcm1_in", SST_PATH_INDEX_PCM1_IN, SST_TASK_SBA, 0, &sst_gains[5]),
+	SST_GAIN("low_pcm0_in", SST_PATH_INDEX_LOW_PCM0_IN, SST_TASK_SBA, 0, &sst_gains[6]),
+	SST_GAIN("pcm1_out", SST_PATH_INDEX_PCM1_OUT, SST_TASK_SBA, 0, &sst_gains[7]),
+	SST_GAIN("pcm2_out", SST_PATH_INDEX_PCM2_OUT, SST_TASK_SBA, 0, &sst_gains[8]),
+
+	SST_GAIN("voip_in", SST_PATH_INDEX_VOIP_IN, SST_TASK_SBA, 0, &sst_gains[9]),
+	SST_GAIN("voip_out", SST_PATH_INDEX_VOIP_OUT, SST_TASK_SBA, 0, &sst_gains[10]),
+	SST_GAIN("tone_in", SST_PATH_INDEX_TONE_IN, SST_TASK_SBA, 0, &sst_gains[11]),
+
+	SST_GAIN("aware_out", SST_PATH_INDEX_AWARE_OUT, SST_TASK_SBA, 0, &sst_gains[12]),
+	SST_GAIN("vad_out", SST_PATH_INDEX_VAD_OUT, SST_TASK_SBA, 0, &sst_gains[13]),
+
+	SST_GAIN("hf_sns_out", SST_PATH_INDEX_HF_SNS_OUT, SST_TASK_SBA, 0, &sst_gains[14]),
+	SST_GAIN("hf_out", SST_PATH_INDEX_HF_OUT, SST_TASK_SBA, 0, &sst_gains[15]),
+	SST_GAIN("speech_out", SST_PATH_INDEX_SPEECH_OUT, SST_TASK_SBA, 0, &sst_gains[16]),
+	SST_GAIN("txspeech_in", SST_PATH_INDEX_TX_SPEECH_IN, SST_TASK_SBA, 0, &sst_gains[17]),
+	SST_GAIN("rxspeech_out", SST_PATH_INDEX_RX_SPEECH_OUT, SST_TASK_SBA, 0, &sst_gains[18]),
+	SST_GAIN("speech_in", SST_PATH_INDEX_SPEECH_IN, SST_TASK_SBA, 0, &sst_gains[19]),
+
+	SST_GAIN("codec_in0", SST_PATH_INDEX_CODEC_IN0, SST_TASK_SBA, 0, &sst_gains[20]),
+	SST_GAIN("codec_in1", SST_PATH_INDEX_CODEC_IN1, SST_TASK_SBA, 0, &sst_gains[21]),
+	SST_GAIN("codec_out0", SST_PATH_INDEX_CODEC_OUT0, SST_TASK_SBA, 0, &sst_gains[22]),
+	SST_GAIN("codec_out1", SST_PATH_INDEX_CODEC_OUT1, SST_TASK_SBA, 0, &sst_gains[23]),
+	SST_GAIN("bt_out", SST_PATH_INDEX_BT_OUT, SST_TASK_SBA, 0, &sst_gains[24]),
+	SST_GAIN("fm_out", SST_PATH_INDEX_FM_OUT, SST_TASK_SBA, 0, &sst_gains[25]),
+	SST_GAIN("bt_in", SST_PATH_INDEX_BT_IN, SST_TASK_SBA, 0, &sst_gains[26]),
+	SST_GAIN("fm_in", SST_PATH_INDEX_FM_IN, SST_TASK_SBA, 0, &sst_gains[27]),
+	SST_GAIN("modem_in", SST_PATH_INDEX_MODEM_IN, SST_TASK_SBA, 0, &sst_gains[28]),
+	SST_GAIN("modem_out", SST_PATH_INDEX_MODEM_OUT, SST_TASK_SBA, 0, &sst_gains[29]),
+	SST_GAIN("media_loop1_out", SST_PATH_INDEX_MEDIA_LOOP1_OUT, SST_TASK_SBA, 0, &sst_gains[30]),
+	SST_GAIN("media_loop2_out", SST_PATH_INDEX_MEDIA_LOOP2_OUT, SST_TASK_SBA, 0, &sst_gains[31]),
+	SST_GAIN("sprot_loop_out", SST_PATH_INDEX_SPROT_LOOP_OUT, SST_TASK_SBA, 0, &sst_gains[32]),
+	SST_VOLUME("media0_in", SST_PATH_INDEX_MEDIA0_IN, SST_TASK_MMX, 0, &sst_gains[33]),
+	SST_GAIN("sidetone_in", SST_PATH_INDEX_SIDETONE_IN, SST_TASK_SBA, 0, &sst_gains[34]),
+	SST_GAIN("speech_out", SST_PATH_INDEX_SPEECH_OUT, SST_TASK_FBA_UL, 1, &sst_gains[35]),
+};
+
+static const struct snd_kcontrol_new sst_algo_controls[] = {
+	SST_ALGO_KCONTROL_BYTES("media_loop1_out", "fir", 272, SST_MODULE_ID_FIR_24,
+		 SST_PATH_INDEX_MEDIA_LOOP1_OUT, 0, SST_TASK_SBA, SBA_VB_SET_FIR),
+	SST_ALGO_KCONTROL_BYTES("media_loop1_out", "iir", 300, SST_MODULE_ID_IIR_24,
+		SST_PATH_INDEX_MEDIA_LOOP1_OUT, 0, SST_TASK_SBA, SBA_VB_SET_IIR),
+	SST_ALGO_KCONTROL_BYTES("media_loop1_out", "mdrp", 286, SST_MODULE_ID_MDRP,
+		SST_PATH_INDEX_MEDIA_LOOP1_OUT, 0, SST_TASK_SBA, SBA_SET_MDRP),
+	SST_ALGO_KCONTROL_BYTES("media_loop2_out", "fir", 272, SST_MODULE_ID_FIR_24,
+		SST_PATH_INDEX_MEDIA_LOOP2_OUT, 0, SST_TASK_SBA, SBA_VB_SET_FIR),
+	SST_ALGO_KCONTROL_BYTES("media_loop2_out", "iir", 300, SST_MODULE_ID_IIR_24,
+		SST_PATH_INDEX_MEDIA_LOOP2_OUT, 0, SST_TASK_SBA, SBA_VB_SET_IIR),
+	SST_ALGO_KCONTROL_BYTES("media_loop2_out", "mdrp", 286, SST_MODULE_ID_MDRP,
+		SST_PATH_INDEX_MEDIA_LOOP2_OUT, 0, SST_TASK_SBA, SBA_SET_MDRP),
+	SST_ALGO_KCONTROL_BYTES("aware_out", "fir", 272, SST_MODULE_ID_FIR_24,
+		SST_PATH_INDEX_AWARE_OUT, 0, SST_TASK_SBA, SBA_VB_SET_FIR),
+	SST_ALGO_KCONTROL_BYTES("aware_out", "iir", 300, SST_MODULE_ID_IIR_24,
+		SST_PATH_INDEX_AWARE_OUT, 0, SST_TASK_SBA, SBA_VB_SET_IIR),
+	SST_ALGO_KCONTROL_BYTES("aware_out", "aware", 48, SST_MODULE_ID_CONTEXT_ALGO_AWARE,
+		SST_PATH_INDEX_AWARE_OUT, 0, SST_TASK_AWARE, AWARE_ENV_CLASS_PARAMS),
+	SST_ALGO_KCONTROL_BYTES("vad_out", "fir", 272, SST_MODULE_ID_FIR_24,
+		SST_PATH_INDEX_VAD_OUT, 0, SST_TASK_SBA, SBA_VB_SET_FIR),
+	SST_ALGO_KCONTROL_BYTES("vad_out", "iir", 300, SST_MODULE_ID_IIR_24,
+		SST_PATH_INDEX_VAD_OUT, 0, SST_TASK_SBA, SBA_VB_SET_IIR),
+	SST_ALGO_KCONTROL_BYTES("vad_out", "vad", 28, SST_MODULE_ID_ALGO_VTSV,
+		SST_PATH_INDEX_VAD_OUT, 0, SST_TASK_AWARE, VAD_ENV_CLASS_PARAMS),
+	SST_ALGO_KCONTROL_BYTES("sprot_loop_out", "lpro", 192, SST_MODULE_ID_SPROT,
+		SST_PATH_INDEX_SPROT_LOOP_OUT, 0, SST_TASK_SBA, SBA_VB_LPRO),
+	SST_ALGO_KCONTROL_BYTES("modem_in", "dcr", 60, SST_MODULE_ID_FILT_DCR,
+		SST_PATH_INDEX_MODEM_IN, 0, SST_TASK_SBA, SBA_VB_SET_IIR),
+	SST_ALGO_KCONTROL_BYTES("bt_in", "dcr", 60, SST_MODULE_ID_FILT_DCR,
+		SST_PATH_INDEX_BT_IN, 0, SST_TASK_SBA, SBA_VB_SET_IIR),
+	SST_ALGO_KCONTROL_BYTES("codec_in0", "dcr", 52, SST_MODULE_ID_FILT_DCR,
+		SST_PATH_INDEX_CODEC_IN0, 0, SST_TASK_SBA, SBA_VB_SET_IIR),
+	SST_ALGO_KCONTROL_BYTES("codec_in1", "dcr", 52, SST_MODULE_ID_FILT_DCR,
+		SST_PATH_INDEX_CODEC_IN1, 0, SST_TASK_SBA, SBA_VB_SET_IIR),
+	SST_ALGO_KCONTROL_BYTES("fm_in", "dcr", 60, SST_MODULE_ID_FILT_DCR,
+		SST_PATH_INDEX_FM_IN, 0, SST_TASK_SBA, SBA_VB_SET_IIR),
+	/* Uplink */
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "fir_speech", 134, SST_MODULE_ID_FIR_16,
+		SST_PATH_INDEX_SPEECH_OUT, 0, SST_TASK_FBA_UL, FBA_VB_SET_FIR),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "fir_hf_sns", 134, SST_MODULE_ID_FIR_16,
+		SST_PATH_INDEX_HF_SNS_OUT, 0, SST_TASK_FBA_UL, FBA_VB_SET_FIR | (0x0001<<11)),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "iir_speech", 46, SST_MODULE_ID_IIR_16,
+		SST_PATH_INDEX_SPEECH_OUT, 0, SST_TASK_FBA_UL, FBA_VB_SET_IIR),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "iir_hf_sns", 46, SST_MODULE_ID_IIR_16,
+		SST_PATH_INDEX_HF_SNS_OUT, 0, SST_TASK_FBA_UL, FBA_VB_SET_IIR | (0x0001<<11)),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "aec", 642, SST_MODULE_ID_AEC,
+		SST_PATH_INDEX_SPEECH_OUT, 0, SST_TASK_FBA_UL, FBA_VB_AEC),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "nr", 38, SST_MODULE_ID_NR,
+		SST_PATH_INDEX_SPEECH_OUT, 0, SST_TASK_FBA_UL, FBA_VB_NR_UL),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "agc", 62, SST_MODULE_ID_AGC,
+		SST_PATH_INDEX_SPEECH_OUT, 0, SST_TASK_FBA_UL, FBA_VB_AGC),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "compr", 100, SST_MODULE_ID_DRP,
+		SST_PATH_INDEX_SPEECH_OUT, 0, SST_TASK_FBA_UL, FBA_VB_DUAL_BAND_COMP),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "ser", 44, SST_MODULE_ID_SER,
+		SST_PATH_INDEX_SPEECH_OUT, 0, SST_TASK_FBA_UL, FBA_VB_SER),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "cni", 48, SST_MODULE_ID_CNI_TX,
+		SST_PATH_INDEX_SPEECH_OUT, 0, SST_TASK_FBA_UL, FBA_VB_TX_CNI),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "ref", 24, SST_MODULE_ID_REF_LINE,
+		SST_PATH_INDEX_HF_OUT, 0, SST_TASK_FBA_UL, FBA_VB_SET_REF_LINE),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "delay", 6, SST_MODULE_ID_EDL,
+		SST_PATH_INDEX_HF_OUT, 0, SST_TASK_FBA_UL, FBA_VB_SET_DELAY_LINE),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "bmf", 572, SST_MODULE_ID_BMF,
+		SST_PATH_INDEX_HF_SNS_OUT, 0, SST_TASK_FBA_UL, FBA_VB_BMF),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "dnr", 56, SST_MODULE_ID_DNR,
+		SST_PATH_INDEX_SPEECH_OUT, 0, SST_TASK_FBA_UL, FBA_VB_DNR),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "wnr", 64, SST_MODULE_ID_WNR,
+		SST_PATH_INDEX_SPEECH_OUT, 0, SST_TASK_FBA_UL, FBA_VB_WNR),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "tnr", 38, SST_MODULE_ID_TNR,
+		SST_PATH_INDEX_SPEECH_OUT, 0, SST_TASK_FBA_UL, FBA_VB_TNR_UL),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "nlf", 236, SST_MODULE_ID_NLF,
+		SST_PATH_INDEX_SPEECH_OUT, 0, SST_TASK_FBA_UL, FBA_VB_NLF),
+
+	/* Downlink */
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_in", "dl_module", "ana", 52, SST_MODULE_ID_ANA,
+		SST_PATH_INDEX_SPEECH_IN, 0, SST_TASK_FBA_DL, FBA_VB_ANA),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_in", "dl_module", "fir", 134, SST_MODULE_ID_FIR_16,
+		SST_PATH_INDEX_SPEECH_IN, 0, SST_TASK_FBA_DL, FBA_VB_SET_FIR),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_in", "dl_module", "iir", 46, SST_MODULE_ID_IIR_16,
+		SST_PATH_INDEX_SPEECH_IN, 0, SST_TASK_FBA_DL, FBA_VB_SET_IIR),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_in", "dl_module", "nr", 38, SST_MODULE_ID_NR,
+		SST_PATH_INDEX_SPEECH_IN, 0, SST_TASK_FBA_DL, FBA_VB_NR_DL),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_in", "dl_module", "compr", 100, SST_MODULE_ID_DRP,
+		SST_PATH_INDEX_SPEECH_IN, 0, SST_TASK_FBA_DL, FBA_VB_DUAL_BAND_COMP),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_in", "dl_module", "cni", 28, SST_MODULE_ID_CNI,
+		SST_PATH_INDEX_SPEECH_IN, 0, SST_TASK_FBA_DL, FBA_VB_RX_CNI),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_in", "dl_module", "bwx", 54, SST_MODULE_ID_BWX,
+		SST_PATH_INDEX_SPEECH_IN, 0, SST_TASK_FBA_DL, FBA_VB_BWX),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_in", "dl_module", "gmm", 586, SST_MODULE_ID_BWX,
+		SST_PATH_INDEX_SPEECH_IN, 0, SST_TASK_FBA_DL, FBA_VB_GMM),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_in", "dl_module", "glc", 18, SST_MODULE_ID_GLC,
+		SST_PATH_INDEX_SPEECH_IN, 0, SST_TASK_FBA_DL, FBA_VB_GLC),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_in", "dl_module", "tnr", 38, SST_MODULE_ID_TNR,
+		SST_PATH_INDEX_SPEECH_IN, 0, SST_TASK_FBA_DL, FBA_VB_TNR_DL),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_in", "dl_module", "slv", 34, SST_MODULE_ID_SLV,
+		SST_PATH_INDEX_SPEECH_IN, 0, SST_TASK_FBA_DL, FBA_VB_SLV),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_in", "dl_module", "mdrp", 134, SST_MODULE_ID_MDRP,
+		SST_PATH_INDEX_SPEECH_IN, 0, SST_TASK_FBA_DL, FBA_VB_MDRP),
+
+	/* Tone Generator */
+	SST_ALGO_KCONTROL_BYTES("tone_in", "tone_generator", 116, SST_MODULE_ID_TONE_GEN,
+		SST_PATH_INDEX_RESERVED, 0, SST_TASK_SBA, SBA_VB_START_TONE),
+
+	/* Sidetone */
+	SST_ALGO_KCONTROL_BYTES("sidetone_in", "iir", 300, SST_MODULE_ID_IIR_24,
+		SST_PATH_INDEX_SIDETONE_IN, 0, SST_TASK_SBA, SBA_VB_SET_IIR),
+
+};
+
+static const struct snd_kcontrol_new sst_debug_controls[] = {
+	SND_SOC_BYTES_EXT("sst debug byte control", SST_MAX_BIN_BYTES,
+		       sst_byte_control_get, sst_byte_control_set),
+};
+
+static inline bool is_sst_dapm_widget(struct snd_soc_dapm_widget *w)
+{
+	if ((w->id == snd_soc_dapm_pga) ||
+	    (w->id == snd_soc_dapm_aif_in) ||
+	    (w->id == snd_soc_dapm_aif_out) ||
+	    (w->id == snd_soc_dapm_input) ||
+	    (w->id == snd_soc_dapm_output) ||
+	    (w->id == snd_soc_dapm_mixer))
+		return true;
+	else
+		return false;
+}
+
+/**
+ * sst_send_pipe_gains - send gains for the front-end DAIs
+ *
+ * The gains in the pipes connected to the front-ends are muted/unmuted
+ * automatically via the digital_mute() DAPM callback. This function sends the
+ * gains for the front-end pipes.
+ */
+int sst_send_pipe_gains(struct snd_soc_dai *dai, int stream, int mute)
+{
+	struct snd_soc_platform *platform = dai->platform;
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	struct snd_soc_dapm_widget *w;
+	struct snd_soc_dapm_path *p = NULL;
+
+	pr_debug("%s: enter, dai-name=%s dir=%d\n", __func__, dai->name, stream);
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		pr_debug("Stream name=%s\n", dai->playback_widget->name);
+		w = dai->playback_widget;
+		list_for_each_entry(p, &w->sinks, list_source) {
+			if (p->connected && !p->connected(w, p->sink))
+				continue;
+
+			if (p->connect && p->sink->power && is_sst_dapm_widget(p->sink)) {
+				struct sst_ids *ids = p->sink->priv;
+
+				pr_debug("send gains for widget=%s\n", p->sink->name);
+				sst_set_pipe_gain(ids, sst, mute);
+			}
+		}
+	} else {
+		pr_debug("Stream name=%s\n", dai->capture_widget->name);
+		w = dai->capture_widget;
+		list_for_each_entry(p, &w->sources, list_sink) {
+			if (p->connected && !p->connected(w, p->sink))
+				continue;
+
+			if (p->connect &&  p->source->power && is_sst_dapm_widget(p->source)) {
+				struct sst_ids *ids = p->source->priv;
+
+				pr_debug("send gain for widget=%s\n", p->source->name);
+				sst_set_pipe_gain(ids, sst, mute);
+			}
+		}
+	}
+	return 0;
+}
+
+/**
+ * sst_fill_module_list - populate the list of modules/gains for a pipe
+ *
+ *
+ * Fills the widget pointer in the kcontrol private data, and also fills the
+ * kcontrol pointer in the widget private data.
+ *
+ * Widget pointer is used to send the algo/gain in the .put() handler if the
+ * widget is powerd on.
+ *
+ * Kcontrol pointer is used to send the algo/gain in the widget power ON/OFF
+ * event handler. Each widget (pipe) has multiple algos stored in the algo_list.
+ */
+static int sst_fill_module_list(struct snd_kcontrol *kctl,
+	 struct snd_soc_dapm_widget *w, int type)
+{
+	struct module *module = NULL;
+	struct sst_ids *ids = w->priv;
+
+	module = devm_kzalloc(w->platform->dev, sizeof(*module), GFP_KERNEL);
+	if (!module) {
+		pr_err("kzalloc block failed\n");
+		return -ENOMEM;
+	}
+
+	if (type == SST_MODULE_GAIN) {
+		struct sst_gain_mixer_control *mc = (void *)kctl->private_value;
+
+		mc->w = w;
+		module->kctl = kctl;
+		list_add_tail(&module->node, &ids->gain_list);
+	} else if (type == SST_MODULE_ALGO) {
+		struct sst_algo_control *bc = (void *)kctl->private_value;
+
+		bc->w = w;
+		module->kctl = kctl;
+		list_add_tail(&module->node, &ids->algo_list);
+	}
+
+	return 0;
+}
+
+/**
+ * sst_fill_widget_module_info - fill list of gains/algos for the pipe
+ * @widget:	pipe modelled as a DAPM widget
+ *
+ * Fill the list of gains/algos for the widget by looking at all the card
+ * controls and comparing the name of the widget with the first part of control
+ * name. First part of control name contains the pipe name (widget name).
+ */
+static int sst_fill_widget_module_info(struct snd_soc_dapm_widget *w,
+	struct snd_soc_platform *platform)
+{
+	struct snd_kcontrol *kctl;
+	int index, ret = 0;
+	struct snd_card *card = platform->card->snd_card;
+	char *idx;
+
+	down_read(&card->controls_rwsem);
+
+	list_for_each_entry(kctl, &card->controls, list) {
+		idx = strstr(kctl->id.name, " ");
+		if (idx == NULL)
+			continue;
+		index  = strlen(kctl->id.name) - strlen(idx);
+		if (strstr(kctl->id.name, "volume") &&
+		    !strncmp(kctl->id.name, w->name, index))
+			ret = sst_fill_module_list(kctl, w, SST_MODULE_GAIN);
+		else if (strstr(kctl->id.name, "params") &&
+			 !strncmp(kctl->id.name, w->name, index))
+			ret = sst_fill_module_list(kctl, w, SST_MODULE_ALGO);
+		else if (strstr(kctl->id.name, "mute") &&
+			 !strncmp(kctl->id.name, w->name, index)) {
+			struct sst_gain_mixer_control *mc = (void *)kctl->private_value;
+			mc->w = w;
+		} else if (strstr(kctl->id.name, "interleaver") &&
+			 !strncmp(kctl->id.name, w->name, index)) {
+			struct sst_enum *e = (void *)kctl->private_value;
+			e->w = w;
+		} else if (strstr(kctl->id.name, "deinterleaver") &&
+			 !strncmp(kctl->id.name, w->name, index)) {
+			struct sst_enum *e = (void *)kctl->private_value;
+			e->w = w;
+		}
+		if (ret < 0) {
+			up_read(&card->controls_rwsem);
+			return ret;
+		}
+	}
+	up_read(&card->controls_rwsem);
+	return 0;
+}
+
+/**
+ * sst_fill_linked_widgets - fill the parent pointer for the linked widget
+ */
+static void sst_fill_linked_widgets(struct snd_soc_platform *platform,
+						struct sst_ids *ids)
+{
+	struct snd_soc_dapm_widget *w;
+	struct snd_soc_dapm_context *dapm = &platform->dapm;
+
+	unsigned int len = strlen(ids->parent_wname);
+	list_for_each_entry(w, &dapm->card->widgets, list) {
+		if (!strncmp(ids->parent_wname, w->name, len)) {
+			ids->parent_w = w;
+			break;
+		}
+	}
+}
+
+/**
+ * sst_map_modules_to_pipe - fill algo/gains list for all pipes
+ */
+static int sst_map_modules_to_pipe(struct snd_soc_platform *platform)
+{
+	struct snd_soc_dapm_widget *w;
+	struct snd_soc_dapm_context *dapm = &platform->dapm;
+	int ret = 0;
+
+	list_for_each_entry(w, &dapm->card->widgets, list) {
+		if (w->platform && is_sst_dapm_widget(w) && (w->priv)) {
+			struct sst_ids *ids = w->priv;
+
+			pr_debug("widget type=%d name=%s\n", w->id, w->name);
+			INIT_LIST_HEAD(&ids->algo_list);
+			INIT_LIST_HEAD(&ids->gain_list);
+			ret = sst_fill_widget_module_info(w, platform);
+			if (ret < 0)
+				return ret;
+			/* fill linked widgets */
+			if (ids->parent_wname !=  NULL)
+				sst_fill_linked_widgets(platform, ids);
+		}
+	}
+	return 0;
+}
+
+int sst_dsp_init_v2_dpcm(struct snd_soc_platform *platform)
+{
+	int i, ret = 0;
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+
+	sst->byte_stream = devm_kzalloc(platform->dev,
+					SST_MAX_BIN_BYTES, GFP_KERNEL);
+	if (!sst->byte_stream) {
+		pr_err("%s: kzalloc failed\n", __func__);
+		return -ENOMEM;
+	}
+	sst->widget = devm_kzalloc(platform->dev,
+				   SST_NUM_WIDGETS * sizeof(*sst->widget),
+				   GFP_KERNEL);
+	if (!sst->widget) {
+		pr_err("%s: kzalloc failed\n", __func__);
+		return -ENOMEM;
+	}
+
+	snd_soc_dapm_new_controls(&platform->dapm, sst_dapm_widgets,
+			ARRAY_SIZE(sst_dapm_widgets));
+	snd_soc_dapm_add_routes(&platform->dapm, intercon,
+			ARRAY_SIZE(intercon));
+	snd_soc_dapm_new_widgets(platform->dapm.card);
+
+	for (i = 0; i < SST_NUM_GAINS; i++) {
+		sst_gains[i].mute = SST_GAIN_MUTE_DEFAULT;
+		sst_gains[i].l_gain = SST_GAIN_VOLUME_DEFAULT;
+		sst_gains[i].r_gain = SST_GAIN_VOLUME_DEFAULT;
+		sst_gains[i].ramp_duration = SST_GAIN_RAMP_DURATION_DEFAULT;
+	}
+
+	snd_soc_add_platform_controls(platform, sst_gain_controls,
+			ARRAY_SIZE(sst_gain_controls));
+
+	snd_soc_add_platform_controls(platform, sst_algo_controls,
+			ARRAY_SIZE(sst_algo_controls));
+	snd_soc_add_platform_controls(platform, sst_slot_controls,
+			ARRAY_SIZE(sst_slot_controls));
+	snd_soc_add_platform_controls(platform, sst_mux_controls,
+			ARRAY_SIZE(sst_mux_controls));
+	snd_soc_add_platform_controls(platform, sst_debug_controls,
+			ARRAY_SIZE(sst_debug_controls));
+	snd_soc_add_platform_controls(platform, sst_vad_enroll,
+			ARRAY_SIZE(sst_vad_enroll));
+
+	/* initialize the names of the probe points */
+	for (i = 0; i < ARRAY_SIZE(sst_probes); i++)
+		sst_probe_enum_texts[i] = sst_probes[i].name;
+
+	snd_soc_add_platform_controls(platform, sst_probe_controls,
+			ARRAY_SIZE(sst_probe_controls));
+
+	ret = sst_map_modules_to_pipe(platform);
+
+	return ret;
+}
diff --git a/sound/soc/intel/platform-libs/ipc_lib.h b/sound/soc/intel/platform-libs/ipc_lib.h
new file mode 100644
index 0000000..40ada7a
--- /dev/null
+++ b/sound/soc/intel/platform-libs/ipc_lib.h
@@ -0,0 +1,29 @@
+/*
+ *  ipc_lib.h - Intel MID Platform driver header file
+ *
+ *  Copyright (C) 2013 Intel Corp
+ *  Author: Lakshmi N Vinnakota <lakshmi.n.vinnakota@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *
+ */
+
+#ifndef __PLATFORMDRV_IPC_LIB_H__
+#define __PLATFORMDRV_IPC_LIB_H__
+
+struct sst_algo_int_control_v2;
+
+void sst_create_compr_vol_ipc(char *bytes, unsigned int type,
+		struct sst_algo_int_control_v2 *kdata);
+#endif
diff --git a/sound/soc/intel/platform-libs/ipc_lib_v2.c b/sound/soc/intel/platform-libs/ipc_lib_v2.c
new file mode 100644
index 0000000..681bbc8
--- /dev/null
+++ b/sound/soc/intel/platform-libs/ipc_lib_v2.c
@@ -0,0 +1,105 @@
+/*
+ *  ipc_lib_v2.c - Intel MID Platform Driver IPC wrappers for mrfld
+ *
+ *  Copyright (C) 2013 Intel Corp
+ *  Author: Lakshmi N Vinnakota <lakshmi.n.vinnakota@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *
+ */
+#include <sound/soc.h>
+#include <asm/platform_sst_audio.h>
+#include "../platform_ipc_v2.h"
+#include "../sst_platform.h"
+#include "../sst_platform_pvt.h"
+
+
+static inline void sst_fill_dsp_hdr(struct ipc_dsp_hdr *hdr, u8 index, u8 pipe,
+	u16 module, u16 cmd, u16 len)
+{
+	hdr->mod_index_id = index;
+	hdr->pipe_id = pipe;
+	hdr->mod_id = module;
+	hdr->cmd_id = cmd;
+	hdr->length = len;
+
+}
+
+static inline void sst_fill_byte_control_hdr(struct snd_sst_bytes_v2 *hdr,
+	u8 type, u8 msg, u8 block, u8 task, u8 pipe, u16 len)
+{
+	hdr->type = type;
+	hdr->ipc_msg = msg;
+	hdr->block = block;
+	hdr->task_id = task;
+	hdr->pipe_id = pipe;
+	hdr->rsvd = 0;
+	hdr->len = len;
+}
+
+#define SST_GAIN_V2_TIME_CONST 50
+
+void sst_create_compr_vol_ipc(char *bytes, unsigned int type,
+	struct sst_algo_int_control_v2 *kdata)
+{
+	struct snd_sst_gain_v2 gain1;
+	struct snd_sst_bytes_v2 byte_hdr;
+	struct ipc_dsp_hdr dsp_hdr;
+	char *tmp;
+	u16 len;
+	u8 ipc_msg;
+
+	/* Fill gain params */
+	gain1.gain_cell_num = 1;  /* num of gain cells to modify*/
+	gain1.cell_nbr_idx = kdata->instance_id; /* instance index */
+	gain1.cell_path_idx = kdata->pipe_id; /* pipe id */
+	gain1.module_id = kdata->module_id; /*module id */
+	gain1.left_cell_gain = kdata->value; /* left gain value in dB*/
+	gain1.right_cell_gain = kdata->value; /* same value as left in dB*/
+	/* set to default recommended value*/
+	gain1.gain_time_const = SST_GAIN_V2_TIME_CONST;
+
+	/* fill dsp header */
+	/* Get params format for vol ctrl lib, size 6 bytes :
+	 * u16 left_gain, u16 right_gain, u16 ramp
+	 */
+	memset(&dsp_hdr, 0, sizeof(dsp_hdr));
+	if (type == SND_SST_BYTES_GET) {
+		len = 6;
+		ipc_msg = IPC_GET_PARAMS;
+	} else {
+		len = sizeof(gain1);
+		ipc_msg = IPC_SET_PARAMS;
+	}
+
+	sst_fill_dsp_hdr(&dsp_hdr, 0, kdata->pipe_id, kdata->module_id,
+				IPC_IA_SET_GAIN_MRFLD, len);
+
+	/* fill byte control header */
+	memset(&byte_hdr, 0, sizeof(byte_hdr));
+	len = sizeof(dsp_hdr) + dsp_hdr.length;
+	sst_fill_byte_control_hdr(&byte_hdr, type, ipc_msg, 1,
+			SST_TASK_ID_MEDIA, kdata->pipe_id, len);
+
+	/* fill complete byte stream as ipc payload */
+	tmp = bytes;
+	memcpy(tmp, &byte_hdr, sizeof(byte_hdr));
+	memcpy((tmp + sizeof(byte_hdr)), &dsp_hdr, sizeof(dsp_hdr));
+	if (type != SND_SST_BYTES_GET)
+		memcpy((tmp + sizeof(byte_hdr) + sizeof(dsp_hdr)), &gain1,
+			sizeof(gain1));
+#ifdef DEBUG_HEX_DUMP_BYTES
+	print_hex_dump_bytes(__func__, DUMP_PREFIX_NONE, bytes, 32);
+#endif
+}
diff --git a/sound/soc/intel/platform-libs/probe_point_dpcm.c b/sound/soc/intel/platform-libs/probe_point_dpcm.c
new file mode 100644
index 0000000..bff107d
--- /dev/null
+++ b/sound/soc/intel/platform-libs/probe_point_dpcm.c
@@ -0,0 +1,172 @@
+/*
+ *  probe_point_dpcm.c - Intel MID probe definition
+ *
+ *  Copyright (C) 2014 Intel Corp
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+static const struct sst_probe_config sst_probes[] = {
+	/* TODO: get this struct from FW config data */
+	/* gain outputs  */
+	{ "media0_in gain", SST_PATH_INDEX_MEDIA0_IN, SST_MODULE_ID_GAIN_CELL, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "media1_in gain", SST_PATH_INDEX_MEDIA1_IN, SST_MODULE_ID_GAIN_CELL, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "media2_in gain", SST_PATH_INDEX_MEDIA2_IN, SST_MODULE_ID_GAIN_CELL, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "media3_in gain", SST_PATH_INDEX_MEDIA3_IN, SST_MODULE_ID_GAIN_CELL, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "pcm0_in gain", SST_PATH_INDEX_PCM0_IN, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "pcm1_in gain", SST_PATH_INDEX_PCM1_IN, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "pcm1_out gain", SST_PATH_INDEX_PCM1_OUT, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "pcm2_out gain", SST_PATH_INDEX_PCM2_OUT, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "voip_in gain", SST_PATH_INDEX_VOIP_IN, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "voip_out gain", SST_PATH_INDEX_VOIP_OUT, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "aware_out gain", SST_PATH_INDEX_AWARE_OUT, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "vad_out gain", SST_PATH_INDEX_VAD_OUT, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "hf_sns_out gain", SST_PATH_INDEX_HF_SNS_OUT, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "hf_out gain", SST_PATH_INDEX_HF_OUT, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "speech_out gain", SST_PATH_INDEX_SPEECH_OUT, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "txspeech_in gain", SST_PATH_INDEX_TX_SPEECH_IN, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "rxspeech_out gain", SST_PATH_INDEX_RX_SPEECH_OUT, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "speech_in gain", SST_PATH_INDEX_SPEECH_IN, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "media_loop1_out gain", SST_PATH_INDEX_MEDIA_LOOP1_OUT , SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "media_loop2_out gain", SST_PATH_INDEX_MEDIA_LOOP2_OUT , SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "tone_in gain", SST_PATH_INDEX_TONE_IN, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "codec_out0 gain", SST_PATH_INDEX_CODEC_OUT0, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "codec_out1 gain", SST_PATH_INDEX_CODEC_OUT1, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "bt_out gain", SST_PATH_INDEX_BT_OUT, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "fm_out gain", SST_PATH_INDEX_FM_OUT, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "modem_out gain", SST_PATH_INDEX_MODEM_OUT, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "codec_in0 gain", SST_PATH_INDEX_CODEC_IN0, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "codec_in1 gain", SST_PATH_INDEX_CODEC_IN1, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "bt_in gain", SST_PATH_INDEX_BT_IN, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "fm_in gain", SST_PATH_INDEX_FM_IN, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "modem_in gain", SST_PATH_INDEX_MODEM_IN, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "sprot_loop_out gain", SST_PATH_INDEX_SPROT_LOOP_OUT, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "sidetone_in", SST_PATH_INDEX_SIDETONE_IN, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+
+	/* SRC */
+	{ "media0_in src", SST_PATH_INDEX_MEDIA0_IN, SST_MODULE_ID_SRC, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "rxspeech_out src", SST_PATH_INDEX_RX_SPEECH_OUT, SST_MODULE_ID_SRC, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "txspeech_in src", SST_PATH_INDEX_TX_SPEECH_IN, SST_MODULE_ID_SRC, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "speech_out src", SST_PATH_INDEX_SPEECH_OUT, SST_MODULE_ID_SRC, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "speech_in src", SST_PATH_INDEX_SPEECH_IN, SST_MODULE_ID_SRC, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "hf_out src", SST_PATH_INDEX_HF_OUT, SST_MODULE_ID_SRC, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "hf_sns_out src", SST_PATH_INDEX_HF_SNS_OUT, SST_MODULE_ID_SRC, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "pcm1_out src", SST_PATH_INDEX_PCM1_OUT, SST_MODULE_ID_SRC, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "pcm2_out src", SST_PATH_INDEX_PCM2_OUT, SST_MODULE_ID_SRC, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "voip_in src", SST_PATH_INDEX_VOIP_IN, SST_MODULE_ID_SRC, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "voip_out src", SST_PATH_INDEX_VOIP_OUT, SST_MODULE_ID_SRC, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "aware_out src", SST_PATH_INDEX_AWARE_OUT, SST_MODULE_ID_SRC, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "vad_out src", SST_PATH_INDEX_VAD_OUT, SST_MODULE_ID_SRC, SST_TASK_SBA, { 1, 2, 1 } },
+
+	{ "media0_in downmix", SST_PATH_INDEX_MEDIA0_IN, SST_MODULE_ID_DOWNMIX, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "sprot_loop_out lpro", SST_PATH_INDEX_SPROT_LOOP_OUT, SST_MODULE_ID_SPROT, SST_TASK_SBA, { 1, 2, 1 } },
+
+	{ "voice_downlink nr", SST_PATH_INDEX_VOICE_DOWNLINK, SST_MODULE_ID_NR, SST_TASK_FBA_DL , { 1, 2, 1 } },
+	{ "voice_uplink nr", SST_PATH_INDEX_VOICE_UPLINK, SST_MODULE_ID_NR, SST_TASK_FBA_UL, { 1, 2, 1 } },
+	{ "voice_downlink bwx", SST_PATH_INDEX_VOICE_DOWNLINK, SST_MODULE_ID_BWX, SST_TASK_FBA_DL, { 1, 2, 1 } },
+	{ "voice_downlink drp", SST_PATH_INDEX_VOICE_DOWNLINK, SST_MODULE_ID_DRP, SST_TASK_FBA_DL, { 1, 2, 1 } },
+	{ "voice_uplink drp", SST_PATH_INDEX_VOICE_UPLINK, SST_MODULE_ID_DRP, SST_TASK_FBA_UL, { 1, 2, 1 } },
+	{ "voice_downlink ana", SST_PATH_INDEX_VOICE_DOWNLINK, SST_MODULE_ID_ANA, SST_TASK_FBA_DL, { 1, 2, 1 } },
+	{ "voice_uplink aec", SST_PATH_INDEX_VOICE_UPLINK, SST_MODULE_ID_AEC, SST_TASK_FBA_UL, { 1, 2, 1 } },
+	{ "voice_uplink nr_sns", SST_PATH_INDEX_VOICE_UPLINK, SST_MODULE_ID_NR_SNS, SST_TASK_FBA_UL, { 1, 2, 1 } },
+	{ "voice_uplink ser", SST_PATH_INDEX_VOICE_UPLINK, SST_MODULE_ID_SER, SST_TASK_FBA_UL, { 1, 2, 1 } },
+	{ "voice_uplink agc", SST_PATH_INDEX_VOICE_UPLINK, SST_MODULE_ID_AGC, SST_TASK_FBA_UL, { 1, 2, 1 } },
+	{ "voice_downlink cni", SST_PATH_INDEX_VOICE_DOWNLINK, SST_MODULE_ID_CNI, SST_TASK_FBA_DL, { 1, 2, 1 } },
+
+
+	{ "media_loop1_out mdrp", SST_PATH_INDEX_MEDIA_LOOP1_OUT , SST_MODULE_ID_MDRP, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "media_loop2_out mdrp", SST_PATH_INDEX_MEDIA_LOOP2_OUT , SST_MODULE_ID_MDRP, SST_TASK_SBA, { 1, 2, 1 } },
+
+	{ "media_loop1_out fir_stereo", SST_PATH_INDEX_MEDIA_LOOP1_OUT , SST_MODULE_ID_FIR_24, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "media_loop2_out fir_stereo", SST_PATH_INDEX_MEDIA_LOOP2_OUT , SST_MODULE_ID_FIR_24, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "media_loop1_out iir_stereo", SST_PATH_INDEX_MEDIA_LOOP1_OUT , SST_MODULE_ID_IIR_24, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "media_loop2_out iir_stereo", SST_PATH_INDEX_MEDIA_LOOP2_OUT , SST_MODULE_ID_IIR_24, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "sidetone_in iir_stereo", SST_PATH_INDEX_SIDETONE_IN, SST_MODULE_ID_IIR_24, SST_TASK_SBA, { 1, 2, 1 } },
+
+	/* ASRC */
+	{ "modem_out asrc", SST_PATH_INDEX_MODEM_OUT, SST_MODULE_ID_ASRC, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "modem_in asrc", SST_PATH_INDEX_MODEM_IN, SST_MODULE_ID_ASRC, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "bt_out asrc", SST_PATH_INDEX_BT_OUT, SST_MODULE_ID_ASRC, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "bt_in asrc", SST_PATH_INDEX_BT_IN, SST_MODULE_ID_ASRC, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "fm_out asrc", SST_PATH_INDEX_FM_OUT, SST_MODULE_ID_ASRC, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "fm_in asrc", SST_PATH_INDEX_FM_IN, SST_MODULE_ID_ASRC, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "codec_out0 asrc", SST_PATH_INDEX_CODEC_OUT0, SST_MODULE_ID_ASRC, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "codec_out1 asrc", SST_PATH_INDEX_CODEC_OUT1, SST_MODULE_ID_ASRC, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "codec_in0 asrc", SST_PATH_INDEX_CODEC_IN0, SST_MODULE_ID_ASRC, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "codec_in1 asrc", SST_PATH_INDEX_CODEC_IN1, SST_MODULE_ID_ASRC, SST_TASK_SBA, { 1, 2, 1 } },
+
+	{ "tone_in tone_gen", SST_PATH_INDEX_TONE_IN, SST_MODULE_ID_TONE_GEN, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "hf_sns_out bmf", SST_PATH_INDEX_HF_SNS_OUT, SST_MODULE_ID_BMF, SST_TASK_FBA_UL, { 1, 2, 1 } },
+	{ "hf_out edl", SST_PATH_INDEX_HF_OUT, SST_MODULE_ID_EDL, SST_TASK_FBA_UL, { 1, 2, 1 } },
+	{ "voice_downlink glc", SST_PATH_INDEX_VOICE_DOWNLINK, SST_MODULE_ID_GLC, SST_TASK_FBA_DL, { 1, 2, 1 } },
+	{ "voice_downlink fir", SST_PATH_INDEX_VOICE_DOWNLINK, SST_MODULE_ID_FIR_16, SST_TASK_FBA_DL, { 1, 2, 1 } },
+	{ "voice_uplink fir", SST_PATH_INDEX_VOICE_UPLINK, SST_MODULE_ID_FIR_16, SST_TASK_FBA_UL, { 1, 2, 1 } },
+	{ "hf_sns_out fir", SST_PATH_INDEX_HF_SNS_OUT, SST_MODULE_ID_FIR_16, SST_TASK_FBA_UL, { 1, 2, 1 } },
+	{ "voice_downlink iir", SST_PATH_INDEX_VOICE_DOWNLINK, SST_MODULE_ID_IIR_16, SST_TASK_FBA_DL, { 1, 2, 1 } },
+	{ "voice_uplink iir", SST_PATH_INDEX_VOICE_UPLINK, SST_MODULE_ID_IIR_16, SST_TASK_FBA_UL, { 1, 2, 1 } },
+	{ "hf_sns_out iir", SST_PATH_INDEX_HF_SNS_OUT, SST_MODULE_ID_IIR_16, SST_TASK_FBA_UL, { 1, 2, 1 } },
+	{ "voice_uplink dnr", SST_PATH_INDEX_VOICE_UPLINK, SST_MODULE_ID_DNR, SST_TASK_FBA_UL, { 1, 2, 1 } },
+	{ "voice_uplink cni", SST_PATH_INDEX_VOICE_UPLINK, SST_MODULE_ID_CNI_TX, SST_TASK_FBA_UL, { 1, 2, 1 } },
+	{ "hf_out ref_line", SST_PATH_INDEX_HF_OUT, SST_MODULE_ID_REF_LINE, SST_TASK_FBA_UL, { 1, 2, 1 } },
+
+	{ "media0_in volume", SST_PATH_INDEX_MEDIA0_IN, SST_MODULE_ID_VOLUME, SST_TASK_MMX, { 1, 2, 1 } },
+
+	/* DCR */
+	{ "modem_in dcr", SST_PATH_INDEX_MODEM_IN, SST_MODULE_ID_FILT_DCR, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "bt_in dcr", SST_PATH_INDEX_BT_IN, SST_MODULE_ID_FILT_DCR, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "fm_in dcr", SST_PATH_INDEX_FM_IN, SST_MODULE_ID_FILT_DCR, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "codec_in0 dcr", SST_PATH_INDEX_CODEC_IN0, SST_MODULE_ID_FILT_DCR, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "codec_in1 dcr", SST_PATH_INDEX_CODEC_IN1, SST_MODULE_ID_FILT_DCR, SST_TASK_SBA, { 1, 2, 1 } },
+
+	/* Log */
+	{ "modem_out log", SST_PATH_INDEX_MODEM_OUT, SST_MODULE_ID_LOG, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "modem_in log", SST_PATH_INDEX_MODEM_IN, SST_MODULE_ID_LOG, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "bt_out log", SST_PATH_INDEX_BT_OUT, SST_MODULE_ID_LOG, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "bt_in log", SST_PATH_INDEX_BT_IN, SST_MODULE_ID_LOG, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "fm_in log", SST_PATH_INDEX_FM_IN, SST_MODULE_ID_LOG, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "fm_out log", SST_PATH_INDEX_FM_OUT, SST_MODULE_ID_LOG, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "codec_out0 log", SST_PATH_INDEX_CODEC_OUT0, SST_MODULE_ID_LOG, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "codec_in0 log", SST_PATH_INDEX_CODEC_IN0, SST_MODULE_ID_LOG, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "voice_downlink log", SST_PATH_INDEX_VOICE_DOWNLINK, SST_MODULE_ID_LOG, SST_TASK_FBA_DL, { 1, 2, 1 } },
+	{ "voice_uplink log", SST_PATH_INDEX_VOICE_UPLINK, SST_MODULE_ID_LOG, SST_TASK_FBA_UL, { 1, 2, 1 } },
+	{ "hf_out log", SST_PATH_INDEX_HF_OUT, SST_MODULE_ID_LOG, SST_TASK_FBA_UL, { 1, 2, 1 } },
+	{ "hf_sns_out log", SST_PATH_INDEX_HF_SNS_OUT, SST_MODULE_ID_LOG, SST_TASK_FBA_UL, { 1, 2, 1 } },
+
+	/* Decoder */
+	{ "media0_in pcm", SST_PATH_INDEX_MEDIA0_IN, SST_MODULE_ID_PCM, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "media0_in mp3", SST_PATH_INDEX_MEDIA0_IN, SST_MODULE_ID_MP3, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "media0_in mp24", SST_PATH_INDEX_MEDIA0_IN, SST_MODULE_ID_MP24, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "media0_in aac", SST_PATH_INDEX_MEDIA0_IN, SST_MODULE_ID_AAC, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "media0_in aacp", SST_PATH_INDEX_MEDIA0_IN, SST_MODULE_ID_AACP, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "media0_in eaacp", SST_PATH_INDEX_MEDIA0_IN, SST_MODULE_ID_EAACP, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "media0_in wma9", SST_PATH_INDEX_MEDIA0_IN, SST_MODULE_ID_WMA9, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "media0_in wma10", SST_PATH_INDEX_MEDIA0_IN, SST_MODULE_ID_WMA10, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "media0_in wma10p", SST_PATH_INDEX_MEDIA0_IN, SST_MODULE_ID_WMA10P, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "media0_in ra", SST_PATH_INDEX_MEDIA0_IN, SST_MODULE_ID_RA, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "media0_in ddac3", SST_PATH_INDEX_MEDIA0_IN, SST_MODULE_ID_DDAC3, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "media0_in true_hd", SST_PATH_INDEX_MEDIA0_IN, SST_MODULE_ID_TRUE_HD, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "media0_in hd_plus", SST_PATH_INDEX_MEDIA0_IN, SST_MODULE_ID_HD_PLUS, SST_TASK_MMX, { 1, 2, 1 } },
+
+	/* Effects */
+	{ "media0_in bass_boost", SST_PATH_INDEX_MEDIA0_IN, SST_MODULE_ID_BASS_BOOST, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "media0_in stereo_wdng", SST_PATH_INDEX_MEDIA0_IN, SST_MODULE_ID_STEREO_WDNG, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "media0_in av_removal", SST_PATH_INDEX_MEDIA0_IN, SST_MODULE_ID_AV_REMOVAL, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "media0_in mic_eq", SST_PATH_INDEX_MEDIA0_IN, SST_MODULE_ID_MIC_EQ, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "media0_in spl", SST_PATH_INDEX_MEDIA0_IN, SST_MODULE_ID_SPL, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "media0_in vtsv", SST_PATH_INDEX_MEDIA0_IN, SST_MODULE_ID_ALGO_VTSV, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "media0_in virtualizer", SST_PATH_INDEX_MEDIA0_IN, SST_MODULE_ID_VIRTUALIZER, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "media0_in visualization", SST_PATH_INDEX_MEDIA0_IN, SST_MODULE_ID_VISUALIZATION, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "media0_in loudness_optimizer", SST_PATH_INDEX_MEDIA0_IN, SST_MODULE_ID_LOUDNESS_OPTIMIZER, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "media0_in reverberation", SST_PATH_INDEX_MEDIA0_IN, SST_MODULE_ID_REVERBERATION, SST_TASK_MMX, { 1, 2, 1 } },
+};
+
diff --git a/sound/soc/intel/platform-libs/sst_widgets.h b/sound/soc/intel/platform-libs/sst_widgets.h
new file mode 100644
index 0000000..00aecd9
--- /dev/null
+++ b/sound/soc/intel/platform-libs/sst_widgets.h
@@ -0,0 +1,352 @@
+/*
+ *  sst_widgets.h - Intel helpers to generate FW widgets
+ *
+ *  Copyright (C) 2013 Intel Corp
+ *  Author: Omair Mohammed Abdullah <omair.m.abdullah@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#ifndef __SST_WIDGETS_H__
+#define __SST_WIDGETS_H__
+
+#include <sound/soc.h>
+#include <sound/tlv.h>
+
+#define SST_MODULE_GAIN 1
+#define SST_MODULE_ALGO 2
+
+#define SST_FMT_MONO 0
+#define SST_FMT_STEREO 3
+
+struct module {
+	struct snd_kcontrol *kctl;
+	struct list_head node;
+};
+
+struct sst_ids {
+	u16 location_id;
+	u16 module_id;
+	u8  task_id;
+	u8  format;
+	u8  reg;
+	const char *parent_wname;
+	struct snd_soc_dapm_widget *parent_w;
+	struct list_head algo_list;
+	struct list_head gain_list;
+	const struct sst_pcm_format *pcm_fmt;
+};
+
+
+#define SST_AIF_IN(wname, wevent)							\
+{	.id = snd_soc_dapm_aif_in, .name = wname, .sname = NULL,			\
+	.reg = SND_SOC_NOPM, .shift = 0,					\
+	.on_val = 1, .off_val = 0,							\
+	.event = wevent, .event_flags = SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD,	\
+	.priv = (void *)&(struct sst_ids) { .task_id = 0, .location_id = 0 }		\
+}
+
+#define SST_AIF_OUT(wname, wevent)							\
+{	.id = snd_soc_dapm_aif_out, .name = wname, .sname = NULL,			\
+	.reg = SND_SOC_NOPM, .shift = 0, 					\
+	.on_val = 1, .off_val = 0,							\
+	.event = wevent, .event_flags = SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD,	\
+	.priv = (void *)&(struct sst_ids) { .task_id = 0, .location_id = 0 }		\
+}
+
+#define SST_INPUT(wname, wevent)							\
+{	.id = snd_soc_dapm_input, .name = wname, .sname = NULL,				\
+	.reg = SND_SOC_NOPM, .shift = 0, 					\
+	.on_val = 1, .off_val = 0,							\
+	.event = wevent, .event_flags = SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD,	\
+	.priv = (void *)&(struct sst_ids) { .task_id = 0, .location_id = 0 }		\
+}
+
+#define SST_OUTPUT(wname, wevent)							\
+{	.id = snd_soc_dapm_output, .name = wname, .sname = NULL,			\
+	.reg = SND_SOC_NOPM, .shift = 0, 					\
+	.on_val = 1, .off_val = 0,							\
+	.event = wevent, .event_flags = SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD,	\
+	.priv = (void *)&(struct sst_ids) { .task_id = 0, .location_id = 0 }		\
+}
+
+#define SST_DAPM_OUTPUT(wname, wloc_id, wtask_id, wformat, wevent)                      \
+{	.id = snd_soc_dapm_output, .name = wname, .sname = NULL,                        \
+	.reg = SND_SOC_NOPM, .shift = 0,                                    \
+	.on_val = 1, .off_val = 0,							\
+	.event = wevent, .event_flags = SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD,   \
+	.priv = (void *)&(struct sst_ids) { .location_id = wloc_id, .task_id = wtask_id,\
+						.pcm_fmt = wformat, }			\
+}
+
+#define SST_PATH(wname, wtask, wloc_id, wevent, wflags)					\
+{	.id = snd_soc_dapm_pga, .name = wname, .reg = SND_SOC_NOPM, .shift = 0,		\
+	 .kcontrol_news = NULL, .num_kcontrols = 0,				\
+	.on_val = 1, .off_val = 0,							\
+	.event = wevent, .event_flags = wflags,						\
+	.priv = (void *)&(struct sst_ids) { .task_id = wtask, .location_id = wloc_id, }	\
+}
+
+#define SST_LINKED_PATH(wname, wtask, wloc_id, linked_wname, wevent, wflags)		\
+{	.id = snd_soc_dapm_pga, .name = wname, .reg = SND_SOC_NOPM, .shift = 0,		\
+	 .kcontrol_news = NULL, .num_kcontrols = 0,				\
+	.on_val = 1, .off_val = 0,							\
+	.event = wevent, .event_flags = wflags,						\
+	.priv = (void *)&(struct sst_ids) { .task_id = wtask, .location_id = wloc_id,	\
+					.parent_wname = linked_wname}			\
+}
+
+#define SST_PATH_MEDIA_LOOP(wname, wtask, wloc_id, wformat, wevent, wflags)             \
+{	.id = snd_soc_dapm_pga, .name = wname, .reg = SND_SOC_NOPM, .shift = 0,         \
+	 .kcontrol_news = NULL, .num_kcontrols = 0,                         \
+	.event = wevent, .event_flags = wflags,                                         \
+	.priv = (void *)&(struct sst_ids) { .task_id = wtask, .location_id = wloc_id,	\
+					    .format = wformat,}				\
+}
+
+/* output is triggered before input */
+#define SST_PATH_INPUT(name, task_id, loc_id, event)					\
+	SST_PATH(name, task_id, loc_id, event, SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD)
+
+#define SST_PATH_LINKED_INPUT(name, task_id, loc_id, linked_wname, event)		\
+	SST_LINKED_PATH(name, task_id, loc_id, linked_wname, event,			\
+					SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD)
+
+#define SST_PATH_OUTPUT(name, task_id, loc_id, event)					\
+	SST_PATH(name, task_id, loc_id, event, SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD)
+
+#define SST_PATH_LINKED_OUTPUT(name, task_id, loc_id, linked_wname, event)		\
+	SST_LINKED_PATH(name, task_id, loc_id, linked_wname, event,			\
+					SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD)
+
+#define SST_PATH_MEDIA_LOOP_OUTPUT(name, task_id, loc_id, format, event)		\
+	SST_PATH_MEDIA_LOOP(name, task_id, loc_id, format, event, SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD)
+
+
+#define SST_SWM_MIXER(wname, wreg, wtask, wloc_id, wcontrols, wevent)			\
+{	.id = snd_soc_dapm_mixer, .name = wname, .reg = SND_SOC_NOPM, .shift = 0,	\
+	 .kcontrol_news = wcontrols, .num_kcontrols = ARRAY_SIZE(wcontrols),\
+	.event = wevent, .event_flags = SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD |	\
+					SND_SOC_DAPM_POST_REG,				\
+	.priv = (void *)&(struct sst_ids) { .task_id = wtask, .location_id = wloc_id,	\
+					    .reg = wreg }				\
+}
+
+enum sst_gain_kcontrol_type {
+	SST_GAIN_TLV,
+	SST_GAIN_MUTE,
+	SST_GAIN_RAMP_DURATION,
+};
+
+struct sst_gain_mixer_control {
+	bool stereo;
+	enum sst_gain_kcontrol_type type;
+	struct sst_gain_value *gain_val;
+	int max;
+	int min;
+	u16 instance_id;
+	u16 module_id;
+	u16 pipe_id;
+	u16 task_id;
+	char pname[44];
+	struct snd_soc_dapm_widget *w;
+};
+
+struct sst_gain_value {
+	u16 ramp_duration;
+	s16 l_gain;
+	s16 r_gain;
+	bool mute;
+};
+
+#define SST_GAIN_VOLUME_DEFAULT		(-1440)
+#define SST_GAIN_RAMP_DURATION_DEFAULT	5 /* timeconstant */
+#define SST_GAIN_MUTE_DEFAULT		true
+
+#define SST_GAIN_KCONTROL_TLV(xname, xhandler_get, xhandler_put, \
+			      xmod, xpipe, xinstance, xtask, tlv_array, xgain_val, \
+			      xmin, xmax, xpname) \
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \
+		  SNDRV_CTL_ELEM_ACCESS_READWRITE, \
+	.tlv.p = (tlv_array), \
+	.info = sst_gain_ctl_info,\
+	.get = xhandler_get, .put = xhandler_put, \
+	.private_value = (unsigned long)&(struct sst_gain_mixer_control) \
+	{ .stereo = true, .max = xmax, .min = xmin, .type = SST_GAIN_TLV, \
+	  .module_id = xmod, .pipe_id = xpipe, .task_id = xtask,\
+	  .instance_id = xinstance, .gain_val = xgain_val, .pname = xpname}
+
+#define SST_GAIN_KCONTROL_INT(xname, xhandler_get, xhandler_put, \
+			      xmod, xpipe, xinstance, xtask, xtype, xgain_val, \
+			      xmin, xmax, xpname) \
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = sst_gain_ctl_info, \
+	.get = xhandler_get, .put = xhandler_put, \
+	.private_value = (unsigned long)&(struct sst_gain_mixer_control) \
+	{ .stereo = false, .max = xmax, .min = xmin, .type = xtype, \
+	  .module_id = xmod, .pipe_id = xpipe, .task_id = xtask,\
+	  .instance_id = xinstance, .gain_val = xgain_val, .pname =  xpname}
+
+#define SST_GAIN_KCONTROL_BOOL(xname, xhandler_get, xhandler_put,\
+			       xmod, xpipe, xinstance, xtask, xgain_val, xpname) \
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = snd_soc_info_bool_ext, \
+	.get = xhandler_get, .put = xhandler_put, \
+	.private_value = (unsigned long)&(struct sst_gain_mixer_control) \
+	{ .stereo = false, .type = SST_GAIN_MUTE, \
+	  .module_id = xmod, .pipe_id = xpipe, .task_id = xtask,\
+	  .instance_id = xinstance, .gain_val = xgain_val, .pname = xpname}
+
+#define SST_CONTROL_NAME(xpname, xmname, xinstance, xtype) \
+	xpname " " xmname " " #xinstance " " xtype
+
+#define SST_COMBO_CONTROL_NAME(xpname, xmname, xinstance, xtype, xsubmodule) \
+	xpname " " xmname " " #xinstance " " xtype " " xsubmodule
+
+/*
+ * 3 Controls for each Gain module
+ * e.g.	- pcm0_in gain 0 volume
+ *	- pcm0_in gain 0 rampduration
+ *	- pcm0_in gain 0 mute
+ */
+#define SST_GAIN_KCONTROLS(xpname, xmname, xmin_gain, xmax_gain, xmin_tc, xmax_tc, \
+			   xhandler_get, xhandler_put, \
+			   xmod, xpipe, xinstance, xtask, tlv_array, xgain_val) \
+	{ SST_GAIN_KCONTROL_INT(SST_CONTROL_NAME(xpname, xmname, xinstance, "rampduration"), \
+		xhandler_get, xhandler_put, xmod, xpipe, xinstance, xtask, SST_GAIN_RAMP_DURATION, \
+		xgain_val, xmin_tc, xmax_tc, xpname) }, \
+	{ SST_GAIN_KCONTROL_BOOL(SST_CONTROL_NAME(xpname, xmname, xinstance, "mute"), \
+		xhandler_get, xhandler_put, xmod, xpipe, xinstance, xtask, \
+		xgain_val, xpname) } ,\
+	{ SST_GAIN_KCONTROL_TLV(SST_CONTROL_NAME(xpname, xmname, xinstance, "volume"), \
+		xhandler_get, xhandler_put, xmod, xpipe, xinstance, xtask, tlv_array, \
+		xgain_val, xmin_gain, xmax_gain, xpname) }
+
+#define SST_GAIN_TC_MIN		5
+#define SST_GAIN_TC_MAX		5000
+#define SST_GAIN_MIN_VALUE	-1440 /* in 0.1 DB units */
+#define SST_GAIN_MAX_VALUE	360
+
+enum sst_algo_kcontrol_type {
+	SST_ALGO_PARAMS,
+	SST_ALGO_BYPASS,
+};
+
+struct sst_algo_control {
+	enum sst_algo_kcontrol_type type;
+	int max;
+	u16 module_id;
+	u16 pipe_id;
+	u16 task_id;
+	u16 cmd_id;
+	bool bypass;
+	unsigned char *params;
+	struct snd_soc_dapm_widget *w;
+};
+
+/* size of the control = size of params + size of length field */
+#define SST_ALGO_CTL_VALUE(xcount, xtype, xpipe, xmod, xtask, xcmd)			\
+	(struct sst_algo_control){							\
+		.max = xcount + sizeof(u16), .type = xtype, .module_id = xmod,			\
+		.pipe_id = xpipe, .task_id = xtask, .cmd_id = xcmd,			\
+	}
+
+#define SST_ALGO_KCONTROL(xname, xcount, xmod, xpipe,					\
+			  xtask, xcmd, xtype, xinfo, xget, xput)			\
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,						\
+	.name =  xname,									\
+	.info = xinfo, .get = xget, .put = xput,					\
+	.private_value = (unsigned long)&						\
+			SST_ALGO_CTL_VALUE(xcount, xtype, xpipe,			\
+					   xmod, xtask, xcmd),				\
+}
+
+#define SST_ALGO_KCONTROL_BYTES(xpname, xmname, xcount, xmod,				\
+				xpipe, xinstance, xtask, xcmd)				\
+	SST_ALGO_KCONTROL(SST_CONTROL_NAME(xpname, xmname, xinstance, "params"),	\
+			  xcount, xmod, xpipe, xtask, xcmd, SST_ALGO_PARAMS,		\
+			  sst_algo_bytes_ctl_info,					\
+			  sst_algo_control_get, sst_algo_control_set)
+
+#define SST_ALGO_KCONTROL_BOOL(xpname, xmname, xmod, xpipe, xinstance, xtask)		\
+	SST_ALGO_KCONTROL(SST_CONTROL_NAME(xpname, xmname, xinstance, "bypass"),	\
+			  0, xmod, xpipe, xtask, 0, SST_ALGO_BYPASS,			\
+			  snd_soc_info_bool_ext,					\
+			  sst_algo_control_get, sst_algo_control_set)
+
+#define SST_ALGO_BYPASS_PARAMS(xpname, xmname, xcount, xmod, xpipe,			\
+				xinstance, xtask, xcmd)					\
+	SST_ALGO_KCONTROL_BOOL(xpname, xmname, xmod, xpipe, xinstance, xtask),		\
+	SST_ALGO_KCONTROL_BYTES(xpname, xmname, xcount, xmod, xpipe, xinstance, xtask, xcmd)
+
+#define SST_COMBO_ALGO_KCONTROL_BYTES(xpname, xmname, xsubmod, xcount, xmod,		\
+				      xpipe, xinstance, xtask, xcmd)			\
+	SST_ALGO_KCONTROL(SST_COMBO_CONTROL_NAME(xpname, xmname, xinstance, "params",	\
+						 xsubmod),				\
+			  xcount, xmod, xpipe, xtask, xcmd, SST_ALGO_PARAMS,		\
+			  sst_algo_bytes_ctl_info,					\
+			  sst_algo_control_get, sst_algo_control_set)
+
+
+struct sst_enum {
+	bool tx;
+	unsigned short reg;
+	unsigned int max;
+	const char * const *texts;
+	struct snd_soc_dapm_widget *w;
+};
+
+/* only 4 slots/channels supported atm */
+#define SST_SSP_SLOT_ENUM(s_ch_no, is_tx, xtexts) \
+	(struct sst_enum){ .reg = s_ch_no, .tx = is_tx, .max = 4+1, .texts = xtexts, }
+
+#define SST_SLOT_CTL_NAME(xpname, xmname, s_ch_name) \
+	xpname " " xmname " " s_ch_name
+
+#define SST_SSP_SLOT_CTL(xpname, xmname, s_ch_name, s_ch_no, is_tx, xtexts, xget, xput) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = SST_SLOT_CTL_NAME(xpname, xmname, s_ch_name), \
+	.info = sst_slot_enum_info, \
+	.get = xget, .put = xput, \
+	.private_value = (unsigned long)&SST_SSP_SLOT_ENUM(s_ch_no, is_tx, xtexts), \
+}
+
+#define SST_MUX_CTL_NAME(xpname, xinstance) \
+	xpname " " #xinstance
+
+#define SST_SSP_MUX_ENUM(xreg, xshift, xtexts) \
+	(struct soc_enum){ .reg = xreg, .texts = xtexts, .shift_l = xshift, \
+			   .shift_r = xshift, .items = ARRAY_SIZE(xtexts), }
+
+#define SST_SSP_MUX_CTL(xpname, xinstance, xreg, xshift, xtexts, xget, xput) \
+	SOC_DAPM_ENUM_EXT(SST_MUX_CTL_NAME(xpname, xinstance), \
+			  SST_SSP_MUX_ENUM(xreg, xshift, xtexts), \
+			  xget, xput)
+
+struct sst_probe_value {
+	unsigned int val;
+	const struct soc_enum *p_enum;
+};
+
+#define SST_PROBE_CTL_NAME(dir, num, type) \
+	dir #num " " type
+
+#define SST_PROBE_ENUM(xname, xenum, xhandler_get, xhandler_put) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = sst_probe_enum_info, \
+	.get = xhandler_get, .put = xhandler_put, \
+	.private_value = (unsigned long)&(struct sst_probe_value) \
+	{ .val = 0, .p_enum = &xenum } }
+
+#endif
diff --git a/sound/soc/intel/platform_ipc_v2.h b/sound/soc/intel/platform_ipc_v2.h
new file mode 100644
index 0000000..09f5c5b
--- /dev/null
+++ b/sound/soc/intel/platform_ipc_v2.h
@@ -0,0 +1,690 @@
+/*
+*  platform_ipc_v2.h - Intel MID Platform driver FW IPC definitions
+*
+*  Copyright (C) 2008-10 Intel Corporation
+*  Author:	Vinod Koul <vinod.koul@intel.com>
+*		Harsha Priya <priya.harsha@intel.com>
+*		Dharageswari R <dharageswari.r@intel.com>
+*		KP Jeeja <jeeja.kp@intel.com>
+*  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; version 2 of the License.
+*
+*  This program is distributed in the hope that it will be useful, but
+*  WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*  General Public License for more details.
+*
+* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+*
+*  This driver exposes the audio engine functionalities to the ALSA
+*	and middleware.
+*  This file has definitions shared between the firmware and driver
+*/
+#ifndef __PLATFORM_IPC_V2_H__
+#define __PLATFORM_IPC_V2_H__
+
+#define MAX_DBG_RW_BYTES 80
+#define MAX_NUM_SCATTER_BUFFERS 8
+#define MAX_LOOP_BACK_DWORDS 8
+/* IPC base address and mailbox, timestamp offsets */
+#define SST_MAILBOX_SIZE 0x0400
+#define SST_MAILBOX_SEND 0x0000
+#define SST_TIME_STAMP 0x1800
+#define SST_TIME_STAMP_MRFLD 0x680
+#define SST_TIME_STAMP_BYT 0x800
+#define SST_RESERVED_OFFSET 0x1A00
+#define SST_SCU_LPE_MAILBOX 0x1000
+#define SST_LPE_SCU_MAILBOX 0x1400
+#define SST_SCU_LPE_LOG_BUF (SST_SCU_LPE_MAILBOX+16)
+#define PROCESS_MSG 0x80
+
+/* Message ID's for IPC messages */
+/* Bits B7: SST or IA/SC ; B6-B4: Msg Category; B3-B0: Msg Type */
+
+/* I2L Firmware/Codec Download msgs */
+#define IPC_IA_PREP_LIB_DNLD 0x01
+#define IPC_IA_LIB_DNLD_CMPLT 0x02
+#define IPC_IA_GET_FW_VERSION 0x04
+#define IPC_IA_GET_FW_BUILD_INF 0x05
+#define IPC_IA_GET_FW_INFO 0x06
+#define IPC_IA_GET_FW_CTXT 0x07
+#define IPC_IA_SET_FW_CTXT 0x08
+#define IPC_IA_PREPARE_SHUTDOWN 0x31
+/* I2L Codec Config/control msgs */
+#define IPC_PREP_D3 0x10
+#define IPC_IA_SET_CODEC_PARAMS 0x10
+#define IPC_IA_GET_CODEC_PARAMS 0x11
+#define IPC_IA_SET_PPP_PARAMS 0x12
+#define IPC_IA_GET_PPP_PARAMS 0x13
+#define IPC_SST_PERIOD_ELAPSED_MRFLD 0xA
+#define IPC_SST_VB_RESET 0x28
+#define IPC_IA_ALG_PARAMS 0x1A
+#define IPC_IA_TUNING_PARAMS 0x1B
+#define IPC_IA_SET_RUNTIME_PARAMS 0x1C
+#define IPC_IA_SET_PARAMS 0x1
+#define IPC_IA_GET_PARAMS 0x2
+
+#define IPC_EFFECTS_CREATE 0xE
+#define IPC_EFFECTS_DESTROY 0xF
+
+/* I2L Stream config/control msgs */
+#define IPC_IA_ALLOC_STREAM_MRFLD 0x2
+#define IPC_IA_ALLOC_STREAM 0x20 /* Allocate a stream ID */
+#define IPC_IA_FREE_STREAM_MRFLD 0x03
+#define IPC_IA_FREE_STREAM 0x21 /* Free the stream ID */
+#define IPC_IA_SET_STREAM_PARAMS 0x22
+#define IPC_IA_SET_STREAM_PARAMS_MRFLD 0x12
+#define IPC_IA_GET_STREAM_PARAMS 0x23
+#define IPC_IA_PAUSE_STREAM 0x24
+#define IPC_IA_PAUSE_STREAM_MRFLD 0x4
+#define IPC_IA_RESUME_STREAM 0x25
+#define IPC_IA_RESUME_STREAM_MRFLD 0x5
+#define IPC_IA_DROP_STREAM 0x26
+#define IPC_IA_DROP_STREAM_MRFLD 0x07
+#define IPC_IA_DRAIN_STREAM 0x27 /* Short msg with str_id */
+#define IPC_IA_DRAIN_STREAM_MRFLD 0x8
+#define IPC_IA_CONTROL_ROUTING 0x29
+#define IPC_IA_VTSV_UPDATE_MODULES 0x20
+#define IPC_IA_VTSV_DETECTED 0x21
+
+#define IPC_IA_START_STREAM_MRFLD 0X06
+#define IPC_IA_START_STREAM 0x30 /* Short msg with str_id */
+
+#define IPC_IA_SET_GAIN_MRFLD 0x21
+/* Debug msgs */
+#define IPC_IA_DBG_MEM_READ 0x40
+#define IPC_IA_DBG_MEM_WRITE 0x41
+#define IPC_IA_DBG_LOOP_BACK 0x42
+#define IPC_IA_DBG_LOG_ENABLE 0x45
+#define IPC_IA_DBG_SET_PROBE_PARAMS 0x47
+
+/* L2I Firmware/Codec Download msgs */
+#define IPC_IA_FW_INIT_CMPLT 0x81
+#define IPC_IA_FW_INIT_CMPLT_MRFLD 0x01
+#define IPC_IA_FW_ASYNC_ERR_MRFLD 0x11
+
+/* L2I Codec Config/control msgs */
+#define IPC_SST_FRAGMENT_ELPASED 0x90 /* Request IA more data */
+
+#define IPC_SST_BUF_UNDER_RUN 0x92 /* PB Under run and stopped */
+#define IPC_SST_BUF_OVER_RUN 0x93 /* CAP Under run and stopped */
+#define IPC_SST_DRAIN_END 0x94 /* PB Drain complete and stopped */
+#define IPC_SST_CHNGE_SSP_PARAMS 0x95 /* PB SSP parameters changed */
+#define IPC_SST_STREAM_PROCESS_FATAL_ERR 0x96/* error in processing a stream */
+#define IPC_SST_PERIOD_ELAPSED 0x97 /* period elapsed */
+
+#define IPC_SST_ERROR_EVENT 0x99 /* Buffer over run occurred */
+/* L2S messages */
+#define IPC_SC_DDR_LINK_UP 0xC0
+#define IPC_SC_DDR_LINK_DOWN 0xC1
+#define IPC_SC_SET_LPECLK_REQ 0xC2
+#define IPC_SC_SSP_BIT_BANG 0xC3
+
+/* L2I Error reporting msgs */
+#define IPC_IA_MEM_ALLOC_FAIL 0xE0
+#define IPC_IA_PROC_ERR 0xE1 /* error in processing a
+					stream can be used by playback and
+					capture modules */
+
+/* L2I Debug msgs */
+#define IPC_IA_PRINT_STRING 0xF0
+
+/* Buffer under-run */
+#define IPC_IA_BUF_UNDER_RUN_MRFLD 0x0B
+
+/* Mrfld specific defines:
+ * For asynchronous messages(INIT_CMPLT, PERIOD_ELAPSED, ASYNC_ERROR)
+ * received from FW, the format is:
+ *  - IPC High: pvt_id is set to zero. Always short message.
+ *  - msg_id is in lower 16-bits of IPC low payload.
+ *  - pipe_id is in higher 16-bits of IPC low payload for period_elapsed.
+ *  - error id is in higher 16-bits of IPC low payload for async errors.
+ */
+#define SST_ASYNC_DRV_ID 0
+
+/* Command Response or Acknowledge message to any IPC message will have
+ * same message ID and stream ID information which is sent.
+ * There is no specific Ack message ID. The data field is used as response
+ * meaning.
+ */
+
+/* SCU IPC for resetting & power gating the LPE through SCU */
+#define IPC_SCU_LPE_RESET 0xA3
+
+enum ackData {
+	IPC_ACK_SUCCESS = 0,
+	IPC_ACK_FAILURE,
+};
+
+enum ipc_ia_msg_id {
+	IPC_CMD = 1,		/*!< Task Control message ID */
+	IPC_SET_PARAMS = 2,/*!< Task Set param message ID */
+	IPC_GET_PARAMS = 3,	/*!< Task Get param message ID */
+	IPC_INVALID = 0xFF,	/*!<Task Get param message ID */
+};
+
+enum sst_codec_types {
+	/*  AUDIO/MUSIC	CODEC Type Definitions */
+	SST_CODEC_TYPE_UNKNOWN = 0,
+	SST_CODEC_TYPE_PCM,	/* Pass through Audio codec */
+	SST_CODEC_TYPE_MP3,
+	SST_CODEC_TYPE_MP24,
+	SST_CODEC_TYPE_AAC,
+	SST_CODEC_TYPE_AACP,
+	SST_CODEC_TYPE_eAACP,
+	SST_CODEC_TYPE_WMA9,
+	SST_CODEC_TYPE_WMA10,
+	SST_CODEC_TYPE_WMA10P,
+	SST_CODEC_TYPE_RA,
+	SST_CODEC_TYPE_DDAC3,
+	SST_CODEC_TYPE_STEREO_TRUE_HD,
+	SST_CODEC_TYPE_STEREO_HD_PLUS,
+
+	/*  VOICE CODEC Type Definitions */
+	SST_CODEC_TYPE_VOICE_PCM = 0x21, /* Pass through voice codec */
+};
+
+enum sst_algo_types {
+	SST_ALGO_SRC = 0x64,
+	SST_ALGO_MIXER = 0x65,
+	SST_ALGO_DOWN_MIXER = 0x66,
+	SST_ALGO_VTSV = 0x73,
+	SST_ALGO_AUDCLASSIFIER = 0x80,
+	SST_ALGO_VOLUME_CONTROL = 0x92,
+	SST_ALGO_GEQ = 0x99,
+};
+
+enum stream_type {
+	SST_STREAM_TYPE_NONE = 0,
+	SST_STREAM_TYPE_MUSIC = 1,
+	SST_STREAM_TYPE_NORMAL = 2,
+	SST_STREAM_TYPE_PROBE = 3,
+	SST_STREAM_TYPE_LONG_PB = 4,
+	SST_STREAM_TYPE_LOW_LATENCY = 5,
+};
+
+enum sst_error_codes {
+	/* Error code,response to msgId: Description */
+	/* Common error codes */
+	SST_SUCCESS = 0,	/* Success */
+	SST_ERR_INVALID_STREAM_ID = 1,
+	SST_ERR_INVALID_MSG_ID = 2,
+	SST_ERR_INVALID_STREAM_OP = 3,
+	SST_ERR_INVALID_PARAMS = 4,
+	SST_ERR_INVALID_CODEC = 5,
+	SST_ERR_INVALID_MEDIA_TYPE = 6,
+	SST_ERR_STREAM_ERR = 7,
+
+	/* IPC specific error codes */
+	SST_IPC_ERR_CALL_BACK_NOT_REGD = 8,
+	SST_IPC_ERR_STREAM_NOT_ALLOCATED = 9,
+	SST_IPC_ERR_STREAM_ALLOC_FAILED = 10,
+	SST_IPC_ERR_GET_STREAM_FAILED = 11,
+	SST_ERR_MOD_NOT_AVAIL = 12,
+	SST_ERR_MOD_DNLD_RQD = 13,
+	SST_ERR_STREAM_STOPPED = 14,
+	SST_ERR_STREAM_IN_USE = 15,
+
+	/* Capture specific error codes */
+	SST_CAP_ERR_INCMPLTE_CAPTURE_MSG = 16,
+	SST_CAP_ERR_CAPTURE_FAIL = 17,
+	SST_CAP_ERR_GET_DDR_NEW_SGLIST = 18,
+	SST_CAP_ERR_UNDER_RUN = 19,
+	SST_CAP_ERR_OVERFLOW = 20,
+
+	/* Playback specific error codes*/
+	SST_PB_ERR_INCMPLTE_PLAY_MSG = 21,
+	SST_PB_ERR_PLAY_FAIL = 22,
+	SST_PB_ERR_GET_DDR_NEW_SGLIST = 23,
+
+	/* Codec manager specific error codes */
+	SST_LIB_ERR_LIB_DNLD_REQUIRED = 24,
+	SST_LIB_ERR_LIB_NOT_SUPPORTED = 25,
+
+	/* Library manager specific error codes */
+	SST_SCC_ERR_PREP_DNLD_FAILED = 26,
+	SST_SCC_ERR_LIB_DNLD_RES_FAILED = 27,
+	/* Scheduler specific error codes */
+	SST_SCH_ERR_FAIL = 28,
+
+	/* DMA specific error codes */
+	SST_DMA_ERR_NO_CHNL_AVAILABLE = 29,
+	SST_DMA_ERR_INVALID_INPUT_PARAMS = 30,
+	SST_DMA_ERR_CHNL_ALREADY_SUSPENDED = 31,
+	SST_DMA_ERR_CHNL_ALREADY_STARTED = 32,
+	SST_DMA_ERR_CHNL_NOT_ENABLED = 33,
+	SST_DMA_ERR_TRANSFER_FAILED = 34,
+
+	SST_SSP_ERR_ALREADY_ENABLED = 35,
+	SST_SSP_ERR_ALREADY_DISABLED = 36,
+	SST_SSP_ERR_NOT_INITIALIZED = 37,
+	SST_SSP_ERR_SRAM_NO_DMA_DATA = 38,
+
+	/* Other error codes */
+	SST_ERR_MOD_INIT_FAIL = 39,
+
+	/* FW init error codes */
+	SST_RDR_ERR_IO_DEV_SEL_NOT_ALLOWED = 40,
+	SST_RDR_ERR_ROUTE_ALREADY_STARTED = 41,
+	SST_RDR_ERR_IO_DEV_SEL_FAILED = 42,
+	SST_RDR_PREP_CODEC_DNLD_FAILED = 43,
+
+	/* Memory debug error codes */
+	SST_ERR_DBG_MEM_READ_FAIL = 44,
+	SST_ERR_DBG_MEM_WRITE_FAIL = 45,
+	SST_ERR_INSUFFICIENT_INPUT_SG_LIST = 46,
+	SST_ERR_INSUFFICIENT_OUTPUT_SG_LIST = 47,
+
+	SST_ERR_BUFFER_NOT_AVAILABLE = 48,
+	SST_ERR_BUFFER_NOT_ALLOCATED = 49,
+	SST_ERR_INVALID_REGION_TYPE = 50,
+	SST_ERR_NULL_PTR = 51,
+	SST_ERR_INVALID_BUFFER_SIZE = 52,
+	SST_ERR_INVALID_BUFFER_INDEX = 53,
+
+	/*IIPC specific error codes */
+	SST_IIPC_QUEUE_FULL = 54,
+	SST_IIPC_ERR_MSG_SND_FAILED = 55,
+	SST_PB_ERR_UNDERRUN_OCCURED = 56,
+	SST_RDR_INSUFFICIENT_MIXER_BUFFER = 57,
+	SST_INVALID_TIME_SLOTS = 58,
+};
+
+enum dbg_mem_data_type {
+	/* Data type of debug read/write */
+	DATA_TYPE_U32,
+	DATA_TYPE_U16,
+	DATA_TYPE_U8,
+};
+
+enum dbg_type {
+	NO_DEBUG = 0,
+	SRAM_DEBUG,
+	PTI_DEBUG,
+};
+
+struct ipc_dsp_hdr {
+	u16 mod_index_id:8;		/*!< DSP Command ID specific to tasks */
+	u16 pipe_id:8;	/*!< instance of the module in the pipeline */
+	u16 mod_id;		/*!< Pipe_id */
+	u16 cmd_id;		/*!< Module ID = lpe_algo_types_t */
+	u16 length;		/*!< Length of the payload only */
+} __packed;
+
+struct ipc_dsp_effects_info {
+	u16	cmd_id;
+	u16	length;
+	u16	sel_pos;
+	u16	sel_algo_id;
+	u16	cpu_load;       /* CPU load indication */
+	u16	memory_usage;   /* Data Memory usage */
+	u32	flags;         /* effect engine caps/requirements flags */
+} __packed;
+
+struct ipc_effect_dsp_hdr {
+	u16 mod_index_id:8;             /*!< DSP Command ID specific to tasks */
+	u16 pipe_id:8;  /*!< instance of the module in the pipeline */
+	u16 mod_id;             /*!< Pipe_id */
+} __packed;
+
+struct ipc_effect_payload {
+	struct ipc_effect_dsp_hdr dsp_hdr;
+	char *data;
+};
+
+union ipc_header_high {
+	struct {
+		u32  msg_id:8;	    /* Message ID - Max 256 Message Types */
+		u32  task_id:4;	    /* Task ID associated with this comand */
+		u32  drv_id:4;    /* Identifier for the driver to track*/
+		u32  rsvd1:8;	    /* Reserved */
+		u32  result:4;	    /* Reserved */
+		u32  res_rqd:1;	    /* Response rqd */
+		u32  large:1;	    /* Large Message if large = 1 */
+		u32  done:1;	    /* bit 30 - Done bit */
+		u32  busy:1;	    /* bit 31 - busy bit*/
+	} part;
+	u32 full;
+} __packed;
+
+/* IPC header */
+union ipc_header_mrfld {
+	struct {
+		u32 header_low_payload;
+		union ipc_header_high header_high;
+	} p;
+	u64 full;
+} __packed;
+
+/* CAUTION NOTE: All IPC message body must be multiple of 32 bits.*/
+
+/* IPC Header */
+union ipc_header {
+	struct {
+		u32  msg_id:8; /* Message ID - Max 256 Message Types */
+		u32  str_id:5;
+		u32  large:1;	/* Large Message if large = 1 */
+		u32  reserved:2;	/* Reserved for future use */
+		u32  data:14;	/* Ack/Info for msg, size of msg in Mailbox */
+		u32  done:1; /* bit 30 */
+		u32  busy:1; /* bit 31 */
+	} part;
+	u32 full;
+} __packed;
+
+/* Firmware build info */
+struct sst_fw_build_info {
+	unsigned char  date[16]; /* Firmware build date */
+	unsigned char  time[16]; /* Firmware build time */
+} __packed;
+
+/* Firmware Version info */
+struct snd_sst_fw_version {
+	u8 build;	/* build number*/
+	u8 minor;	/* minor number*/
+	u8 major;	/* major number*/
+	u8 type;	/* build type */
+};
+
+struct ipc_header_fw_init {
+	struct snd_sst_fw_version fw_version;/* Firmware version details */
+	struct sst_fw_build_info build_info;
+	u16 result;	/* Fw init result */
+	u8 module_id; /* Module ID in case of error */
+	u8 debug_info; /* Debug info from Module ID in case of fail */
+} __packed;
+
+struct snd_sst_tstamp {
+	u64 ring_buffer_counter;	/* PB/CP: Bytes copied from/to DDR. */
+	u64 hardware_counter;	    /* PB/CP: Bytes DMAed to/from SSP. */
+	u64 frames_decoded;
+	u64 bytes_decoded;
+	u64 bytes_copied;
+	u32 sampling_frequency;
+	u32 channel_peak[8];
+} __packed;
+
+/* SST to IA memory read debug message  */
+struct ipc_sst_ia_dbg_mem_rw  {
+	u16  num_bytes;/* Maximum of MAX_DBG_RW_BYTES */
+	u16  data_type;/* enum: dbg_mem_data_type */
+	u32  address;	/* Memory address of data memory of data_type */
+	u8	rw_bytes[MAX_DBG_RW_BYTES];/* Maximum of 64 bytes can be RW */
+} __packed;
+
+struct ipc_sst_ia_dbg_loop_back {
+	u16 num_dwords; /* Maximum of MAX_DBG_RW_BYTES */
+	u16 increment_val;/* Increments dwords by this value, 0- no increment */
+	u32 lpbk_dwords[MAX_LOOP_BACK_DWORDS];/* Maximum of 8 dwords loopback */
+} __packed;
+
+/* Stream type params struture for Alloc stream */
+struct snd_sst_str_type {
+	u8 codec_type;		/* Codec type */
+	u8 str_type;		/* 1 = voice 2 = music */
+	u8 operation;		/* Playback or Capture */
+	u8 protected_str;	/* 0=Non DRM, 1=DRM */
+	u8 time_slots;
+	u8 reserved;		/* Reserved */
+	u16 result;		/* Result used for acknowledgment */
+} __packed;
+
+/* Library info structure */
+struct module_info {
+	u32 lib_version;
+	u32 lib_type;/*TBD- KLOCKWORK u8 lib_type;*/
+	u32 media_type;
+	u8  lib_name[12];
+	u32 lib_caps;
+	unsigned char  b_date[16]; /* Lib build date */
+	unsigned char  b_time[16]; /* Lib build time */
+} __packed;
+
+/* Library slot info */
+struct lib_slot_info {
+	u8  slot_num; /* 1 or 2 */
+	u8  reserved1;
+	u16 reserved2;
+	u32 iram_size; /* slot size in IRAM */
+	u32 dram_size; /* slot size in DRAM */
+	u32 iram_offset; /* starting offset of slot in IRAM */
+	u32 dram_offset; /* starting offset of slot in DRAM */
+} __packed;
+
+struct snd_ppp_mixer_params {
+	__u32			type; /*Type of the parameter */
+	__u32			size;
+	__u32			input_stream_bitmap; /*Input stream Bit Map*/
+} __packed;
+
+struct snd_sst_lib_download {
+	struct module_info lib_info; /* library info type, capabilities etc */
+	struct lib_slot_info slot_info; /* slot info to be downloaded */
+	u32 mod_entry_pt;
+};
+
+struct snd_sst_lib_download_info {
+	struct snd_sst_lib_download dload_lib;
+	u16 result;	/* Result used for acknowledgment */
+	u8 pvt_id; /* Private ID */
+	u8 reserved;  /* for alignment */
+};
+
+struct snd_pcm_params {
+	u8 num_chan;	/* 1=Mono, 2=Stereo */
+	u8 pcm_wd_sz;	/* 16/24 - bit*/
+	u8 use_offload_path;	/* 0-PCM using period elpased & ALSA interfaces
+				   1-PCM stream via compressed interface  */
+	u8 reserved2;
+	u32 sfreq;    /* Sampling rate in Hz */
+	u8 channel_map[8];
+} __packed;
+
+/* MP3 Music Parameters Message */
+struct snd_mp3_params {
+	u8  num_chan;	/* 1=Mono, 2=Stereo	*/
+	u8  pcm_wd_sz; /* 16/24 - bit*/
+	u8  crc_check; /* crc_check - disable (0) or enable (1) */
+	u8  reserved1; /* unused*/
+};
+
+#define AAC_BIT_STREAM_ADTS		0
+#define AAC_BIT_STREAM_ADIF		1
+#define AAC_BIT_STREAM_RAW		2
+
+/* AAC Music Parameters Message */
+struct snd_aac_params {
+	u8 num_chan; /* 1=Mono, 2=Stereo*/
+	u8 pcm_wd_sz; /* 16/24 - bit*/
+	u8 bdownsample; /*SBR downsampling 0 - disable 1 -enabled AAC+ only */
+	u8 bs_format; /* input bit stream format adts=0, adif=1, raw=2 */
+	u32 externalsr; /*sampling rate of basic AAC raw bit stream*/
+	u8 sbr_signalling;/*disable/enable/set automode the SBR tool.AAC+*/
+	u8 reser1;
+	u16  reser2;
+};
+
+/* WMA Music Parameters Message */
+struct snd_wma_params {
+	u8  num_chan;	/* 1=Mono, 2=Stereo */
+	u8  pcm_wd_sz;	/* 16/24 - bit*/
+	u16 reserved1;
+	u32 brate;	/* Use the hard coded value. */
+	u32 sfreq;	/* Sampling freq eg. 8000, 441000, 48000 */
+	u32 channel_mask;  /* Channel Mask */
+	u16 format_tag;	/* Format Tag */
+	u16 block_align;	/* packet size */
+	u16 wma_encode_opt;/* Encoder option */
+	u8 op_align;	/* op align 0- 16 bit, 1- MSB, 2 LSB */
+	u8 reserved;	/* reserved */
+};
+
+/* Codec params struture */
+union  snd_sst_codec_params {
+	struct snd_pcm_params pcm_params;
+	struct snd_mp3_params mp3_params;
+	struct snd_aac_params aac_params;
+	struct snd_wma_params wma_params;
+};
+
+/* Address and size info of a frame buffer in DDR */
+struct sst_address_info {
+	__u32 addr; /* Address at IA */
+	__u32 size; /* Size of the buffer */
+} __packed;
+
+/* Additional params for Alloc struct*/
+struct snd_sst_alloc_params_ext {
+	__u16 sg_count;
+	__u16 reserved;
+	__u32 frag_size;	/*Number of samples after which period elapsed
+				  message is sent valid only if path  = 0*/
+	struct sst_address_info  ring_buf_info[8];
+};
+
+struct snd_sst_stream_params {
+	union snd_sst_codec_params uc;
+} __packed;
+
+struct snd_sst_params {
+	u32 result;
+	u32 stream_id;
+	u8 codec;
+	u8 ops;
+	u8 stream_type;
+	u8 device_type;
+	u8 task;
+	struct snd_sst_stream_params sparams;
+	struct snd_sst_alloc_params_ext aparams;
+};
+
+struct snd_sst_alloc_mrfld {
+	u16 codec_type;
+	u8 operation;
+	u8 sg_count;
+	struct sst_address_info ring_buf_info[8];
+	u32 frag_size;
+	u32 ts;
+	struct snd_sst_stream_params codec_params;
+} __packed;
+
+/* Alloc stream params structure */
+struct snd_sst_alloc_params {
+	struct snd_sst_str_type str_type;
+	struct snd_sst_stream_params stream_params;
+	struct snd_sst_alloc_params_ext alloc_params;
+} __packed;
+
+/* Alloc stream response message */
+struct snd_sst_alloc_response {
+	struct snd_sst_str_type str_type; /* Stream type for allocation */
+	struct snd_sst_lib_download lib_dnld; /* Valid only for codec dnld */
+};
+
+/* Drop response */
+struct snd_sst_drop_response {
+	u32 result;
+	u32 bytes;
+};
+
+struct snd_sst_async_msg {
+	u32 msg_id; /* Async msg id */
+	u32 payload[0];
+};
+
+struct snd_sst_async_err_msg {
+	u32 fw_resp; /* Firmware Result */
+	u32 lib_resp; /*Library result */
+} __packed;
+
+struct snd_sst_vol {
+	u32	stream_id;
+	s32	volume;
+	u32	ramp_duration;
+	u32	ramp_type;		/* Ramp type, default=0 */
+};
+
+/* Gain library parameters for mrfld
+ * based on DSP command spec v0.82
+ */
+struct snd_sst_gain_v2 {
+	u16 gain_cell_num;  /* num of gain cells to modify*/
+	u8 cell_nbr_idx; /* instance index*/
+	u8 cell_path_idx; /* pipe-id */
+	u16 module_id; /*module id */
+	u16 left_cell_gain; /* left gain value in dB*/
+	u16 right_cell_gain; /* right gain value in dB*/
+	u16 gain_time_const; /* gain time constant*/
+} __packed;
+
+struct snd_sst_mute {
+	u32	stream_id;
+	u32	mute;
+};
+
+struct snd_sst_runtime_params {
+	u8 type;
+	u8 str_id;
+	u8 size;
+	u8 rsvd;
+	void *addr;
+} __packed;
+
+enum stream_param_type {
+	SST_SET_TIME_SLOT = 0,
+	SST_SET_CHANNEL_INFO = 1,
+	OTHERS = 2, /*reserved for future params*/
+};
+
+/* CSV Voice call routing structure */
+struct snd_sst_control_routing {
+	u8 control; /* 0=start, 1=Stop */
+	u8 reserved[3];	/* Reserved- for 32 bit alignment */
+};
+
+struct ipc_post {
+	struct list_head node;
+	union ipc_header header; /* driver specific */
+	bool is_large;
+	bool is_process_reply;
+	union ipc_header_mrfld mrfld_header;
+	char *mailbox_data;
+};
+
+struct snd_sst_ctxt_params {
+	u32 address; /* Physical Address in DDR where the context is stored */
+	u32 size; /* size of the context */
+};
+
+struct snd_sst_lpe_log_params {
+	u8 dbg_type;
+	u8 module_id;
+	u8 log_level;
+	u8 reserved;
+} __packed;
+
+enum snd_sst_bytes_type {
+	SND_SST_BYTES_SET = 0x1,
+	SND_SST_BYTES_GET = 0x2,
+};
+
+struct snd_sst_bytes_v2 {
+	u8 type;
+	u8 ipc_msg;
+	u8 block;
+	u8 task_id;
+	u8 pipe_id;
+	u8 rsvd;
+	u16 len;
+	char bytes[0];
+};
+
+#define MAX_VTSV_FILES 2
+struct snd_sst_vtsv_info {
+	struct sst_address_info vfiles[MAX_VTSV_FILES];
+} __packed;
+
+#endif /* __PLATFORMDRV_IPC_V2_H__ */
diff --git a/sound/soc/intel/sst/Makefile b/sound/soc/intel/sst/Makefile
new file mode 100644
index 0000000..45f1ec3
--- /dev/null
+++ b/sound/soc/intel/sst/Makefile
@@ -0,0 +1,14 @@
+# Makefile for SST Audio driver
+snd-intel-sst-objs := sst.o sst_ipc.o sst_stream.o sst_drv_interface.o sst_dsp.o sst_pvt.o sst_app_interface.o sst_acpi.o
+
+ifdef CONFIG_DEBUG_FS
+	snd-intel-sst-objs += sst_debug.o
+endif
+
+obj-$(CONFIG_SND_INTEL_SST) += snd-intel-sst.o
+
+
+CFLAGS_snd-intel-sst.o = -I$(src)
+
+ccflags-y += -DMRFLD_WORD_WA -Werror
+
diff --git a/sound/soc/intel/sst/sst.c b/sound/soc/intel/sst/sst.c
new file mode 100644
index 0000000..0624cfa
--- /dev/null
+++ b/sound/soc/intel/sst/sst.c
@@ -0,0 +1,1297 @@
+
+/*
+ *  sst.c - Intel SST Driver for audio engine
+ *
+ *  Copyright (C) 2008-10	Intel Corp
+ *  Authors:	Vinod Koul <vinod.koul@intel.com>
+ *		Harsha Priya <priya.harsha@intel.com>
+ *		Dharageswari R <dharageswari.r@intel.com>
+ *		KP Jeeja <jeeja.kp@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This driver enumerates the SST audio engine as a PCI or ACPI device and
+ *  provides interface to the platform driver to interact with the SST audio
+ *  Firmware.
+ *
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/firmware.h>
+#include <linux/miscdevice.h>
+#include <linux/pm_runtime.h>
+#include <linux/pm_qos.h>
+#include <linux/async.h>
+#include <linux/lnw_gpio.h>
+#include <linux/delay.h>
+#include <linux/acpi.h>
+#include <asm/intel-mid.h>
+#include <asm/platform_sst_audio.h>
+#include <asm/platform_sst.h>
+#include "../sst_platform.h"
+#include "../platform_ipc_v2.h"
+#include "sst.h"
+
+#define CREATE_TRACE_POINTS
+#include "sst_trace.h"
+
+MODULE_AUTHOR("Vinod Koul <vinod.koul@intel.com>");
+MODULE_AUTHOR("Harsha Priya <priya.harsha@intel.com>");
+MODULE_AUTHOR("Dharageswari R <dharageswari.r@intel.com>");
+MODULE_AUTHOR("KP Jeeja <jeeja.kp@intel.com>");
+MODULE_DESCRIPTION("Intel (R) SST(R) Audio Engine Driver");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION(SST_DRIVER_VERSION);
+
+struct intel_sst_drv *sst_drv_ctx;
+static struct mutex drv_ctx_lock;
+
+/*
+ *  * ioctl32 compat
+ *   */
+#ifdef CONFIG_COMPAT
+#include "sst_app_compat_interface.c"
+#else
+#define intel_sst_ioctl_compat NULL
+#endif
+
+static const struct file_operations intel_sst_fops_cntrl = {
+	.owner = THIS_MODULE,
+	.open = intel_sst_open_cntrl,
+	.release = intel_sst_release_cntrl,
+	.unlocked_ioctl = intel_sst_ioctl,
+	.compat_ioctl = intel_sst_ioctl_compat,
+};
+
+struct miscdevice lpe_ctrl = {
+	.minor = MISC_DYNAMIC_MINOR,/* dynamic allocation */
+	.name = "intel_sst_ctrl",/* /dev/intel_sst_ctrl */
+	.fops = &intel_sst_fops_cntrl
+};
+
+static inline void set_imr_interrupts(struct intel_sst_drv *ctx, bool enable)
+{
+	union interrupt_reg imr;
+
+	spin_lock(&ctx->ipc_spin_lock);
+	imr.full = sst_shim_read(ctx->shim, SST_IMRX);
+	if (enable) {
+		imr.part.done_interrupt = 0;
+		imr.part.busy_interrupt = 0;
+	} else {
+		imr.part.done_interrupt = 1;
+		imr.part.busy_interrupt = 1;
+	}
+	sst_shim_write(ctx->shim, SST_IMRX, imr.full);
+	spin_unlock(&ctx->ipc_spin_lock);
+}
+
+#define SST_IS_PROCESS_REPLY(header) ((header & PROCESS_MSG) ? true : false)
+#define SST_VALIDATE_MAILBOX_SIZE(size) ((size <= SST_MAILBOX_SIZE) ? true : false)
+
+static irqreturn_t intel_sst_interrupt_mrfld(int irq, void *context)
+{
+	union interrupt_reg_mrfld isr;
+	union ipc_header_mrfld header;
+	union sst_imr_reg_mrfld imr;
+	struct ipc_post *msg = NULL;
+	unsigned int size = 0;
+	struct intel_sst_drv *drv = (struct intel_sst_drv *) context;
+	irqreturn_t retval = IRQ_HANDLED;
+
+	/* Interrupt arrived, check src */
+	isr.full = sst_shim_read64(drv->shim, SST_ISRX);
+	if (isr.part.done_interrupt) {
+		/* Clear done bit */
+		spin_lock(&drv->ipc_spin_lock);
+		header.full = sst_shim_read64(drv->shim,
+					drv->ipc_reg.ipcx);
+		header.p.header_high.part.done = 0;
+		sst_shim_write64(drv->shim, drv->ipc_reg.ipcx, header.full);
+		/* write 1 to clear status register */;
+		isr.part.done_interrupt = 1;
+		sst_shim_write64(drv->shim, SST_ISRX, isr.full);
+		spin_unlock(&drv->ipc_spin_lock);
+		trace_sst_ipc("ACK   <-", header.p.header_high.full,
+					  header.p.header_low_payload,
+					  header.p.header_high.part.drv_id);
+		queue_work(drv->post_msg_wq, &drv->ipc_post_msg.wq);
+		retval = IRQ_HANDLED;
+	}
+	if (isr.part.busy_interrupt) {
+		spin_lock(&drv->ipc_spin_lock);
+		imr.full = sst_shim_read64(drv->shim, SST_IMRX);
+		imr.part.busy_interrupt = 1;
+		sst_shim_write64(drv->shim, SST_IMRX, imr.full);
+		spin_unlock(&drv->ipc_spin_lock);
+		header.full =  sst_shim_read64(drv->shim, drv->ipc_reg.ipcd);
+		if (sst_create_ipc_msg(&msg, header.p.header_high.part.large)) {
+			pr_err("No memory available\n");
+			drv->ops->clear_interrupt();
+			return IRQ_HANDLED;
+		}
+		if (header.p.header_high.part.large) {
+			size = header.p.header_low_payload;
+			if (SST_VALIDATE_MAILBOX_SIZE(size)) {
+				memcpy_fromio(msg->mailbox_data,
+					drv->mailbox + drv->mailbox_recv_offset, size);
+			} else {
+				pr_err("Mailbox not copied, payload siz is: %u\n", size);
+				header.p.header_low_payload = 0;
+			}
+		}
+		msg->mrfld_header = header;
+		msg->is_process_reply =
+			SST_IS_PROCESS_REPLY(header.p.header_high.part.msg_id);
+		trace_sst_ipc("REPLY <-", msg->mrfld_header.p.header_high.full,
+					  msg->mrfld_header.p.header_low_payload,
+					  msg->mrfld_header.p.header_high.part.drv_id);
+		spin_lock(&drv->rx_msg_lock);
+		list_add_tail(&msg->node, &drv->rx_list);
+		spin_unlock(&drv->rx_msg_lock);
+		drv->ops->clear_interrupt();
+		retval = IRQ_WAKE_THREAD;
+	}
+	return retval;
+}
+
+static irqreturn_t intel_sst_irq_thread_mfld(int irq, void *context)
+{
+	struct intel_sst_drv *drv = (struct intel_sst_drv *) context;
+	struct ipc_post *__msg, *msg = NULL;
+	unsigned long irq_flags;
+
+	if (list_empty(&drv->rx_list))
+		return IRQ_HANDLED;
+
+	spin_lock_irqsave(&drv->rx_msg_lock, irq_flags);
+	list_for_each_entry_safe(msg, __msg, &drv->rx_list, node) {
+
+		list_del(&msg->node);
+		spin_unlock_irqrestore(&drv->rx_msg_lock, irq_flags);
+		if (msg->is_process_reply)
+			drv->ops->process_message(msg);
+		else
+			drv->ops->process_reply(msg);
+
+		if (msg->is_large)
+			kfree(msg->mailbox_data);
+		kfree(msg);
+		spin_lock_irqsave(&drv->rx_msg_lock, irq_flags);
+	}
+	spin_unlock_irqrestore(&drv->rx_msg_lock, irq_flags);
+	return IRQ_HANDLED;
+}
+/**
+* intel_sst_interrupt - Interrupt service routine for SST
+*
+* @irq:	irq number of interrupt
+* @context: pointer to device structre
+*
+* This function is called by OS when SST device raises
+* an interrupt. This will be result of write in IPC register
+* Source can be busy or done interrupt
+*/
+static irqreturn_t intel_sst_intr_mfld(int irq, void *context)
+{
+	union interrupt_reg isr;
+	union ipc_header header;
+	irqreturn_t retval = IRQ_HANDLED;
+	struct ipc_post *msg = NULL;
+	unsigned int size = 0;
+	struct intel_sst_drv *drv = (struct intel_sst_drv *) context;
+
+	/* Interrupt arrived, check src */
+	isr.full = sst_shim_read(drv->shim, SST_ISRX);
+	if (isr.part.done_interrupt) {
+		/* Mask all interrupts till this one is processsed */
+		set_imr_interrupts(drv, false);
+		/* Clear done bit */
+		spin_lock(&drv->ipc_spin_lock);
+		header.full = sst_shim_read(drv->shim, drv->ipc_reg.ipcx);
+		header.part.done = 0;
+		sst_shim_write(drv->shim, drv->ipc_reg.ipcx, header.full);
+		/* write 1 to clear status register */;
+		isr.part.done_interrupt = 1;
+		sst_shim_write(drv->shim, SST_ISRX, isr.full);
+		spin_unlock(&drv->ipc_spin_lock);
+		queue_work(drv->post_msg_wq, &sst_drv_ctx->ipc_post_msg.wq);
+
+		/* Un mask done and busy intr */
+		set_imr_interrupts(drv, true);
+		retval = IRQ_HANDLED;
+	}
+	if (isr.part.busy_interrupt) {
+		/* Mask all interrupts till we process it in bottom half */
+		set_imr_interrupts(drv, false);
+		header.full = sst_shim_read(drv->shim, drv->ipc_reg.ipcd);
+		if (sst_create_ipc_msg(&msg, header.part.large)) {
+			pr_err("No memory available\n");
+			drv->ops->clear_interrupt();
+			return IRQ_HANDLED;
+		}
+		if (header.part.large) {
+			size = header.part.data;
+			if (SST_VALIDATE_MAILBOX_SIZE(size)) {
+				memcpy_fromio(msg->mailbox_data,
+					drv->mailbox + drv->mailbox_recv_offset + 4, size);
+			} else {
+				pr_err("Mailbox not copied, payload siz is: %u\n", size);
+				header.part.data = 0;
+			}
+		}
+		msg->header = header;
+		msg->is_process_reply =
+				SST_IS_PROCESS_REPLY(msg->header.part.msg_id);
+		spin_lock(&drv->rx_msg_lock);
+		list_add_tail(&msg->node, &drv->rx_list);
+		spin_unlock(&drv->rx_msg_lock);
+		drv->ops->clear_interrupt();
+		retval = IRQ_WAKE_THREAD;
+	}
+	return retval;
+}
+
+static int sst_save_dsp_context_v2(struct intel_sst_drv *sst)
+{
+	unsigned int pvt_id;
+	struct ipc_post *msg = NULL;
+	struct ipc_dsp_hdr dsp_hdr;
+	struct sst_block *block;
+
+	/*send msg to fw*/
+	pvt_id = sst_assign_pvt_id(sst);
+	if (sst_create_block_and_ipc_msg(&msg, true, sst, &block,
+				IPC_CMD, pvt_id)) {
+		pr_err("msg/block alloc failed. Not proceeding with context save\n");
+		return 0;
+	}
+
+	sst_fill_header_mrfld(&msg->mrfld_header, IPC_CMD,
+			      SST_TASK_ID_MEDIA, 1, pvt_id);
+	msg->mrfld_header.p.header_low_payload = sizeof(dsp_hdr);
+	msg->mrfld_header.p.header_high.part.res_rqd = 1;
+	sst_fill_header_dsp(&dsp_hdr, IPC_PREP_D3, PIPE_RSVD, pvt_id);
+	memcpy(msg->mailbox_data, &dsp_hdr, sizeof(dsp_hdr));
+
+	sst_add_to_dispatch_list_and_post(sst, msg);
+	/*wait for reply*/
+	if (sst_wait_timeout(sst, block)) {
+		pr_err("sst: err fw context save timeout  ...\n");
+		pr_err("not suspending FW!!!");
+		sst_free_block(sst, block);
+		return -EIO;
+	}
+	if (block->ret_code) {
+		pr_err("fw responded w/ error %d", block->ret_code);
+		sst_free_block(sst, block);
+		return -EIO;
+	}
+
+	sst_free_block(sst, block);
+	return 0;
+}
+
+static int sst_save_dsp_context(struct intel_sst_drv *sst)
+{
+	struct snd_sst_ctxt_params fw_context;
+	unsigned int pvt_id;
+	struct ipc_post *msg = NULL;
+	struct sst_block *block;
+	pr_debug("%s: Enter\n", __func__);
+
+	/*send msg to fw*/
+	pvt_id = sst_assign_pvt_id(sst_drv_ctx);
+	if (sst_create_block_and_ipc_msg(&msg, true, sst_drv_ctx, &block,
+				IPC_IA_GET_FW_CTXT, pvt_id)) {
+		pr_err("msg/block alloc failed. Not proceeding with context save\n");
+		return -ENOMEM;
+	}
+	sst_fill_header(&msg->header, IPC_IA_GET_FW_CTXT, 1, pvt_id);
+	msg->header.part.data = sizeof(fw_context) + sizeof(u32);
+	fw_context.address = virt_to_phys((void *)sst_drv_ctx->fw_cntx);
+	fw_context.size = FW_CONTEXT_MEM;
+	memcpy(msg->mailbox_data, &msg->header, sizeof(u32));
+	memcpy(msg->mailbox_data + sizeof(u32),
+				&fw_context, sizeof(fw_context));
+	sst_add_to_dispatch_list_and_post(sst, msg);
+	/*wait for reply*/
+	if (sst_wait_timeout(sst_drv_ctx, block))
+		pr_err("sst: err fw context save timeout  ...\n");
+	pr_debug("fw context saved  ...\n");
+	if (block->ret_code)
+		sst_drv_ctx->fw_cntx_size = 0;
+	else
+		sst_drv_ctx->fw_cntx_size = *sst_drv_ctx->fw_cntx;
+	pr_debug("fw copied data %x\n", sst_drv_ctx->fw_cntx_size);
+	sst_free_block(sst_drv_ctx, block);
+	return 0;
+}
+
+static struct intel_sst_ops mrfld_ops = {
+	.interrupt = intel_sst_interrupt_mrfld,
+	.irq_thread = intel_sst_irq_thread_mfld,
+	.clear_interrupt = intel_sst_clear_intr_mrfld,
+	.start = sst_start_mrfld,
+	.reset = intel_sst_reset_dsp_mrfld,
+	.post_message = sst_post_message_mrfld,
+	.sync_post_message = sst_sync_post_message_mrfld,
+	.process_message = sst_process_message_mrfld,
+	.process_reply = sst_process_reply_mrfld,
+	.save_dsp_context =  sst_save_dsp_context_v2,
+	.alloc_stream = sst_alloc_stream_mrfld,
+	.post_download = sst_post_download_mrfld,
+	.do_recovery = sst_do_recovery_mrfld,
+};
+
+static struct intel_sst_ops mrfld_32_ops = {
+	.interrupt = intel_sst_intr_mfld,
+	.irq_thread = intel_sst_irq_thread_mfld,
+	.clear_interrupt = intel_sst_clear_intr_mfld,
+	.start = sst_start_mrfld,
+	.reset = intel_sst_reset_dsp_mrfld,
+	.post_message = sst_post_message_mfld,
+	.sync_post_message = sst_sync_post_message_mfld,
+	.process_message = sst_process_message_mfld,
+	.process_reply = sst_process_reply_mfld,
+	.save_dsp_context =  sst_save_dsp_context,
+	.restore_dsp_context = sst_restore_fw_context,
+	.alloc_stream = sst_alloc_stream_ctp,
+	.post_download = sst_post_download_byt,
+	.do_recovery = sst_do_recovery,
+};
+
+static struct intel_sst_ops ctp_ops = {
+	.interrupt = intel_sst_intr_mfld,
+	.irq_thread = intel_sst_irq_thread_mfld,
+	.clear_interrupt = intel_sst_clear_intr_mfld,
+	.start = sst_start_mfld,
+	.reset = intel_sst_reset_dsp_mfld,
+	.post_message = sst_post_message_mfld,
+	.sync_post_message = sst_sync_post_message_mfld,
+	.process_message = sst_process_message_mfld,
+	.process_reply = sst_process_reply_mfld,
+	.set_bypass = intel_sst_set_bypass_mfld,
+	.save_dsp_context =  sst_save_dsp_context,
+	.restore_dsp_context = sst_restore_fw_context,
+	.alloc_stream = sst_alloc_stream_ctp,
+	.post_download = sst_post_download_ctp,
+	.do_recovery = sst_do_recovery,
+};
+
+int sst_driver_ops(struct intel_sst_drv *sst)
+{
+
+	switch (sst->pci_id) {
+#if 0
+	case SST_MRFLD_PCI_ID:
+	case PCI_DEVICE_ID_INTEL_SST_MOOR:
+	case SST_CHT_PCI_ID:
+		sst->tstamp = SST_TIME_STAMP_MRFLD;
+		sst->ops = &mrfld_ops;
+
+		/* Override the recovery ops for CHT platforms */
+		if (sst->pci_id == SST_CHT_PCI_ID)
+			sst->ops->do_recovery = sst_do_recovery;
+		/* For MOFD platforms disable/enable recovery based on
+		 * platform data
+		 */
+		if (sst->pci_id == PCI_DEVICE_ID_INTEL_SST_MOOR) {
+			if (!sst->pdata->enable_recovery) {
+				pr_debug("Recovery disabled for this mofd platform\n");
+				sst->ops->do_recovery = sst_do_recovery;
+			} else
+				pr_debug("Recovery enabled for this mofd platform\n");
+		}
+
+		return 0;
+#endif
+	case SST_BYT_PCI_ID:
+		sst->tstamp = SST_TIME_STAMP_BYT;
+		sst->ops = &mrfld_32_ops;
+		/* Override ops for DPCM architecture */
+#ifdef CONFIG_SST_DPCM
+		sst->tstamp = SST_TIME_STAMP_MRFLD;
+		sst->ops = &mrfld_ops;
+		sst->ops->do_recovery = sst_do_recovery;
+#endif
+
+		return 0;
+	case SST_CLV_PCI_ID:
+		sst->tstamp =  SST_TIME_STAMP;
+		sst->ops = &ctp_ops;
+		return 0;
+	default:
+		pr_err("SST Driver capablities missing for pci_id: %x", sst->pci_id);
+		return -EINVAL;
+	};
+}
+
+int sst_alloc_drv_context(struct device *dev)
+{
+	struct intel_sst_drv *ctx;
+	mutex_lock(&drv_ctx_lock);
+	if (sst_drv_ctx) {
+		pr_err("Only one sst handle is supported\n");
+		mutex_unlock(&drv_ctx_lock);
+		return -EBUSY;
+	}
+	pr_debug("%s: %d", __func__, __LINE__);
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx) {
+		pr_err("malloc fail\n");
+		mutex_unlock(&drv_ctx_lock);
+		return -ENOMEM;
+	}
+	sst_drv_ctx = ctx;
+	mutex_unlock(&drv_ctx_lock);
+	return 0;
+}
+
+static ssize_t sst_sysfs_get_recovery(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", ctx->sst_state);
+}
+
+
+static ssize_t sst_sysfs_set_recovery(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t len)
+{
+	long val;
+	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
+
+	if (kstrtol(buf, 0, &val))
+		return -EINVAL;
+
+	if (val == 1) {
+		if (!atomic_read(&ctx->pm_usage_count)) {
+			pr_debug("%s: set sst state to RESET...\n", __func__);
+			sst_set_fw_state_locked(ctx, SST_RESET);
+		} else {
+			pr_err("%s: not setting sst state... %d\n", __func__,
+					atomic_read(&ctx->pm_usage_count));
+			pr_err("Unrecoverable state....\n");
+			BUG();
+			return -EPERM;
+		}
+	}
+
+	return len;
+}
+
+static DEVICE_ATTR(audio_recovery, S_IRUGO | S_IWUSR,
+			sst_sysfs_get_recovery, sst_sysfs_set_recovery);
+
+int sst_request_firmware_async(struct intel_sst_drv *ctx)
+{
+	int ret = 0;
+
+	snprintf(ctx->firmware_name, sizeof(ctx->firmware_name),
+			"%s%04x%s", "fw_sst_",
+			ctx->pci_id, ".bin");
+	pr_debug("Requesting FW %s now...\n", ctx->firmware_name);
+
+	trace_sst_fw_download("Request firmware async", ctx->sst_state);
+
+	ret = request_firmware_nowait(THIS_MODULE, 1, ctx->firmware_name,
+			ctx->dev, GFP_KERNEL, ctx, sst_firmware_load_cb);
+	if (ret)
+		pr_err("could not load firmware %s error %d\n", ctx->firmware_name, ret);
+
+	return ret;
+}
+/*
+* intel_sst_probe - PCI probe function
+*
+* @pci:	PCI device structure
+* @pci_id: PCI device ID structure
+*
+* This function is called by OS when a device is found
+* This enables the device, interrupt etc
+*/
+static int intel_sst_probe(struct pci_dev *pci,
+			const struct pci_device_id *pci_id)
+{
+	int i, ret = 0;
+	struct intel_sst_ops *ops;
+	struct sst_platform_info *sst_pdata = pci->dev.platform_data;
+	int ddr_base;
+	u32 ssp_base_add;
+	u32 dma_base_add;
+	u32 len;
+
+
+
+	pr_debug("Probe for DID %x\n", pci->device);
+	ret = sst_alloc_drv_context(&pci->dev);
+	if (ret)
+		return ret;
+
+	sst_drv_ctx->dev = &pci->dev;
+	sst_drv_ctx->pci_id = pci->device;
+	if (!sst_pdata)
+		return -EINVAL;
+	sst_drv_ctx->pdata = sst_pdata;
+
+	if (!sst_drv_ctx->pdata->probe_data)
+		return -EINVAL;
+	memcpy(&sst_drv_ctx->info, sst_drv_ctx->pdata->probe_data,
+					sizeof(sst_drv_ctx->info));
+
+	sst_drv_ctx->use_32bit_ops = sst_drv_ctx->pdata->ipc_info->use_32bit_ops;
+	sst_drv_ctx->mailbox_recv_offset = sst_drv_ctx->pdata->ipc_info->mbox_recv_off;
+
+	if (0 != sst_driver_ops(sst_drv_ctx))
+		return -EINVAL;
+	ops = sst_drv_ctx->ops;
+	mutex_init(&sst_drv_ctx->stream_lock);
+	mutex_init(&sst_drv_ctx->sst_lock);
+	mutex_init(&sst_drv_ctx->mixer_ctrl_lock);
+	mutex_init(&sst_drv_ctx->csr_lock);
+
+	sst_drv_ctx->stream_cnt = 0;
+	sst_drv_ctx->fw_in_mem = NULL;
+	sst_drv_ctx->vcache.file1_in_mem = NULL;
+	sst_drv_ctx->vcache.file2_in_mem = NULL;
+	sst_drv_ctx->vcache.size1 = 0;
+	sst_drv_ctx->vcache.size2 = 0;
+
+	/* we use dma, so set to 1*/
+	sst_drv_ctx->use_dma = 0;
+	sst_drv_ctx->use_lli = 0;
+
+	INIT_LIST_HEAD(&sst_drv_ctx->memcpy_list);
+	INIT_LIST_HEAD(&sst_drv_ctx->libmemcpy_list);
+
+	INIT_LIST_HEAD(&sst_drv_ctx->ipc_dispatch_list);
+	INIT_LIST_HEAD(&sst_drv_ctx->block_list);
+	INIT_LIST_HEAD(&sst_drv_ctx->rx_list);
+	INIT_WORK(&sst_drv_ctx->ipc_post_msg.wq, ops->post_message);
+	init_waitqueue_head(&sst_drv_ctx->wait_queue);
+
+	sst_drv_ctx->mad_wq = create_singlethread_workqueue("sst_mad_wq");
+	if (!sst_drv_ctx->mad_wq) {
+		ret = -EINVAL;
+		goto do_free_drv_ctx;
+	}
+	sst_drv_ctx->post_msg_wq =
+		create_singlethread_workqueue("sst_post_msg_wq");
+	if (!sst_drv_ctx->post_msg_wq) {
+		ret = -EINVAL;
+		goto free_mad_wq;
+	}
+
+	spin_lock_init(&sst_drv_ctx->ipc_spin_lock);
+	spin_lock_init(&sst_drv_ctx->block_lock);
+	spin_lock_init(&sst_drv_ctx->pvt_id_lock);
+	spin_lock_init(&sst_drv_ctx->rx_msg_lock);
+
+	sst_drv_ctx->ipc_reg.ipcx = SST_IPCX + sst_drv_ctx->pdata->ipc_info->ipc_offset;
+	sst_drv_ctx->ipc_reg.ipcd = SST_IPCD + sst_drv_ctx->pdata->ipc_info->ipc_offset;
+	pr_debug("ipcx 0x%x ipxd 0x%x", sst_drv_ctx->ipc_reg.ipcx,
+					sst_drv_ctx->ipc_reg.ipcd);
+
+	pr_info("Got drv data max stream %d\n",
+				sst_drv_ctx->info.max_streams);
+	for (i = 1; i <= sst_drv_ctx->info.max_streams; i++) {
+		struct stream_info *stream = &sst_drv_ctx->streams[i];
+		memset(stream, 0, sizeof(*stream));
+		stream->pipe_id = PIPE_RSVD;
+		mutex_init(&stream->lock);
+	}
+
+	ret = sst_request_firmware_async(sst_drv_ctx);
+	if (ret) {
+		pr_err("Firmware download failed:%d\n", ret);
+		goto do_free_mem;
+	}
+	/* Init the device */
+	ret = pci_enable_device(pci);
+	if (ret) {
+		pr_err("device can't be enabled\n");
+		goto do_free_mem;
+	}
+	sst_drv_ctx->pci = pci_dev_get(pci);
+	ret = pci_request_regions(pci, SST_DRV_NAME);
+	if (ret)
+		goto do_disable_device;
+	/* map registers */
+	/* SST Shim */
+
+	if (sst_drv_ctx->pci_id == SST_MRFLD_PCI_ID) { /* ||
+			(sst_drv_ctx->pci_id == PCI_DEVICE_ID_INTEL_SST_MOOR)) {*/
+		sst_drv_ctx->ddr_base = pci_resource_start(pci, 0);
+		/*
+		* check that the relocated IMR base matches with FW Binary
+		* put temporary check till better soln is available for FW
+		*/
+		ddr_base = relocate_imr_addr_mrfld(sst_drv_ctx->ddr_base);
+		if (!sst_drv_ctx->pdata->lib_info) {
+			pr_err("%s:lib_info pointer NULL\n", __func__);
+			ret = -EINVAL;
+			goto do_release_regions;
+		}
+		if (ddr_base != sst_drv_ctx->pdata->lib_info->mod_base) {
+			pr_err("FW LSP DDR BASE does not match with IFWI\n");
+			ret = -EINVAL;
+			goto do_release_regions;
+		}
+		sst_drv_ctx->ddr_end = pci_resource_end(pci, 0);
+
+		sst_drv_ctx->ddr = pci_ioremap_bar(pci, 0);
+		if (!sst_drv_ctx->ddr) {
+			ret = -EINVAL;
+			goto do_unmap_ddr;
+		}
+		pr_debug("sst: DDR Ptr %p\n", sst_drv_ctx->ddr);
+	} else {
+		sst_drv_ctx->ddr = NULL;
+	}
+
+	/* SHIM */
+	sst_drv_ctx->shim_phy_add = pci_resource_start(pci, 1);
+	sst_drv_ctx->shim = pci_ioremap_bar(pci, 1);
+	if (!sst_drv_ctx->shim) {
+		ret = -EINVAL;
+		goto do_release_regions;
+	}
+	pr_debug("SST Shim Ptr %p\n", sst_drv_ctx->shim);
+
+	/* Shared SRAM */
+	sst_drv_ctx->mailbox_add = pci_resource_start(pci, 2);
+	sst_drv_ctx->mailbox = pci_ioremap_bar(pci, 2);
+	if (!sst_drv_ctx->mailbox) {
+		ret = -EINVAL;
+		goto do_unmap_shim;
+	}
+	pr_debug("SRAM Ptr %p\n", sst_drv_ctx->mailbox);
+
+	/* IRAM */
+	sst_drv_ctx->iram_end = pci_resource_end(pci, 3);
+	sst_drv_ctx->iram_base = pci_resource_start(pci, 3);
+	sst_drv_ctx->iram = pci_ioremap_bar(pci, 3);
+	if (!sst_drv_ctx->iram) {
+		ret = -EINVAL;
+		goto do_unmap_sram;
+	}
+	pr_debug("IRAM Ptr %p\n", sst_drv_ctx->iram);
+
+	/* DRAM */
+	sst_drv_ctx->dram_end = pci_resource_end(pci, 4);
+	sst_drv_ctx->dram_base = pci_resource_start(pci, 4);
+	sst_drv_ctx->dram = pci_ioremap_bar(pci, 4);
+	if (!sst_drv_ctx->dram) {
+		ret = -EINVAL;
+		goto do_unmap_iram;
+	}
+	pr_debug("DRAM Ptr %p\n", sst_drv_ctx->dram);
+
+	if ((sst_pdata->pdata != NULL) &&
+			(sst_pdata->debugfs_data != NULL)) {
+		if (sst_pdata->ssp_data != NULL) {
+			/* SSP Register */
+			ssp_base_add = sst_pdata->ssp_data->base_add;
+			len = sst_pdata->debugfs_data->ssp_reg_size;
+			for (i = 0; i < sst_pdata->debugfs_data->num_ssp; i++) {
+				sst_drv_ctx->debugfs.ssp[i] =
+					devm_ioremap(&pci->dev,
+						ssp_base_add + (len * i), len);
+				if (!sst_drv_ctx->debugfs.ssp[i]) {
+					pr_warn("ssp ioremap failed\n");
+					continue;
+				}
+
+				pr_debug("\n ssp io 0x%p ssp 0x%x size 0x%x",
+					sst_drv_ctx->debugfs.ssp[i],
+						ssp_base_add, len);
+			}
+		}
+
+		/* DMA Register */
+		dma_base_add = sst_pdata->pdata->sst_dma_base[0];
+		len = sst_pdata->debugfs_data->dma_reg_size;
+		for (i = 0; i < sst_pdata->debugfs_data->num_dma; i++) {
+			sst_drv_ctx->debugfs.dma_reg[i] =
+				devm_ioremap(&pci->dev,
+					dma_base_add + (len * i), len);
+			if (!sst_drv_ctx->debugfs.dma_reg[i]) {
+				pr_warn("dma ioremap failed\n");
+				continue;
+			}
+
+			pr_debug("\n dma io 0x%p ssp 0x%x size 0x%x",
+				sst_drv_ctx->debugfs.dma_reg[i],
+					dma_base_add, len);
+		}
+	}
+
+	/* Do not access iram/dram etc before LPE is reset */
+
+	sst_drv_ctx->dump_buf.iram_buf.size = pci_resource_len(pci, 3);
+	sst_drv_ctx->dump_buf.iram_buf.buf = kzalloc(sst_drv_ctx->dump_buf.iram_buf.size,
+						GFP_KERNEL);
+	if (!sst_drv_ctx->dump_buf.iram_buf.buf) {
+		pr_err("%s: no memory\n", __func__);
+		ret = -ENOMEM;
+		goto do_unmap_dram;
+	}
+
+	sst_drv_ctx->dump_buf.dram_buf.size = pci_resource_len(pci, 4);
+	sst_drv_ctx->dump_buf.dram_buf.buf = kzalloc(sst_drv_ctx->dump_buf.dram_buf.size,
+						GFP_KERNEL);
+	if (!sst_drv_ctx->dump_buf.dram_buf.buf) {
+		pr_err("%s: no memory\n", __func__);
+		ret = -ENOMEM;
+		goto do_free_iram_buf;
+	}
+
+	pr_debug("\niram len 0x%x dram len 0x%x",
+			sst_drv_ctx->dump_buf.iram_buf.size,
+			sst_drv_ctx->dump_buf.dram_buf.size);
+
+	if (sst_drv_ctx->pci_id == SST_CLV_PCI_ID) {
+		sst_drv_ctx->probe_bytes = kzalloc(SST_MAX_BIN_BYTES, GFP_KERNEL);
+		if (!sst_drv_ctx->probe_bytes) {
+			pr_err("%s: no memory\n", __func__);
+			ret = -ENOMEM;
+			goto do_free_dram_buf;
+		}
+	}
+
+	sst_set_fw_state_locked(sst_drv_ctx, SST_RESET);
+	sst_drv_ctx->irq_num = pci->irq;
+	/* Register the ISR */
+	ret = request_threaded_irq(pci->irq, sst_drv_ctx->ops->interrupt,
+		sst_drv_ctx->ops->irq_thread, 0, SST_DRV_NAME,
+		sst_drv_ctx);
+	if (ret)
+		goto do_free_probe_bytes;
+	pr_debug("Registered IRQ 0x%x\n", pci->irq);
+
+	/*Register LPE Control as misc driver*/
+	ret = misc_register(&lpe_ctrl);
+	if (ret) {
+		pr_err("couldn't register control device\n");
+		goto do_free_irq;
+	}
+	/* default intr are unmasked so set this as masked */
+	if (sst_drv_ctx->pci_id == SST_MRFLD_PCI_ID) /* ||
+			(sst_drv_ctx->pci_id == PCI_DEVICE_ID_INTEL_SST_MOOR)) */
+		sst_shim_write64(sst_drv_ctx->shim, SST_IMRX, 0xFFFF0038);
+
+	if (sst_drv_ctx->use_32bit_ops) {
+		pr_debug("allocate mem for context save/restore\n ");
+		/*allocate mem for fw context save during suspend*/
+		sst_drv_ctx->fw_cntx = kzalloc(FW_CONTEXT_MEM, GFP_KERNEL);
+		if (!sst_drv_ctx->fw_cntx) {
+			ret = -ENOMEM;
+			goto do_free_misc;
+		}
+		/*setting zero as that is valid mem to restore*/
+		sst_drv_ctx->fw_cntx_size = 0;
+	}
+	if (sst_drv_ctx->pci_id == SST_CLV_PCI_ID) {
+		u32 csr;
+		u32 csr2;
+		u32 clkctl;
+
+		/*set lpe start clock and ram size*/
+		csr = sst_shim_read(sst_drv_ctx->shim, SST_CSR);
+		csr |= 0x30000;
+		/*make sure clksel set to OSC for SSP0,1 (default)*/
+		csr &= 0xFFFFFFF3;
+		sst_shim_write(sst_drv_ctx->shim, SST_CSR, csr);
+
+		/*set clock output enable for SSP0,1,3*/
+		clkctl = sst_shim_read(sst_drv_ctx->shim, SST_CLKCTL);
+		if (sst_drv_ctx->pci_id == SST_CLV_PCI_ID)
+			clkctl |= (0x7 << 16);
+		else
+			clkctl |= ((1<<16)|(1<<17));
+		sst_shim_write(sst_drv_ctx->shim, SST_CLKCTL, clkctl);
+
+		/* set SSP0 & SSP1 disable DMA Finish*/
+		csr2 = sst_shim_read(sst_drv_ctx->shim, SST_CSR2);
+		/*set SSP3 disable DMA finsh for SSSP3 */
+		csr2 |= BIT(1)|BIT(2);
+		sst_shim_write(sst_drv_ctx->shim, SST_CSR2, csr2);
+	}
+	if (sst_drv_ctx->pdata->ssp_data) {
+		if (sst_drv_ctx->pdata->ssp_data->gpio_in_use)
+			sst_set_gpio_conf(&sst_drv_ctx->pdata->ssp_data->gpio);
+	}
+	pci_set_drvdata(pci, sst_drv_ctx);
+	pm_runtime_allow(sst_drv_ctx->dev);
+	pm_runtime_put_noidle(sst_drv_ctx->dev);
+	register_sst(sst_drv_ctx->dev);
+	sst_debugfs_init(sst_drv_ctx);
+	sst_drv_ctx->qos = kzalloc(sizeof(struct pm_qos_request),
+				GFP_KERNEL);
+	if (!sst_drv_ctx->qos) {
+		ret = -EINVAL;
+		goto do_free_misc;
+	}
+	pm_qos_add_request(sst_drv_ctx->qos, PM_QOS_CPU_DMA_LATENCY,
+				PM_QOS_DEFAULT_VALUE);
+
+	ret = device_create_file(sst_drv_ctx->dev, &dev_attr_audio_recovery);
+	if (ret) {
+		pr_err("could not create sysfs %s file\n",
+			dev_attr_audio_recovery.attr.name);
+		goto do_free_qos;
+	}
+
+	pr_info("%s successfully done!\n", __func__);
+	return ret;
+
+do_free_qos:
+	pm_qos_remove_request(sst_drv_ctx->qos);
+	kfree(sst_drv_ctx->qos);
+do_free_misc:
+	misc_deregister(&lpe_ctrl);
+do_free_irq:
+	free_irq(pci->irq, sst_drv_ctx);
+do_free_probe_bytes:
+	if (sst_drv_ctx->pci_id == SST_CLV_PCI_ID)
+		kfree(sst_drv_ctx->probe_bytes);
+do_free_dram_buf:
+#ifdef CONFIG_DEBUG_FS
+	if (sst_drv_ctx->pci_id == SST_CLV_PCI_ID)
+		kfree(sst_drv_ctx->dump_buf.dram_buf.buf);
+do_free_iram_buf:
+	if (sst_drv_ctx->pci_id == SST_CLV_PCI_ID)
+		kfree(sst_drv_ctx->dump_buf.iram_buf.buf);
+#endif
+do_unmap_dram:
+	iounmap(sst_drv_ctx->dram);
+do_unmap_iram:
+	iounmap(sst_drv_ctx->iram);
+do_unmap_sram:
+	iounmap(sst_drv_ctx->mailbox);
+do_unmap_shim:
+	iounmap(sst_drv_ctx->shim);
+
+do_unmap_ddr:
+	if (sst_drv_ctx->ddr)
+		iounmap(sst_drv_ctx->ddr);
+
+do_release_regions:
+	pci_release_regions(pci);
+do_disable_device:
+	pci_disable_device(pci);
+do_free_mem:
+	destroy_workqueue(sst_drv_ctx->post_msg_wq);
+free_mad_wq:
+	destroy_workqueue(sst_drv_ctx->mad_wq);
+do_free_drv_ctx:
+	sst_drv_ctx = NULL;
+	pr_err("Probe failed with %d\n", ret);
+	return ret;
+}
+
+/**
+* intel_sst_remove - PCI remove function
+*
+* @pci:	PCI device structure
+*
+* This function is called by OS when a device is unloaded
+* This frees the interrupt etc
+*/
+static void intel_sst_remove(struct pci_dev *pci)
+{
+	struct intel_sst_drv *sst_drv_ctx = pci_get_drvdata(pci);
+	sst_debugfs_exit(sst_drv_ctx);
+	pm_runtime_get_noresume(sst_drv_ctx->dev);
+	pm_runtime_forbid(sst_drv_ctx->dev);
+	unregister_sst(sst_drv_ctx->dev);
+	pci_dev_put(sst_drv_ctx->pci);
+	sst_set_fw_state_locked(sst_drv_ctx, SST_SHUTDOWN);
+	misc_deregister(&lpe_ctrl);
+	free_irq(pci->irq, sst_drv_ctx);
+
+	iounmap(sst_drv_ctx->dram);
+	iounmap(sst_drv_ctx->iram);
+	iounmap(sst_drv_ctx->mailbox);
+	iounmap(sst_drv_ctx->shim);
+#ifdef CONFIG_DEBUG_FS
+	if (sst_drv_ctx->pci_id == SST_CLV_PCI_ID) {
+		kfree(sst_drv_ctx->dump_buf.iram_buf.buf);
+		kfree(sst_drv_ctx->dump_buf.dram_buf.buf);
+	}
+#endif
+	if (sst_drv_ctx->pci_id == SST_CLV_PCI_ID)
+		kfree(sst_drv_ctx->probe_bytes);
+
+	device_remove_file(sst_drv_ctx->dev, &dev_attr_audio_recovery);
+	kfree(sst_drv_ctx->fw_cntx);
+	kfree(sst_drv_ctx->runtime_param.param.addr);
+	flush_scheduled_work();
+	destroy_workqueue(sst_drv_ctx->post_msg_wq);
+	destroy_workqueue(sst_drv_ctx->mad_wq);
+	pm_qos_remove_request(sst_drv_ctx->qos);
+	kfree(sst_drv_ctx->qos);
+	kfree(sst_drv_ctx->fw_sg_list.src);
+	kfree(sst_drv_ctx->fw_sg_list.dst);
+	sst_drv_ctx->fw_sg_list.list_len = 0;
+	kfree(sst_drv_ctx->fw_in_mem);
+	sst_drv_ctx->fw_in_mem = NULL;
+	sst_memcpy_free_resources();
+	sst_drv_ctx = NULL;
+	pci_release_regions(pci);
+	pci_disable_device(pci);
+	pci_set_drvdata(pci, NULL);
+}
+
+inline void sst_save_shim64(struct intel_sst_drv *ctx,
+			    void __iomem *shim,
+			    struct sst_shim_regs64 *shim_regs)
+{
+	unsigned long irq_flags;
+	spin_lock_irqsave(&ctx->ipc_spin_lock, irq_flags);
+
+	shim_regs->csr = sst_shim_read64(shim, SST_CSR),
+	shim_regs->pisr = sst_shim_read64(shim, SST_PISR),
+	shim_regs->pimr = sst_shim_read64(shim, SST_PIMR),
+	shim_regs->isrx = sst_shim_read64(shim, SST_ISRX),
+	shim_regs->isrd = sst_shim_read64(shim, SST_ISRD),
+	shim_regs->imrx = sst_shim_read64(shim, SST_IMRX),
+	shim_regs->imrd = sst_shim_read64(shim, SST_IMRD),
+	shim_regs->ipcx = sst_shim_read64(shim, ctx->ipc_reg.ipcx),
+	shim_regs->ipcd = sst_shim_read64(shim, ctx->ipc_reg.ipcd),
+	shim_regs->isrsc = sst_shim_read64(shim, SST_ISRSC),
+	shim_regs->isrlpesc = sst_shim_read64(shim, SST_ISRLPESC),
+	shim_regs->imrsc = sst_shim_read64(shim, SST_IMRSC),
+	shim_regs->imrlpesc = sst_shim_read64(shim, SST_IMRLPESC),
+	shim_regs->ipcsc = sst_shim_read64(shim, SST_IPCSC),
+	shim_regs->ipclpesc = sst_shim_read64(shim, SST_IPCLPESC),
+	shim_regs->clkctl = sst_shim_read64(shim, SST_CLKCTL),
+	shim_regs->csr2 = sst_shim_read64(shim, SST_CSR2);
+
+	spin_unlock_irqrestore(&ctx->ipc_spin_lock, irq_flags);
+}
+
+static inline void sst_restore_shim64(struct intel_sst_drv *ctx,
+				      void __iomem *shim,
+				      struct sst_shim_regs64 *shim_regs)
+{
+	unsigned long irq_flags;
+	spin_lock_irqsave(&ctx->ipc_spin_lock, irq_flags);
+	sst_shim_write64(shim, SST_IMRX, shim_regs->imrx),
+	spin_unlock_irqrestore(&ctx->ipc_spin_lock, irq_flags);
+}
+
+/*
+ * The runtime_suspend/resume is pretty much similar to the legacy
+ * suspend/resume with the noted exception below: The PCI core takes care of
+ * taking the system through D3hot and restoring it back to D0 and so there is
+ * no need to duplicate that here.
+ */
+static int intel_sst_runtime_suspend(struct device *dev)
+{
+	union config_status_reg csr;
+	int ret = 0;
+	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
+
+	pr_info("runtime_suspend called\n");
+	if (ctx->sst_state == SST_RESET) {
+		pr_debug("LPE is already in RESET state, No action");
+		return 0;
+	}
+	/*save fw context*/
+	if (ctx->ops->save_dsp_context(ctx))
+		return -EBUSY;
+
+	if (ctx->pci_id == SST_CLV_PCI_ID) {
+		/*Assert RESET on LPE Processor*/
+		csr.full = sst_shim_read(ctx->shim, SST_CSR);
+		ctx->csr_value = csr.full;
+		csr.full = csr.full | 0x2;
+		sst_shim_write(ctx->shim, SST_CSR, csr.full);
+	}
+
+	/* Move the SST state to Reset */
+	sst_set_fw_state_locked(ctx, SST_RESET);
+
+	flush_workqueue(ctx->post_msg_wq);
+	synchronize_irq(ctx->irq_num);
+
+	if (ctx->pci_id == SST_BYT_PCI_ID || ctx->pci_id == SST_CHT_PCI_ID) {
+		/* save the shim registers because PMC doesn't save state */
+		sst_save_shim64(ctx, ctx->shim, ctx->shim_regs64);
+	}
+	return ret;
+}
+
+static int intel_sst_runtime_resume(struct device *dev)
+{
+	u32 csr;
+	int ret = 0;
+	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
+
+	pr_info("runtime_resume called\n");
+
+	if (ctx->pci_id == SST_BYT_PCI_ID || ctx->pci_id == SST_CHT_PCI_ID) {
+		/* wait for device power up a/c to PCI spec */
+		usleep_range(10000, 11000);
+		sst_restore_shim64(ctx, ctx->shim, ctx->shim_regs64);
+	}
+
+	if (ctx->pci_id == SST_CLV_PCI_ID) {
+		csr = sst_shim_read(ctx->shim, SST_CSR);
+		/*
+		 * To restore the csr_value after S0ix and S3 states.
+		 * The value 0x30000 is to enable LPE dram high and low addresses.
+		 * Reference:
+		 * Penwell Audio Voice Module HAS 1.61 Section - 13.12.1 -
+		 * CSR - Configuration and Status Register.
+		 */
+		csr |= (ctx->csr_value | 0x30000);
+		sst_shim_write(ctx->shim, SST_CSR, csr);
+		if (sst_drv_ctx->pdata->ssp_data) {
+			if (ctx->pdata->ssp_data->gpio_in_use)
+				sst_set_gpio_conf(&ctx->pdata->ssp_data->gpio);
+		}
+	}
+	/* When fw_clear_cache is set, clear the cached firmware copy */
+	/* fw_clear_cache is set through debugfs support */
+	if (atomic_read(&ctx->fw_clear_cache) && ctx->fw_in_mem) {
+		pr_debug("Clearing the cached firmware\n");
+		kfree(ctx->fw_in_mem);
+		ctx->fw_in_mem = NULL;
+		atomic_set(&ctx->fw_clear_cache, 0);
+	}
+
+	sst_set_fw_state_locked(ctx, SST_RESET);
+
+	return ret;
+}
+
+static int intel_sst_suspend(struct device *dev)
+{
+	int retval = 0, usage_count;
+	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
+
+	usage_count = atomic_read(&ctx->pm_usage_count);
+	if (usage_count) {
+		pr_err("Ret error for suspend:%d\n", usage_count);
+		return -EBUSY;
+	}
+	retval = intel_sst_runtime_suspend(dev);
+
+	return retval;
+}
+
+static int intel_sst_runtime_idle(struct device *dev)
+{
+	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
+
+	pr_info("runtime_idle called\n");
+	if (ctx->sst_state != SST_RESET) {
+		pm_schedule_suspend(dev, SST_SUSPEND_DELAY);
+		return -EBUSY;
+	} else {
+		return 0;
+	}
+	return -EBUSY;
+
+}
+
+static void sst_do_shutdown(struct intel_sst_drv *ctx)
+{
+	int retval = 0;
+	unsigned int pvt_id;
+	struct ipc_post *msg = NULL;
+	struct sst_block *block = NULL;
+
+	pr_debug(" %s called\n", __func__);
+	if ((atomic_read(&ctx->pm_usage_count) == 0) ||
+		ctx->sst_state == SST_RESET) {
+		sst_set_fw_state_locked(ctx, SST_SHUTDOWN);
+		pr_debug("sst is already in suspended/RESET state\n");
+		return;
+	}
+	if (!ctx->use_32bit_ops)
+		return;
+
+	sst_set_fw_state_locked(ctx, SST_SHUTDOWN);
+	flush_workqueue(ctx->post_msg_wq);
+	pvt_id = sst_assign_pvt_id(ctx);
+	retval = sst_create_block_and_ipc_msg(&msg, false,
+			ctx, &block,
+			IPC_IA_PREPARE_SHUTDOWN, pvt_id);
+	if (retval) {
+		pr_err("sst_create_block returned error!\n");
+		return;
+	}
+	sst_fill_header(&msg->header, IPC_IA_PREPARE_SHUTDOWN, 0, pvt_id);
+	sst_add_to_dispatch_list_and_post(ctx, msg);
+	sst_wait_timeout(ctx, block);
+	sst_free_block(ctx, block);
+}
+
+
+/**
+* sst_pci_shutdown - PCI shutdown function
+*
+* @pci:        PCI device structure
+*
+* This function is called by OS when a device is shutdown/reboot
+*
+*/
+
+static void sst_pci_shutdown(struct pci_dev *pci)
+{
+	struct intel_sst_drv *ctx = pci_get_drvdata(pci);
+
+	pr_debug(" %s called\n", __func__);
+
+	sst_do_shutdown(ctx);
+	disable_irq_nosync(pci->irq);
+}
+
+/**
+* sst_acpi_shutdown - platform shutdown function
+*
+* @pci:        Platform device structure
+*
+* This function is called by OS when a device is shutdown/reboot
+*
+*/
+static void sst_acpi_shutdown(struct platform_device *pdev)
+{
+	struct intel_sst_drv *ctx = platform_get_drvdata(pdev);
+	int irq = platform_get_irq(pdev, 0);
+
+	pr_debug(" %s called\n", __func__);
+
+	sst_do_shutdown(ctx);
+	disable_irq_nosync(irq);
+}
+
+static const struct dev_pm_ops intel_sst_pm = {
+	.suspend = intel_sst_suspend,
+	.resume = intel_sst_runtime_resume,
+	.runtime_suspend = intel_sst_runtime_suspend,
+	.runtime_resume = intel_sst_runtime_resume,
+	.runtime_idle = intel_sst_runtime_idle,
+};
+
+static const struct acpi_device_id sst_acpi_ids[];
+
+struct sst_platform_info *sst_get_acpi_driver_data(const char *hid)
+{
+	const struct acpi_device_id *id;
+
+	pr_debug("%s", __func__);
+	for (id = sst_acpi_ids; id->id[0]; id++)
+		if (!strncmp(id->id, hid, 16))
+			return (struct sst_platform_info *)id->driver_data;
+	return NULL;
+}
+
+/* PCI Routines */
+static DEFINE_PCI_DEVICE_TABLE(intel_sst_ids) = {
+	{ PCI_VDEVICE(INTEL, SST_CLV_PCI_ID), 0},
+	{ PCI_VDEVICE(INTEL, SST_MRFLD_PCI_ID), 0},
+	{ 0, }
+};
+MODULE_DEVICE_TABLE(pci, intel_sst_ids);
+
+static const struct acpi_device_id sst_acpi_ids[] = {
+	{ "LPE0F28",  (kernel_ulong_t) &byt_rvp_platform_data },
+	{ "LPE0F281", (kernel_ulong_t) &byt_ffrd8_platform_data },
+	{ "80860F28", (kernel_ulong_t) &byt_ffrd8_platform_data },
+	{ "808622A8", (kernel_ulong_t) &cht_platform_data },
+	{ },
+};
+MODULE_DEVICE_TABLE(acpi, sst_acpi_ids);
+
+static struct pci_driver driver = {
+	.name = SST_DRV_NAME,
+	.id_table = intel_sst_ids,
+	.probe = intel_sst_probe,
+	.remove = intel_sst_remove,
+	.shutdown = sst_pci_shutdown,
+#ifdef CONFIG_PM
+	.driver = {
+		.pm = &intel_sst_pm,
+	},
+#endif
+};
+
+static struct platform_driver sst_acpi_driver = {
+	.driver = {
+		.name			= "intel_sst_acpi",
+		.owner			= THIS_MODULE,
+		.acpi_match_table	= ACPI_PTR(sst_acpi_ids),
+		.pm			= &intel_sst_pm,
+	},
+	.probe	= sst_acpi_probe,
+	.remove	= sst_acpi_remove,
+	.shutdown = sst_acpi_shutdown,
+};
+
+
+/**
+* intel_sst_init - Module init function
+*
+* Registers with PCI
+* Registers with /dev
+* Init all data strutures
+*/
+static int __init intel_sst_init(void)
+{
+	/* Init all variables, data structure etc....*/
+	int ret = 0;
+	pr_info("INFO: ******** SST DRIVER loading.. Ver: %s\n",
+				       SST_DRIVER_VERSION);
+
+	mutex_init(&drv_ctx_lock);
+	/* Register with PCI */
+	ret = pci_register_driver(&driver);
+	if (ret)
+		pr_err("PCI register failed\n");
+
+	ret = platform_driver_register(&sst_acpi_driver);
+	if (ret)
+		pr_err("ACPI register failed\n");
+	return ret;
+}
+
+/**
+* intel_sst_exit - Module exit function
+*
+* Unregisters with PCI
+* Unregisters with /dev
+* Frees all data strutures
+*/
+static void __exit intel_sst_exit(void)
+{
+	pci_unregister_driver(&driver);
+	platform_driver_unregister(&sst_acpi_driver);
+
+	pr_debug("driver unloaded\n");
+	sst_drv_ctx = NULL;
+	return;
+}
+
+module_init(intel_sst_init);
+module_exit(intel_sst_exit);
diff --git a/sound/soc/intel/sst/sst.h b/sound/soc/intel/sst/sst.h
new file mode 100644
index 0000000..8094c89
--- /dev/null
+++ b/sound/soc/intel/sst/sst.h
@@ -0,0 +1,933 @@
+
+/*
+ *  sst.h - Intel SST Driver for audio engine
+ *
+ *  Copyright (C) 2008-10 Intel Corporation
+ *  Authors:	Vinod Koul <vinod.koul@intel.com>
+ *		Harsha Priya <priya.harsha@intel.com>
+ *		Dharageswari R <dharageswari.r@intel.com>
+ *		KP Jeeja <jeeja.kp@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  Common private declarations for SST
+ */
+#ifndef __SST_H__
+#define __SST_H__
+
+#include <linux/dmaengine.h>
+#include <linux/pm_runtime.h>
+#include <linux/firmware.h>
+#include <linux/intel_mid_dma.h>
+#include <linux/lnw_gpio.h>
+#include <asm/platform_sst.h>
+#include <sound/intel_sst_ioctl.h>
+
+#define SST_DRIVER_VERSION "3.0.8"
+
+/* driver names */
+#define SST_DRV_NAME "intel_sst_driver"
+#define SST_CLV_PCI_ID	0x08E7
+#define SST_MRFLD_PCI_ID 0x119A
+#define SST_BYT_PCI_ID  0x0F28
+#define SST_CHT_PCI_ID 0x22A8
+
+#define SST_SUSPEND_DELAY 2000
+#define FW_CONTEXT_MEM (64*1024)
+#define SST_ICCM_BOUNDARY 4
+#define SST_CONFIG_SSP_SIGN 0x7ffe8001
+
+/* FIXME: All this info should come from platform data
+ * move this when the base framework is ready to pass
+ * platform data to SST driver
+ */
+#define MRFLD_FW_VIRTUAL_BASE 0xC0000000
+#define MRFLD_FW_DDR_BASE_OFFSET 0x0
+#define MRFLD_FW_FEATURE_BASE_OFFSET 0x4
+#define MRFLD_FW_BSS_RESET_BIT 0
+extern struct intel_sst_drv *sst_drv_ctx;
+enum sst_states {
+	SST_FW_LOADING = 1,
+	SST_FW_RUNNING,
+	SST_RESET,
+	SST_SHUTDOWN,
+};
+
+enum sst_algo_ops {
+	SST_SET_ALGO = 0,
+	SST_GET_ALGO = 1,
+};
+
+#define SST_BLOCK_TIMEOUT	1000
+
+/* SST register map */
+#define SST_CSR			0x00
+#define SST_PISR		0x08
+#define SST_PIMR		0x10
+#define SST_ISRX		0x18
+#define SST_ISRD		0x20
+#define SST_IMRX		0x28
+#define SST_IMRD		0x30
+#define SST_IPCX		0x38 /* IPC IA-SST */
+#define SST_IPCD		0x40 /* IPC SST-IA */
+#define SST_ISRSC		0x48
+#define SST_ISRLPESC		0x50
+#define SST_IMRSC		0x58
+#define SST_IMRLPESC		0x60
+#define SST_IPCSC		0x68
+#define SST_IPCLPESC		0x70
+#define SST_CLKCTL		0x78
+#define SST_CSR2		0x80
+
+#define SST_SHIM_BEGIN		SST_CSR
+#define SST_SHIM_END		SST_CSR2
+#define SST_SHIM_SIZE		0x88
+
+#define FW_SIGNATURE_SIZE	4
+
+/* stream states */
+enum sst_stream_states {
+	STREAM_UN_INIT	= 0,	/* Freed/Not used stream */
+	STREAM_RUNNING	= 1,	/* Running */
+	STREAM_PAUSED	= 2,	/* Paused stream */
+	STREAM_DECODE	= 3,	/* stream is in decoding only state */
+	STREAM_INIT	= 4,	/* stream init, waiting for data */
+	STREAM_RESET	= 5,	/* force reset on recovery */
+};
+
+enum sst_ram_type {
+	SST_IRAM	= 1,
+	SST_DRAM	= 2,
+	SST_DDR	= 5,
+	SST_CUSTOM_INFO	= 7,	/* consists of FW binary information */
+};
+
+/* SST shim registers to structure mapping  */
+union config_status_reg {
+	struct {
+		u32 mfld_strb:1;
+		u32 sst_reset:1;
+		u32 clk_sel:3;
+		u32 sst_clk:2;
+		u32 bypass:3;
+		u32 run_stall:1;
+		u32 rsvd1:2;
+		u32 strb_cntr_rst:1;
+		u32 rsvd:18;
+	} part;
+	u32 full;
+};
+
+union interrupt_reg {
+	struct {
+		u64 done_interrupt:1;
+		u64 busy_interrupt:1;
+		u64 rsvd:62;
+	} part;
+	u64 full;
+};
+
+union sst_imr_reg {
+	struct {
+		u32 done_interrupt:1;
+		u32 busy_interrupt:1;
+		u32 rsvd:30;
+	} part;
+	u32 full;
+};
+
+union sst_pisr_reg {
+	struct {
+		u32 pssp0:1;
+		u32 pssp1:1;
+		u32 rsvd0:3;
+		u32 dmac:1;
+		u32 rsvd1:26;
+	} part;
+	u32 full;
+};
+
+union sst_pimr_reg {
+	struct {
+		u32 ssp0:1;
+		u32 ssp1:1;
+		u32 rsvd0:3;
+		u32 dmac:1;
+		u32 rsvd1:10;
+		u32 ssp0_sc:1;
+		u32 ssp1_sc:1;
+		u32 rsvd2:3;
+		u32 dmac_sc:1;
+		u32 rsvd3:10;
+	} part;
+	u32 full;
+};
+
+union config_status_reg_mrfld {
+	struct {
+		u64 lpe_reset:1;
+		u64 lpe_reset_vector:1;
+		u64 runstall:1;
+		u64 pwaitmode:1;
+		u64 clk_sel:3;
+		u64 rsvd2:1;
+		u64 sst_clk:3;
+		u64 xt_snoop:1;
+		u64 rsvd3:4;
+		u64 clk_sel1:6;
+		u64 clk_enable:3;
+		u64 rsvd4:6;
+		u64 slim0baseclk:1;
+		u64 rsvd:32;
+	} part;
+	u64 full;
+};
+
+union interrupt_reg_mrfld {
+	struct {
+		u64 done_interrupt:1;
+		u64 busy_interrupt:1;
+		u64 rsvd:62;
+	} part;
+	u64 full;
+};
+
+union sst_imr_reg_mrfld {
+	struct {
+		u64 done_interrupt:1;
+		u64 busy_interrupt:1;
+		u64 rsvd:62;
+	} part;
+	u64 full;
+};
+
+/*This structure is used to block a user/fw data call to another
+fw/user call
+*/
+struct sst_block {
+	bool	condition; /* condition for blocking check */
+	int	ret_code; /* ret code when block is released */
+	void	*data; /* data to be appsed for block if any */
+	u32     size;
+	bool	on;
+	u32     msg_id;  /*msg_id = msgid in mfld/ctp, mrfld = 0 */
+	u32     drv_id; /* = str_id in mfld/ctp, = drv_id in mrfld*/
+	struct list_head node;
+};
+
+/**
+ * struct stream_info - structure that holds the stream information
+ *
+ * @status : stream current state
+ * @prev : stream prev state
+ * @ops : stream operation pb/cp/drm...
+ * @bufs: stream buffer list
+ * @lock : stream mutex for protecting state
+ * @pcm_substream : PCM substream
+ * @period_elapsed : PCM period elapsed callback
+ * @sfreq : stream sampling freq
+ * @str_type : stream type
+ * @cumm_bytes : cummulative bytes decoded
+ * @str_type : stream type
+ * @src : stream source
+ * @device : output device type (medfield only)
+ */
+struct stream_info {
+	unsigned int		status;
+	unsigned int		prev;
+	unsigned int		ops;
+	struct mutex		lock; /* mutex */
+	void			*pcm_substream;
+	void (*period_elapsed)	(void *pcm_substream);
+	unsigned int		sfreq;
+	u32			cumm_bytes;
+	void			*compr_cb_param;
+	void (*compr_cb)	(void *compr_cb_param);
+	void			*drain_cb_param;
+	void (*drain_notify)	(void *drain_cb_param);
+
+	unsigned int		num_ch;
+	unsigned int		pipe_id;
+	unsigned int		str_id;
+	unsigned int		task_id;
+};
+
+#define SST_FW_SIGN "$SST"
+#define SST_FW_LIB_SIGN "$LIB"
+
+/*
+ * struct fw_header - FW file headers
+ *
+ * @signature : FW signature
+ * @modules : # of modules
+ * @file_format : version of header format
+ * @reserved : reserved fields
+ */
+struct fw_header {
+	unsigned char signature[FW_SIGNATURE_SIZE]; /* FW signature */
+	u32 file_size; /* size of fw minus this header */
+	u32 modules; /*  # of modules */
+	u32 file_format; /* version of header format */
+	u32 reserved[4];
+};
+
+struct fw_module_header {
+	unsigned char signature[FW_SIGNATURE_SIZE]; /* module signature */
+	u32 mod_size; /* size of module */
+	u32 blocks; /* # of blocks */
+	u32 type; /* codec type, pp lib */
+	u32 entry_point;
+};
+
+struct fw_block_info {
+	enum sst_ram_type	type;	/* IRAM/DRAM */
+	u32			size;	/* Bytes */
+	u32			ram_offset; /* Offset in I/DRAM */
+	u32			rsvd;	/* Reserved field */
+};
+
+struct sst_ipc_msg_wq {
+	union ipc_header_mrfld mrfld_header;
+	struct ipc_dsp_hdr dsp_hdr;
+	char mailbox[SST_MAILBOX_SIZE];
+	struct work_struct	wq;
+	union ipc_header header;
+};
+
+struct sst_dma {
+	struct dma_chan *ch;
+	struct intel_mid_dma_slave slave;
+	struct device *dev;
+};
+
+struct sst_runtime_param {
+	struct snd_sst_runtime_params param;
+};
+
+struct sst_sg_list {
+	struct scatterlist *src;
+	struct scatterlist *dst;
+	int list_len;
+	unsigned int sg_idx;
+};
+
+struct sst_memcpy_list {
+	struct list_head memcpylist;
+	void *dstn;
+	const void *src;
+	u32 size;
+	bool is_io;
+};
+
+struct sst_debugfs {
+#ifdef CONFIG_DEBUG_FS
+	struct dentry		*root;
+#endif
+	int			runtime_pm_status;
+	void __iomem            *ssp[SST_MAX_SSP_PORTS];
+	void __iomem            *dma_reg[SST_MAX_DMA];
+	unsigned char get_params_data[1024];
+	ssize_t get_params_len;
+};
+
+struct lpe_log_buf_hdr {
+	u32 base_addr;
+	u32 end_addr;
+	u32 rd_addr;
+	u32 wr_addr;
+};
+
+struct snd_ssp_config {
+	int size;
+	char bytes[0];
+};
+
+struct snd_sst_probe_bytes {
+	u16 len;
+	char bytes[0];
+};
+
+#define PCI_DMAC_CLV_ID 0x08F0
+#define PCI_DMAC_MRFLD_ID 0x119B
+
+struct sst_ram_buf {
+	u32 size;
+	char *buf;
+};
+
+/* Firmware Module Information*/
+
+enum sst_lib_dwnld_status {
+	SST_LIB_NOT_FOUND = 0,
+	SST_LIB_FOUND,
+	SST_LIB_DOWNLOADED,
+};
+
+struct sst_module_info {
+	const char *name; /* Library name */
+	u32	id; /* Module ID */
+	u32	entry_pt; /* Module entry point */
+	u8	status; /* module status*/
+	u8	rsvd1;
+	u16	rsvd2;
+};
+
+/* Structure for managing the Library Region(1.5MB)
+ * in DDR in Merrifield
+ */
+struct sst_mem_mgr {
+	phys_addr_t current_base;
+	int avail;
+	unsigned int count;
+};
+
+struct sst_dump_buf {
+	/* buffers for iram-dram dump crash */
+	struct sst_ram_buf iram_buf;
+	struct sst_ram_buf dram_buf;
+};
+
+struct sst_ipc_reg {
+	int ipcx;
+	int ipcd;
+};
+
+struct sst_shim_regs64 {
+	u64 csr;
+	u64 pisr;
+	u64 pimr;
+	u64 isrx;
+	u64 isrd;
+	u64 imrx;
+	u64 imrd;
+	u64 ipcx;
+	u64 ipcd;
+	u64 isrsc;
+	u64 isrlpesc;
+	u64 imrsc;
+	u64 imrlpesc;
+	u64 ipcsc;
+	u64 ipclpesc;
+	u64 clkctl;
+	u64 csr2;
+};
+
+struct sst_vtsv_cache {
+	void *file1_in_mem;
+	u32 size1;
+	void *file2_in_mem;
+	u32 size2;
+};
+
+/***
+ *
+ * struct intel_sst_drv - driver ops
+ *
+ * @sst_state : current sst device state
+ * @pci_id : PCI device id loaded
+ * @shim : SST shim pointer
+ * @mailbox : SST mailbox pointer
+ * @iram : SST IRAM pointer
+ * @dram : SST DRAM pointer
+ * @pdata : SST info passed as a part of pci platform data
+ * @shim_phy_add : SST shim phy addr
+ * @shim_regs64: Struct to save shim registers
+ * @ipc_dispatch_list : ipc messages dispatched
+ * @rx_list : to copy the process_reply/process_msg from DSP
+ * @ipc_post_msg_wq : wq to post IPC messages context
+ * @ipc_post_msg : wq to post reply from FW context
+ * @mad_ops : MAD driver operations registered
+ * @mad_wq : MAD driver wq
+ * @post_msg_wq : wq to post IPC messages
+ * @streams : sst stream contexts
+ * @list_lock : sst driver list lock (deprecated)
+ * @ipc_spin_lock : spin lock to handle audio shim access and ipc queue
+ * @rx_msg_lock : spin lock to handle the rx messages from the DSP
+ * @scard_ops : sst card ops
+ * @pci : sst pci device struture
+ * @dev : pointer to current device struct
+ * @sst_lock : sst device lock
+ * @stream_lock : sst stream lock
+ * @pvt_id : sst private id
+ * @stream_cnt : total sst active stream count
+ * @pb_streams : total active pb streams
+ * @cp_streams : total active cp streams
+ * @audio_start : audio status
+ * @qos		: PM Qos struct
+ * firmware_name : Firmware / Library name
+ */
+struct intel_sst_drv {
+	int			sst_state;
+	int			irq_num;
+	unsigned int		pci_id;
+	bool			use_32bit_ops;
+	void __iomem		*ddr;
+	void __iomem		*shim;
+	void __iomem		*mailbox;
+	void __iomem		*iram;
+	void __iomem		*dram;
+	void __iomem		*ssp0;
+#if 0
+	void __iomem		*dma0;
+	void __iomem		*dma1;
+#endif
+	unsigned int		mailbox_add;
+	unsigned int		iram_base;
+	unsigned int		dram_base;
+	unsigned int		shim_phy_add;
+	unsigned int		iram_end;
+	unsigned int		dram_end;
+	unsigned int		ddr_end;
+	unsigned int		ddr_base;
+	unsigned int		mailbox_recv_offset;
+	atomic_t		pm_usage_count;
+	struct sst_shim_regs64	*shim_regs64;
+	struct list_head        block_list;
+	struct list_head	ipc_dispatch_list;
+	struct sst_platform_info *pdata;
+	struct sst_ipc_msg_wq   ipc_post_msg;
+	struct list_head	rx_list;
+	struct work_struct      ipc_post_msg_wq;
+	wait_queue_head_t	wait_queue;
+	struct workqueue_struct *mad_wq;
+	struct workqueue_struct *post_msg_wq;
+	unsigned int		tstamp;
+	struct stream_info	streams[MAX_NUM_STREAMS+1]; /*str_id 0 is not used*/
+	spinlock_t		ipc_spin_lock; /* lock for Shim reg access and ipc queue */
+	spinlock_t              block_lock; /* lock for adding block to block_list */
+	spinlock_t              pvt_id_lock; /* lock for allocating private id */
+	spinlock_t		rx_msg_lock;
+	struct pci_dev		*pci;
+	struct device		*dev;
+	unsigned int		pvt_id;
+	struct mutex            sst_lock;
+	struct mutex		stream_lock;
+	unsigned int		stream_cnt;
+	unsigned int		*fw_cntx;
+	unsigned int		fw_cntx_size;
+	unsigned int		csr_value;
+	struct sst_dma		dma;
+	void			*fw_in_mem;
+	struct sst_runtime_param runtime_param;
+	unsigned int		device_input_mixer;
+	struct mutex		mixer_ctrl_lock;
+	struct dma_async_tx_descriptor *desc;
+	struct sst_sg_list	fw_sg_list, library_list;
+	struct intel_sst_ops	*ops;
+	struct sst_debugfs	debugfs;
+	struct pm_qos_request	*qos;
+	struct sst_info	info;
+	unsigned int		use_dma;
+	unsigned int		use_lli;
+	atomic_t		fw_clear_context;
+	atomic_t		fw_clear_cache;
+	bool			lib_dwnld_reqd;
+	/* list used during FW download in memcpy mode */
+	struct list_head	memcpy_list;
+	/* list used during LIB download in memcpy mode */
+	struct list_head	libmemcpy_list;
+	/* holds the stucts of iram/dram local buffers for dump*/
+	struct sst_dump_buf	dump_buf;
+	/* Lock for CSR register change */
+	struct mutex		csr_lock;
+	/* byte control to set the probe stream */
+	struct snd_sst_probe_bytes *probe_bytes;
+	/* contains the ipc registers */
+	struct sst_ipc_reg	ipc_reg;
+	/* IMR region Library space memory manager */
+	struct sst_mem_mgr      lib_mem_mgr;
+	/* Contains the cached vtsv files*/
+	struct sst_vtsv_cache	vcache;
+	/* Pointer to device ID, now for same PCI_ID, HID will be
+	 * will be different for FDK and EDK2. This will be used
+	 * for devices where PCI or ACPI id is same but HID is
+	 * different
+	 */
+	const char *hid;
+	/* Holder for firmware name. Due to async call it needs to be
+	 * persistent till worker thread gets called
+	 */
+	char firmware_name[20];
+};
+
+extern struct intel_sst_drv *sst_drv_ctx;
+extern struct sst_platform_info byt_rvp_platform_data;
+extern struct sst_platform_info byt_ffrd8_platform_data;
+extern struct sst_platform_info cht_platform_data;
+
+/* misc definitions */
+#define FW_DWNL_ID 0xFF
+
+struct sst_fill_config {
+	u32 sign;
+	struct sst_board_config_data sst_bdata;
+	struct sst_platform_config_data sst_pdata;
+	u32 shim_phy_add;
+	u32 mailbox_add;
+} __packed;
+
+struct intel_sst_ops {
+	irqreturn_t (*interrupt) (int, void *);
+	irqreturn_t (*irq_thread) (int, void *);
+	void (*clear_interrupt) (void);
+	int (*start) (void);
+	int (*reset) (void);
+	void (*process_reply) (struct ipc_post *msg);
+	void (*post_message) (struct work_struct *work);
+	int (*sync_post_message) (struct ipc_post *msg);
+	void (*process_message) (struct ipc_post *msg);
+	void (*set_bypass)(bool set);
+	int (*save_dsp_context) (struct intel_sst_drv *sst);
+	void (*restore_dsp_context) (void);
+	int (*alloc_stream) (char *params, struct sst_block *block);
+	void (*post_download)(struct intel_sst_drv *sst);
+	void (*do_recovery)(struct intel_sst_drv *sst);
+};
+
+int sst_alloc_stream(char *params, struct sst_block *block);
+int sst_pause_stream(int id);
+int sst_resume_stream(int id);
+int sst_drop_stream(int id);
+int sst_next_track(void);
+int sst_free_stream(int id);
+int sst_start_stream(int str_id);
+int sst_send_byte_stream_mrfld(void *sbytes);
+int sst_send_probe_bytes(struct intel_sst_drv *sst);
+int sst_set_stream_param(int str_id, struct snd_sst_params *str_param);
+int sst_set_metadata(int str_id, char *params);
+int sst_get_stream(struct snd_sst_params *str_param);
+int sst_get_stream_allocated(struct snd_sst_params *str_param,
+				struct snd_sst_lib_download **lib_dnld);
+int sst_drain_stream(int str_id, bool partial_drain);
+
+
+int sst_sync_post_message_mfld(struct ipc_post *msg);
+void sst_post_message_mfld(struct work_struct *work);
+void sst_process_message_mfld(struct ipc_post *msg);
+void sst_process_reply_mfld(struct ipc_post *msg);
+int sst_start_mfld(void);
+int intel_sst_reset_dsp_mfld(void);
+void intel_sst_clear_intr_mfld(void);
+void intel_sst_set_bypass_mfld(bool set);
+
+int sst_sync_post_message_mrfld(struct ipc_post *msg);
+void sst_post_message_mrfld(struct work_struct *work);
+void sst_process_message_mrfld(struct ipc_post *msg);
+void sst_process_reply_mrfld(struct ipc_post *msg);
+int sst_start_mrfld(void);
+int intel_sst_reset_dsp_mrfld(void);
+void intel_sst_clear_intr_mrfld(void);
+void sst_process_mad_ops(struct work_struct *work);
+
+long intel_sst_ioctl(struct file *file_ptr, unsigned int cmd,
+			unsigned long arg);
+int intel_sst_open_cntrl(struct inode *i_node, struct file *file_ptr);
+int intel_sst_release_cntrl(struct inode *i_node, struct file *file_ptr);
+
+int sst_load_fw(void);
+int sst_load_library(struct snd_sst_lib_download *lib, u8 ops);
+int sst_load_all_modules_elf(struct intel_sst_drv *ctx,
+		struct sst_module_info *mod_table, int mod_table_size);
+int sst_get_next_lib_mem(struct sst_mem_mgr *mgr, int size,
+			unsigned long *lib_base);
+void sst_post_download_ctp(struct intel_sst_drv *ctx);
+void sst_post_download_mrfld(struct intel_sst_drv *ctx);
+void sst_post_download_byt(struct intel_sst_drv *ctx);
+int sst_get_block_stream(struct intel_sst_drv *sst_drv_ctx);
+void sst_memcpy_free_resources(void);
+
+int sst_wait_interruptible(struct intel_sst_drv *sst_drv_ctx,
+				struct sst_block *block);
+int sst_wait_timeout(struct intel_sst_drv *sst_drv_ctx,
+			struct sst_block *block);
+int sst_create_ipc_msg(struct ipc_post **arg, bool large);
+int sst_download_fw(void);
+int free_stream_context(unsigned int str_id);
+void sst_clean_stream(struct stream_info *stream);
+int intel_sst_register_compress(struct intel_sst_drv *sst);
+int intel_sst_remove_compress(struct intel_sst_drv *sst);
+void sst_cdev_fragment_elapsed(int str_id);
+int sst_send_sync_msg(int ipc, int str_id);
+int sst_get_num_channel(struct snd_sst_params *str_param);
+int sst_get_sfreq(struct snd_sst_params *str_param);
+int intel_sst_check_device(void);
+int sst_alloc_stream_ctp(char *params, struct sst_block *block);
+int sst_alloc_stream_mrfld(char *params, struct sst_block *block);
+void sst_restore_fw_context(void);
+struct sst_block *sst_create_block(struct intel_sst_drv *ctx,
+				u32 msg_id, u32 drv_id);
+int sst_create_block_and_ipc_msg(struct ipc_post **arg, bool large,
+		struct intel_sst_drv *sst_drv_ctx, struct sst_block **block,
+		u32 msg_id, u32 drv_id);
+int sst_free_block(struct intel_sst_drv *ctx, struct sst_block *freed);
+int sst_wake_up_block(struct intel_sst_drv *ctx, int result,
+		u32 drv_id, u32 ipc, void *data, u32 size);
+int sst_alloc_drv_context(struct device *dev);
+int sst_request_firmware_async(struct intel_sst_drv *ctx);
+int sst_driver_ops(struct intel_sst_drv *sst);
+struct sst_platform_info *sst_get_acpi_driver_data(const char *hid);
+int sst_acpi_probe(struct platform_device *pdev);
+int sst_acpi_remove(struct platform_device *pdev);
+void sst_save_shim64(struct intel_sst_drv *ctx, void __iomem *shim,
+		     struct sst_shim_regs64 *shim_regs);
+void sst_firmware_load_cb(const struct firmware *fw, void *context);
+int sst_send_vtsv_data_to_fw(struct intel_sst_drv *ctx);
+
+void sst_do_recovery_mrfld(struct intel_sst_drv *sst);
+void sst_do_recovery(struct intel_sst_drv *sst);
+long intel_sst_ioctl_dsp(unsigned int cmd,
+		struct snd_ppp_params *algo_params, unsigned long arg);
+
+void sst_dump_to_buffer(const void *from, size_t from_len, char *buf);
+
+extern int intel_scu_ipc_simple_command(int, int);
+
+static inline int sst_pm_runtime_put(struct intel_sst_drv *sst_drv)
+{
+	int ret;
+
+	ret = pm_runtime_put_sync(sst_drv->dev);
+	if (ret < 0)
+		return ret;
+	atomic_dec(&sst_drv->pm_usage_count);
+
+	pr_debug("%s: count is %d now..\n", __func__,
+			atomic_read(&sst_drv->pm_usage_count));
+	return 0;
+}
+/*
+ * sst_fill_header - inline to fill sst header
+ *
+ * @header : ipc header
+ * @msg : IPC message to be sent
+ * @large : is ipc large msg
+ * @str_id : stream id
+ *
+ * this function is an inline function that sets the headers before
+ * sending a message
+ */
+static inline void sst_fill_header(union ipc_header *header,
+				int msg, int large, int str_id)
+{
+	header->part.msg_id = msg;
+	header->part.str_id = str_id;
+	header->part.large = large;
+	header->part.done = 0;
+	header->part.busy = 1;
+	header->part.data = 0;
+}
+
+
+static inline void sst_fill_header_mrfld(union ipc_header_mrfld *header,
+				int msg, int task_id, int large, int drv_id)
+{
+	header->full = 0;
+	header->p.header_high.part.msg_id = msg;
+	header->p.header_high.part.task_id = task_id;
+	header->p.header_high.part.large = large;
+	header->p.header_high.part.drv_id = drv_id;
+	header->p.header_high.part.done = 0;
+	header->p.header_high.part.busy = 1;
+	header->p.header_high.part.res_rqd = 1;
+}
+
+static inline void sst_fill_header_dsp(struct ipc_dsp_hdr *dsp, int msg,
+					int pipe_id, int len)
+{
+	dsp->cmd_id = msg;
+	dsp->mod_index_id = 0xff;
+	dsp->pipe_id = pipe_id;
+	dsp->length = len;
+	dsp->mod_id = 0;
+}
+
+#define MAX_BLOCKS 15
+/* sst_assign_pvt_id - assign a pvt id for stream
+ *
+ * @sst_drv_ctx : driver context
+ *
+ * this inline function assigns a private id for calls that dont have stream
+ * context yet, should be called with lock held
+ */
+static inline unsigned int sst_assign_pvt_id(struct intel_sst_drv *sst_drv_ctx)
+{
+	unsigned int local;
+
+	spin_lock(&sst_drv_ctx->pvt_id_lock);
+	sst_drv_ctx->pvt_id++;
+	if (sst_drv_ctx->pvt_id > MAX_BLOCKS)
+		sst_drv_ctx->pvt_id = 1;
+	local = sst_drv_ctx->pvt_id;
+	spin_unlock(&sst_drv_ctx->pvt_id_lock);
+	return local;
+}
+
+
+/*
+ * sst_init_stream - this function initialzes stream context
+ *
+ * @stream : stream struture
+ * @codec : codec for stream
+ * @sst_id : stream id
+ * @ops : stream operation
+ * @slot : stream pcm slot
+ * @device : device type
+ *
+ * this inline function initialzes stream context for allocated stream
+ */
+static inline void sst_init_stream(struct stream_info *stream,
+		int codec, int sst_id, int ops, u8 slot)
+{
+	stream->status = STREAM_INIT;
+	stream->prev = STREAM_UN_INIT;
+	stream->ops = ops;
+}
+
+static inline void sst_set_gpio_conf(const struct sst_gpio_config *gpio_conf)
+{
+#if 0
+	lnw_gpio_set_alt(gpio_conf->i2s_rx_alt, gpio_conf->alt_function);
+	lnw_gpio_set_alt(gpio_conf->i2s_tx_alt, gpio_conf->alt_function);
+	lnw_gpio_set_alt(gpio_conf->i2s_frame, gpio_conf->alt_function);
+	lnw_gpio_set_alt(gpio_conf->i2s_clock, gpio_conf->alt_function);
+#endif
+}
+
+
+/*
+ * sst_validate_strid - this function validates the stream id
+ *
+ * @str_id : stream id to be validated
+ *
+ * returns 0 if valid stream
+ */
+static inline int sst_validate_strid(int str_id)
+{
+	if (str_id <= 0 || str_id > sst_drv_ctx->info.max_streams) {
+		pr_err("SST ERR: invalid stream id : %d, max %d\n",
+					str_id, sst_drv_ctx->info.max_streams);
+		return -EINVAL;
+	} else
+		return 0;
+}
+
+static inline int sst_shim_write(void __iomem *addr, int offset, int value)
+{
+	writel(value, addr + offset);
+	return 0;
+}
+
+static inline u32 sst_shim_read(void __iomem *addr, int offset)
+{
+
+	return readl(addr + offset);
+}
+
+static inline u32 sst_reg_read(void __iomem *addr, int offset)
+{
+
+	return readl(addr + offset);
+}
+
+static inline u64 sst_reg_read64(void __iomem *addr, int offset)
+{
+	u64 val = 0;
+
+	memcpy_fromio(&val, addr + offset, sizeof(val));
+
+	return val;
+}
+
+static inline int sst_shim_write64(void __iomem *addr, int offset, u64 value)
+{
+	memcpy_toio(addr + offset, &value, sizeof(value));
+	return 0;
+}
+
+static inline u64 sst_shim_read64(void __iomem *addr, int offset)
+{
+	u64 val = 0;
+
+	memcpy_fromio(&val, addr + offset, sizeof(val));
+	return val;
+}
+
+static inline void
+sst_set_fw_state_locked(struct intel_sst_drv *sst_drv_ctx, int sst_state)
+{
+	mutex_lock(&sst_drv_ctx->sst_lock);
+	sst_drv_ctx->sst_state = sst_state;
+	mutex_unlock(&sst_drv_ctx->sst_lock);
+}
+
+static inline struct stream_info *get_stream_info(int str_id)
+{
+	if (sst_validate_strid(str_id))
+		return NULL;
+	return &sst_drv_ctx->streams[str_id];
+}
+
+static inline int get_stream_id_mrfld(u32 pipe_id)
+{
+	int i;
+
+	for (i = 1; i <= sst_drv_ctx->info.max_streams; i++)
+		if (pipe_id == sst_drv_ctx->streams[i].pipe_id)
+			return i;
+
+	pr_debug("%s: no such pipe_id(%u)", __func__, pipe_id);
+	return -1;
+}
+
+int register_sst(struct device *);
+int unregister_sst(struct device *);
+
+#ifdef CONFIG_DEBUG_FS
+void sst_debugfs_init(struct intel_sst_drv *sst);
+void sst_debugfs_exit(struct intel_sst_drv *sst);
+#else
+static inline void sst_debugfs_init(struct intel_sst_drv *sst)
+{
+}
+
+static inline void sst_debugfs_exit(struct intel_sst_drv *sst)
+{
+}
+#endif /* CONFIG_DEBUG_FS */
+
+/*
+ * FW should use virtual address 0xC000_0000 to map to the DDR
+ * reserved 2MB region at 512MB boundary. Currently the address of
+ * DDR region allocated by IA FW is not 512MB aligned. So FW is
+ * statically linking the DDR region at 0xDF600000. So we need to
+ * use the translated address to identify the DDR regions in the FW
+ * ELF binary.
+ */
+static inline u32 relocate_imr_addr_mrfld(u32 base_addr)
+{
+	/* Get the difference from 512MB aligned base addr */
+	/* relocate the base */
+	base_addr = MRFLD_FW_VIRTUAL_BASE + (base_addr % (512 * 1024 * 1024));
+	return base_addr;
+}
+
+static inline void sst_add_to_dispatch_list_and_post(struct intel_sst_drv *sst,
+						struct ipc_post *msg)
+{
+	unsigned long irq_flags;
+	spin_lock_irqsave(&sst->ipc_spin_lock, irq_flags);
+	list_add_tail(&msg->node, &sst->ipc_dispatch_list);
+	spin_unlock_irqrestore(&sst->ipc_spin_lock, irq_flags);
+	sst->ops->post_message(&sst->ipc_post_msg_wq);
+}
+#endif
diff --git a/sound/soc/intel/sst/sst_acpi.c b/sound/soc/intel/sst/sst_acpi.c
new file mode 100644
index 0000000..1544a5f
--- /dev/null
+++ b/sound/soc/intel/sst/sst_acpi.c
@@ -0,0 +1,711 @@
+
+/* sst_acpi.c - SST (LPE) driver init file for ACPI enumeration.
+ *
+ * Copyright (c) 2013, Intel Corporation.
+ *
+ *  Authors:	Ramesh Babu K V <Ramesh.Babu@intel.com>
+ *  Authors:	Omair Mohammed Abdullah <omair.m.abdullah@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ *
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+#include <linux/firmware.h>
+#include <linux/pm_runtime.h>
+#include <linux/pm_qos.h>
+#include <asm/platform_byt_audio.h>
+#include <asm/platform_sst.h>
+#include <linux/acpi.h>
+#include <acpi/acbuffer.h>
+#include <acpi/platform/acenv.h>
+#include <acpi/platform/aclinux.h>
+#include <acpi/actypes.h>
+#include <acpi/acpi_bus.h>
+#include <sound/intel_sst_ioctl.h>
+#include "../sst_platform.h"
+#include "../platform_ipc_v2.h"
+#include "sst.h"
+
+extern struct miscdevice lpe_ctrl;
+
+static const struct sst_platform_config_data sst_byt_pdata = {
+	.sst_sram_buff_base	= 0xffffffff,
+	.sst_dma_base[0]	= SST_BYT_DMA0_PHY_ADDR,
+	.sst_dma_base[1]	= SST_BYT_DMA1_PHY_ADDR,
+};
+
+/* use array[0] for ssp_platform_data even though SSP2 is used */
+static const struct sst_board_config_data sst_byt_rvp_bdata = {
+	.active_ssp_ports = 1,
+	.platform_id = 3,
+	.board_id = 1,
+	.ihf_num_chan = 2,
+	.osc_clk_freq = 25000000,
+	.ssp_platform_data = {
+		[0] = {
+			.ssp_cfg_sst = 1,
+			.port_number = 2,
+			.is_master = 1,
+			.pack_mode = 1,
+			.num_slots_per_frame = 2,
+			.num_bits_per_slot = 24,
+			.active_tx_map = 3,
+			.active_rx_map = 3,
+			.ssp_frame_format = 3,
+			.frame_polarity = 1,
+			.serial_bitrate_clk_mode = 0,
+			.frame_sync_width = 24,
+			.dma_handshake_interface_tx = 5,
+			.dma_handshake_interface_rx = 4,
+			.network_mode = 0,
+			.start_delay = 1,
+			.ssp_base_add = SST_BYT_SSP2_PHY_ADDR,
+		},
+	},
+};
+
+static const struct sst_board_config_data sst_byt_ffrd8_bdata = {
+	.active_ssp_ports = 1,
+	.platform_id = 3,
+	.board_id = 1,
+	.ihf_num_chan = 2,
+	.osc_clk_freq = 25000000,
+	.ssp_platform_data = {
+		[0] = {
+			.ssp_cfg_sst = 1,
+			.port_number = 0,
+			.is_master = 1,
+			.pack_mode = 1,
+			.num_slots_per_frame = 2,
+			.num_bits_per_slot = 24,
+			.active_tx_map = 3,
+			.active_rx_map = 3,
+			.ssp_frame_format = 3,
+			.frame_polarity = 1,
+			.serial_bitrate_clk_mode = 0,
+			.frame_sync_width = 24,
+			.dma_handshake_interface_tx = 1,
+			.dma_handshake_interface_rx = 0,
+			.network_mode = 0,
+			.start_delay = 1,
+			.ssp_base_add = SST_BYT_SSP0_PHY_ADDR,
+		},
+	},
+};
+
+static const struct sst_board_config_data sst_byt_crv2_bdata = {
+	.active_ssp_ports = 1,
+	.platform_id = 3,
+	.board_id = 1,
+	.ihf_num_chan = 1,
+	.osc_clk_freq = 25000000,
+	.ssp_platform_data = {
+		[0] = {
+			.ssp_cfg_sst = 1,
+			.port_number = 0,
+			.is_master = 1,
+			.pack_mode = 1,
+			.num_slots_per_frame = 2,
+			.num_bits_per_slot = 24,
+			.active_tx_map = 3,
+			.active_rx_map = 3,
+			.ssp_frame_format = 3,
+			.frame_polarity = 1,
+			.serial_bitrate_clk_mode = 0,
+			.frame_sync_width = 24,
+			.dma_handshake_interface_tx = 1,
+			.dma_handshake_interface_rx = 0,
+			.network_mode = 0,
+			.start_delay = 1,
+			.ssp_base_add = SST_BYT_SSP0_PHY_ADDR,
+		},
+	},
+};
+
+static const struct sst_info byt_fwparse_info = {
+	.use_elf	= true,
+#ifndef CONFIG_SST_DPCM
+	.max_streams	= 4,
+#else
+	.max_streams	= 25,
+#endif
+	.dma_max_len	= SST_MAX_DMA_LEN_MRFLD,
+	.iram_start	= SST_BYT_IRAM_PHY_START,
+	.iram_end	= SST_BYT_IRAM_PHY_END,
+	.iram_use	= true,
+	.dram_start	= SST_BYT_DRAM_PHY_START,
+	.dram_end	= SST_BYT_DRAM_PHY_END,
+	.dram_use	= true,
+	.imr_start	= SST_BYT_IMR_VIRT_START,
+	.imr_end	= SST_BYT_IMR_VIRT_END,
+	.imr_use	= true,
+	.mailbox_start	= SST_BYT_MBOX_PHY_ADDR,
+	.num_probes	= 0,
+	.lpe_viewpt_rqd  = true,
+};
+
+
+static const struct sst_info cht_fwparse_info = {
+	.use_elf	= true,
+	.max_streams	= MAX_NUM_STREAMS_MRFLD,
+	.dma_max_len	= SST_MAX_DMA_LEN_MRFLD,
+	.iram_start	= SST_BYT_IRAM_PHY_START,
+	.iram_end	= SST_BYT_IRAM_PHY_END,
+	.iram_use	= true,
+	.dram_start	= SST_BYT_DRAM_PHY_START,
+	.dram_end	= SST_BYT_DRAM_PHY_END,
+	.dram_use	= true,
+	.imr_start	= SST_BYT_IMR_VIRT_START,
+	.imr_end	= SST_BYT_IMR_VIRT_END,
+	.imr_use	= true,
+	.mailbox_start	= SST_BYT_MBOX_PHY_ADDR,
+	.num_probes	= 0,
+	.lpe_viewpt_rqd = true,
+};
+
+static const struct sst_ipc_info byt_ipc_info = {
+#ifndef CONFIG_SST_DPCM
+	.use_32bit_ops = true,
+	.ipc_offset = 4,
+#else
+	.use_32bit_ops = false,
+	.ipc_offset = 0,
+#endif
+	.mbox_recv_off = 0x400,
+};
+
+static const struct sst_lib_dnld_info  byt_lib_dnld_info = {
+	.mod_base           = SST_BYT_IMR_VIRT_START,
+	.mod_end            = SST_BYT_IMR_VIRT_END,
+	.mod_table_offset   = BYT_FW_MOD_TABLE_OFFSET,
+	.mod_table_size     = BYT_FW_MOD_TABLE_SIZE,
+	.mod_ddr_dnld       = true,
+};
+
+static const struct sst_ipc_info cht_ipc_info = {
+	.use_32bit_ops = false,
+	.ipc_offset = 0,
+	.mbox_recv_off = 0x400,
+};
+
+struct sst_platform_info cht_platform_data = {
+	.probe_data = &cht_fwparse_info,
+	.ssp_data = NULL,
+	.bdata = NULL,
+	.pdata = NULL,
+	.ipc_info = &cht_ipc_info,
+	.lib_info = NULL,
+};
+
+struct sst_platform_info byt_rvp_platform_data = {
+	.probe_data = &byt_fwparse_info,
+	.ssp_data = NULL,
+	.bdata = &sst_byt_rvp_bdata,
+	.pdata = &sst_byt_pdata,
+	.ipc_info = &byt_ipc_info,
+	.lib_info = &byt_lib_dnld_info,
+};
+
+struct sst_platform_info byt_ffrd8_platform_data = {
+	.probe_data = &byt_fwparse_info,
+	.ssp_data = NULL,
+	.bdata = &sst_byt_ffrd8_bdata,
+	.pdata = &sst_byt_pdata,
+	.ipc_info = &byt_ipc_info,
+	.lib_info = &byt_lib_dnld_info,
+};
+
+int sst_workqueue_init(struct intel_sst_drv *ctx)
+{
+	pr_debug("%s", __func__);
+
+	INIT_LIST_HEAD(&ctx->memcpy_list);
+	INIT_LIST_HEAD(&ctx->libmemcpy_list);
+	INIT_LIST_HEAD(&sst_drv_ctx->rx_list);
+	INIT_LIST_HEAD(&ctx->ipc_dispatch_list);
+	INIT_LIST_HEAD(&ctx->block_list);
+	INIT_WORK(&ctx->ipc_post_msg.wq, ctx->ops->post_message);
+	init_waitqueue_head(&ctx->wait_queue);
+
+	ctx->mad_wq = create_singlethread_workqueue("sst_mad_wq");
+	if (!ctx->mad_wq)
+		goto err_wq;
+	ctx->post_msg_wq =
+		create_singlethread_workqueue("sst_post_msg_wq");
+	if (!ctx->post_msg_wq)
+		goto err_wq;
+	return 0;
+err_wq:
+	return -EBUSY;
+}
+
+void sst_init_locks(struct intel_sst_drv *ctx)
+{
+	mutex_init(&ctx->stream_lock);
+	mutex_init(&ctx->sst_lock);
+	mutex_init(&ctx->mixer_ctrl_lock);
+	mutex_init(&ctx->csr_lock);
+	spin_lock_init(&sst_drv_ctx->rx_msg_lock);
+	spin_lock_init(&ctx->ipc_spin_lock);
+	spin_lock_init(&ctx->block_lock);
+	spin_lock_init(&ctx->pvt_id_lock);
+}
+
+int sst_destroy_workqueue(struct intel_sst_drv *ctx)
+{
+	pr_debug("%s", __func__);
+	if (ctx->mad_wq)
+		destroy_workqueue(ctx->mad_wq);
+	if (ctx->post_msg_wq)
+		destroy_workqueue(ctx->post_msg_wq);
+	return 0;
+}
+
+#if IS_ENABLED(CONFIG_ACPI)
+static int sst_platform_get_resources_fdk(struct intel_sst_drv *ctx,
+				      struct platform_device *pdev)
+{
+	struct resource *rsrc;
+
+	pr_debug("%s", __func__);
+
+	/* All ACPI resource request here */
+	/* Get DDR addr from platform resource table */
+	rsrc = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!rsrc) {
+		pr_err("Invalid DDR base from IFWI");
+		return -EIO;
+	}
+	ctx->ddr_base = rsrc->start;
+	ctx->ddr_end = rsrc->end;
+	pr_debug("DDR base: %#x", ctx->ddr_base);
+	ctx->ddr = devm_ioremap_nocache(ctx->dev, ctx->ddr_base,
+					resource_size(rsrc));
+	if (!ctx->ddr) {
+		pr_err("unable to map DDR");
+		return -EIO;
+	}
+
+	/* Get Shim addr from platform resource table */
+	rsrc = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!rsrc) {
+		pr_err("Invalid SHIM base from IFWI");
+		return -EIO;
+	}
+	ctx->shim_phy_add = rsrc->start;
+	pr_debug("SHIM base: %#x", ctx->shim_phy_add);
+	ctx->shim = devm_ioremap_nocache(ctx->dev, ctx->shim_phy_add,
+					 resource_size(rsrc));
+	if (!ctx->shim) {
+		pr_err("unable to map SHIM");
+		return -EIO;
+	}
+	/* reassign physical address to LPE viewpoint address */
+	ctx->shim_phy_add = SST_BYT_SHIM_PHY_ADDR;
+
+	/* Get mailbox addr from platform resource table */
+	rsrc = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+	if (!rsrc) {
+		pr_err("Invalid Mailbox base from IFWI");
+		return -EIO;
+	}
+	ctx->mailbox_add = rsrc->start;
+	pr_debug("Mailbox base: %#x", ctx->mailbox_add);
+	ctx->mailbox = devm_ioremap_nocache(ctx->dev, ctx->mailbox_add,
+					    resource_size(rsrc));
+	if (!ctx->mailbox) {
+		pr_err("unable to map mailbox");
+		return -EIO;
+	}
+	/* reassign physical address to LPE viewpoint address */
+	ctx->mailbox_add = sst_drv_ctx->info.mailbox_start;
+
+	/* Get iram/iccm addr from platform resource table */
+	rsrc = platform_get_resource(pdev, IORESOURCE_MEM, 3);
+	if (!rsrc) {
+		pr_err("Invalid IRAM base from IFWI");
+		return -EIO;
+	}
+	ctx->iram_base = rsrc->start;
+	ctx->iram_end =  rsrc->end;
+	pr_debug("IRAM base: %#x", ctx->iram_base);
+	ctx->iram = devm_ioremap_nocache(ctx->dev, ctx->iram_base,
+					 resource_size(rsrc));
+	if (!ctx->iram) {
+		pr_err("unable to map IRAM");
+		return -EIO;
+	}
+
+	/* Get dram/dccm addr from platform resource table */
+	rsrc = platform_get_resource(pdev, IORESOURCE_MEM, 4);
+	if (!rsrc) {
+		pr_err("Invalid DRAM base from IFWI");
+		return -EIO;
+	}
+	ctx->dram_base = rsrc->start;
+	ctx->dram_end = rsrc->end;
+	pr_debug("DRAM base: %#x", ctx->dram_base);
+	ctx->dram = devm_ioremap_nocache(ctx->dev, ctx->dram_base,
+					 resource_size(rsrc));
+	if (!ctx->dram) {
+		pr_err("unable to map DRAM");
+		return -EIO;
+	}
+
+	/* Register the ISR */
+	ctx->irq_num = platform_get_irq(pdev, 0);
+	pr_debug("irq from pdev is:%d", ctx->irq_num);
+	return 0;
+}
+
+#define LPE_IRAM_OFFSET 0x0C0000
+#define LPE_IRAM_SIZE 0x040000
+#define LPE_DRAM_OFFSET 0x100000
+#define LPE_DRAM_SIZE 0x040000
+#define LPE_SHIM_OFFSET 0x140000
+#define LPE_SHIM_SIZE 0x004000
+#define LPE_MBOX_OFFSET 0x144000
+#define LPE_MBOX_SIZE 0x004000
+
+static int sst_platform_get_resources_edk(struct intel_sst_drv *ctx,
+				      struct platform_device *pdev)
+{
+	struct resource *rsrc;
+
+	pr_err("%s", __func__);
+
+	/* All ACPI resource request here */
+	/* Get Shim addr */
+	rsrc = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!rsrc) {
+		pr_err("Invalid SHIM base from IFWI");
+		return -EIO;
+	}
+	pr_err("LPE base: %#x size:%#x", (unsigned int) rsrc->start,
+					(unsigned int)resource_size(rsrc));
+
+	ctx->ssp0 = devm_ioremap_nocache(ctx->dev, (rsrc->start + 0xa0000),
+					 0x1000);
+	if (!ctx->ssp0)
+		pr_err("unable to map ssp0");
+#if 0
+	ctx->dma0 = devm_ioremap_nocache(ctx->dev, (rsrc->start + 0x98000),
+					 0x4000);
+	if (!ctx->dma0)
+		pr_err("unable to map DMA0");
+
+	ctx->dma1 = devm_ioremap_nocache(ctx->dev, (rsrc->start + 0x9c000),
+					 0x4000);
+	if (!ctx->dma1)
+		pr_err("unable to map DMA1");
+#endif
+
+	ctx->iram_base = rsrc->start + LPE_IRAM_OFFSET;
+	ctx->iram_end =  ctx->iram_base + LPE_IRAM_SIZE - 1;
+	pr_err("IRAM base: %#x", ctx->iram_base);
+	ctx->iram = devm_ioremap_nocache(ctx->dev, ctx->iram_base,
+					 LPE_IRAM_SIZE);
+	if (!ctx->iram) {
+		pr_err("unable to map IRAM");
+		return -EIO;
+	}
+
+	ctx->dram_base = rsrc->start + LPE_DRAM_OFFSET;
+	ctx->dram_end = ctx->dram_base + LPE_DRAM_SIZE - 1;
+	pr_err("DRAM base: %#x", ctx->dram_base);
+	ctx->dram = devm_ioremap_nocache(ctx->dev, ctx->dram_base,
+					 LPE_DRAM_SIZE);
+	if (!ctx->dram) {
+		pr_err("unable to map DRAM");
+		return -EIO;
+	}
+
+	ctx->shim_phy_add = rsrc->start + LPE_SHIM_OFFSET;
+	pr_err("SHIM base: %#x", ctx->shim_phy_add);
+	ctx->shim = devm_ioremap_nocache(ctx->dev, ctx->shim_phy_add,
+							LPE_SHIM_SIZE);
+	if (!ctx->shim) {
+		pr_err("unable to map SHIM");
+		return -EIO;
+	}
+	/* reassign physical address to LPE viewpoint address */
+	ctx->shim_phy_add = SST_BYT_SHIM_PHY_ADDR;
+
+	/* Get mailbox addr */
+	ctx->mailbox_add = rsrc->start + LPE_MBOX_OFFSET;
+	pr_err("Mailbox base: %#x", ctx->mailbox_add);
+	ctx->mailbox = devm_ioremap_nocache(ctx->dev, ctx->mailbox_add,
+					    LPE_MBOX_SIZE);
+	if (!ctx->mailbox) {
+		pr_err("unable to map mailbox");
+		return -EIO;
+	}
+
+	/* reassign physical address to LPE viewpoint address */
+	ctx->mailbox_add = sst_drv_ctx->info.mailbox_start;
+
+	rsrc = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+	if (!rsrc) {
+		pr_err("Invalid DDR base from IFWI");
+		return -EIO;
+	}
+	ctx->ddr_base = rsrc->start;
+	ctx->ddr_end = rsrc->end;
+	pr_err("DDR base: %#x", ctx->ddr_base);
+	ctx->ddr = devm_ioremap_nocache(ctx->dev, ctx->ddr_base,
+					resource_size(rsrc));
+	if (!ctx->ddr) {
+		pr_err("unable to map DDR");
+		return -EIO;
+	}
+	/* Register the ISR */
+	if (!strncmp(ctx->hid, "80860F28", 8))
+		ctx->irq_num = 0x1d;
+	else if (!strncmp(ctx->hid, "808622A8", 8)) {
+		/* FIXME: IRQ number will be moved to 0 once the BIOS fix is done */
+		ctx->irq_num = platform_get_irq(pdev, 5);
+	} else
+		return -EINVAL;
+	return 0;
+}
+
+static int sst_platform_get_resources(const char *hid,
+		struct intel_sst_drv *ctx, struct platform_device *pdev)
+{
+
+	pr_debug("%s", __func__);
+
+	if (!strncmp(hid, "LPE0F281", 8)) {
+		ctx->pci_id = SST_BYT_PCI_ID;
+		return sst_platform_get_resources_fdk(ctx, pdev);
+	}
+	if (!strncmp(hid, "808622A8", 8)) {
+		ctx->pci_id = SST_CHT_PCI_ID;
+		return sst_platform_get_resources_edk(ctx, pdev);
+	}
+	if (!strncmp(hid, "80860F28", 8)) {
+		ctx->pci_id = SST_BYT_PCI_ID;
+		return sst_platform_get_resources_edk(ctx, pdev);
+	} else if (!strncmp(hid, "LPE0F28", 7)) {
+		ctx->pci_id = SST_BYT_PCI_ID;
+		return sst_platform_get_resources_fdk(ctx, pdev);
+	} else {
+		pr_err("Invalid device\n");
+		return -EINVAL;
+	}
+}
+
+struct platform_device byt_rt5640_dev = {
+	.name		= "byt_rt5640",
+	.id		= -1,
+	.num_resources	= 0,
+
+};
+
+int sst_acpi_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	acpi_handle handle = ACPI_HANDLE(dev);
+	struct acpi_device *device;
+	const char *hid;
+	int i, ret = 0;
+	struct intel_sst_drv *ctx;
+	platform_device_register(&byt_rt5640_dev);
+
+	ret = acpi_bus_get_device(handle, &device);
+	if (ret) {
+		pr_err("%s: could not get acpi device - %d\n", __func__, ret);
+		return -ENODEV;
+	}
+
+	if (acpi_bus_get_status(device) || !device->status.present) {
+		pr_err("%s: device has invalid status", __func__);
+		return -ENODEV;
+	}
+
+	hid = acpi_device_hid(device);
+	pr_debug("%s for %s", __func__, hid);
+	ret = sst_alloc_drv_context(dev);
+	if (ret)
+		return ret;
+	ctx = sst_drv_ctx;
+	ctx->dev = dev;
+	ctx->hid = hid;
+
+	ret = sst_platform_get_resources(hid, ctx, pdev);
+	if (ret)
+		return ret;
+	/* need to save shim registers in BYT */
+	ctx->shim_regs64 = devm_kzalloc(dev, sizeof(*ctx->shim_regs64),
+					GFP_KERNEL);
+	if (!ctx->shim_regs64)
+		return -ENOMEM;
+
+	ret = sst_driver_ops(ctx);
+	if (ret != 0)
+		return -EINVAL;
+
+	sst_init_locks(ctx);
+
+	ctx->stream_cnt = 0;
+	ctx->fw_in_mem = NULL;
+	ctx->use_dma = 0;
+	ctx->use_lli = 0;
+
+	if (sst_workqueue_init(ctx)) {
+		ret = -EINVAL;
+		goto do_free_wq;
+	}
+
+	ctx->pdata = sst_get_acpi_driver_data(hid);
+	if (!ctx->pdata)
+		return -EINVAL;
+	ctx->pdata->bdata = &sst_byt_crv2_bdata;
+#if 0
+	if (INTEL_MID_BOARD(3, TABLET, BYT, BLK, PRO, CRV2)) {
+		/* BYT-CR V2 has only mono speaker, while
+		 * byt has stereo speaker, for both
+		 * HID is same, so platform data also is
+		 * same, hence overriding bdata based on spid
+		 */
+		ctx->pdata->bdata = &sst_byt_crv2_bdata;
+		pr_info("Overriding bdata for byt-crv2\n");
+	}
+#endif
+
+	ctx->use_32bit_ops = ctx->pdata->ipc_info->use_32bit_ops;
+	ctx->mailbox_recv_offset = ctx->pdata->ipc_info->mbox_recv_off;
+
+	memcpy(&ctx->info, ctx->pdata->probe_data, sizeof(ctx->info));
+
+	ctx->ipc_reg.ipcx = SST_IPCX + ctx->pdata->ipc_info->ipc_offset;
+	ctx->ipc_reg.ipcd = SST_IPCD + ctx->pdata->ipc_info->ipc_offset;
+
+	pr_debug("Got drv data max stream %d\n",
+				ctx->info.max_streams);
+	for (i = 1; i <= ctx->info.max_streams; i++) {
+		struct stream_info *stream = &ctx->streams[i];
+		mutex_init(&stream->lock);
+	}
+	ret = sst_request_firmware_async(ctx);
+	if (ret) {
+		pr_err("Firmware download failed:%d\n", ret);
+		goto do_free_wq;
+	}
+
+	ret = devm_request_threaded_irq(ctx->dev, ctx->irq_num, ctx->ops->interrupt,
+					ctx->ops->irq_thread, 0, SST_DRV_NAME,
+					ctx);
+	if (ret)
+		return ret;
+	pr_debug("Registered IRQ %#x\n", ctx->irq_num);
+
+	/*Register LPE Control as misc driver*/
+	ret = misc_register(&lpe_ctrl);
+	if (ret) {
+		pr_err("couldn't register control device\n");
+		goto do_free_wq;
+	}
+	/* mask all SSP and DMA irq to IA - enabled in acpi kernel driver */
+	sst_shim_write64(ctx->shim, SST_IMRX, 0xFFFF0038);
+
+	if (ctx->use_32bit_ops) {
+		pr_debug("allocate mem for context save/restore\n ");
+		/*allocate mem for fw context save during suspend*/
+		ctx->fw_cntx = devm_kzalloc(ctx->dev, FW_CONTEXT_MEM, GFP_KERNEL);
+		if (!ctx->fw_cntx) {
+			ret = -ENOMEM;
+			goto do_free_misc;
+		}
+		/*setting zero as that is valid mem to restore*/
+		ctx->fw_cntx_size = 0;
+	}
+
+	platform_set_drvdata(pdev, ctx);
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+	register_sst(dev);
+	sst_debugfs_init(ctx);
+	sst_set_fw_state_locked(ctx, SST_RESET);
+	sst_save_shim64(ctx, ctx->shim, ctx->shim_regs64);
+	pr_info("%s successfully done!\n", __func__);
+	return ret;
+
+do_free_misc:
+	misc_deregister(&lpe_ctrl);
+do_free_wq:
+	sst_destroy_workqueue(ctx);
+
+	sst_drv_ctx = NULL;
+	platform_set_drvdata(pdev, NULL);
+	pr_err("%s: failed with %d\n", __func__, ret);
+	return ret;
+}
+
+/**
+* intel_sst_remove - remove function
+*
+* @pdev:	platform device structure
+*
+* This function is called by OS when a device is unloaded
+* This frees the interrupt etc
+*/
+int sst_acpi_remove(struct platform_device *pdev)
+{
+	struct intel_sst_drv *ctx;
+
+	ctx = platform_get_drvdata(pdev);
+	sst_debugfs_exit(ctx);
+	pm_runtime_get_noresume(ctx->dev);
+	pm_runtime_disable(ctx->dev);
+	unregister_sst(ctx->dev);
+	sst_set_fw_state_locked(ctx, SST_SHUTDOWN);
+	misc_deregister(&lpe_ctrl);
+	kfree(ctx->runtime_param.param.addr);
+	flush_scheduled_work();
+	sst_destroy_workqueue(ctx);
+	kfree(ctx->fw_sg_list.src);
+	kfree(ctx->fw_sg_list.dst);
+	ctx->fw_sg_list.list_len = 0;
+	kfree(ctx->fw_in_mem);
+	ctx->fw_in_mem = NULL;
+	sst_memcpy_free_resources();
+	sst_drv_ctx = NULL;
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+#else
+int sst_acpi_probe(struct platform_device *pdev)
+{
+	return -EINVAL;
+}
+
+int sst_acpi_remove(struct platform_device *pdev)
+{
+	return -EINVAL;
+}
+#endif
+
+MODULE_DESCRIPTION("Intel (R) SST(R) Audio Engine ACPI Driver");
+MODULE_AUTHOR("Ramesh Babu K V");
+MODULE_AUTHOR("Omair Mohammed Abdullah");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("sst");
diff --git a/sound/soc/intel/sst/sst_app_compat_interface.c b/sound/soc/intel/sst/sst_app_compat_interface.c
new file mode 100644
index 0000000..79f5607
--- /dev/null
+++ b/sound/soc/intel/sst/sst_app_compat_interface.c
@@ -0,0 +1,81 @@
+
+/*
+ *  sst_app_compat_interface.c - Intel SST Driver for audio engine
+ *
+ *  Copyright (C) 2013-14 Intel Corp
+ *  Authors: Subhransu S. Prusty <subhransu.s.prusty@intel.com>
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *  This driver exposes the audio engine functionalities to the ALSA
+ *	and middleware.
+ */
+
+/* This file is included from sst.c */
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/compat.h>
+#include <linux/types.h>
+#include <sound/intel_sst_ioctl.h>
+#include "sst.h"
+
+struct snd_ppp_params32 {
+	__u8			algo_id;/* Post/Pre processing algorithm ID  */
+	__u8			str_id;	/*Only 5 bits used 0 - 31 are valid*/
+	__u8			enable;	/* 0= disable, 1= enable*/
+	__u8			operation;
+	__u32			size;	/*Size of parameters for all blocks*/
+	__u32			params;
+} __packed;
+
+enum {
+SNDRV_SST_SET_ALGO32 = _IOW('L', 0x30,  struct snd_ppp_params32),
+SNDRV_SST_GET_ALGO32 = _IOWR('L', 0x31,  struct snd_ppp_params32),
+};
+
+static long sst_algo_compat(unsigned int cmd,
+				struct snd_ppp_params32 __user *arg32)
+{
+	int retval = 0;
+	struct snd_ppp_params32 algo_params32;
+	struct snd_ppp_params algo_params;
+
+	if (copy_from_user(&algo_params32, arg32, sizeof(algo_params32))) {
+		pr_debug("%s: copy from user failed: %d\n", __func__, retval);
+		return -EINVAL;
+	}
+
+	memcpy(&algo_params, &algo_params32, sizeof(algo_params32)-sizeof(__u32));
+	algo_params.params = compat_ptr(algo_params32.params);
+	retval = intel_sst_ioctl_dsp(cmd, &algo_params, (unsigned long)arg32);
+	return retval;
+}
+
+static long intel_sst_ioctl_compat(struct file *file_ptr,
+				unsigned int cmd, unsigned long arg)
+{
+	void __user *argp = compat_ptr(arg);
+
+	switch (_IOC_NR(cmd)) {
+	case _IOC_NR(SNDRV_SST_DRIVER_INFO):
+	case _IOC_NR(SNDRV_SST_TUNING_PARAMS):
+		return intel_sst_ioctl(file_ptr, cmd, (unsigned long)argp);
+	case _IOC_NR(SNDRV_SST_SET_ALGO32):
+		return sst_algo_compat(SNDRV_SST_SET_ALGO, argp);
+	case _IOC_NR(SNDRV_SST_GET_ALGO32):
+		return sst_algo_compat(SNDRV_SST_GET_ALGO, argp);
+
+	default:
+		return -ENOTTY;
+	}
+	return 0;
+}
diff --git a/sound/soc/intel/sst/sst_app_interface.c b/sound/soc/intel/sst/sst_app_interface.c
new file mode 100644
index 0000000..c24b6cd
--- /dev/null
+++ b/sound/soc/intel/sst/sst_app_interface.c
@@ -0,0 +1,338 @@
+/*
+ *  sst_app_interface.c - Intel SST Driver for audio engine
+ *
+ *  Copyright (C) 2008-10 Intel Corp
+ *  Authors:	Vinod Koul <vinod.koul@intel.com>
+ *  Harsha Priya <priya.harsha@intel.com>
+ *  Dharageswari R <dharageswari.r@intel.com>
+ *  Jeeja KP <jeeja.kp@intel.com>
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *  This driver exposes the audio engine functionalities to the ALSA
+ *	and middleware.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/pci.h>
+#include <linux/fs.h>
+#include <linux/uio.h>
+#include <linux/aio.h>
+#include <linux/uaccess.h>
+#include <linux/firmware.h>
+#include <linux/ioctl.h>
+#include <sound/intel_sst_ioctl.h>
+#include "../sst_platform.h"
+#include "../platform_ipc_v2.h"
+#include "sst.h"
+
+#define AM_MODULE 1
+
+/**
+ * intel_sst_open_cntrl - opens a handle to driver
+ *
+ * @i_node:	inode structure
+ * @file_ptr:pointer to file
+ *
+ * This function is called by OS when a user space component
+ * tries to get a driver handle to /dev/intel_sst_control.
+ * Only one handle at a time will be allowed
+ * This is for control operations only
+ */
+int intel_sst_open_cntrl(struct inode *i_node, struct file *file_ptr)
+{
+	unsigned int retval;
+
+	/* audio manager open */
+	mutex_lock(&sst_drv_ctx->stream_lock);
+	retval = intel_sst_check_device();
+	if (retval) {
+		mutex_unlock(&sst_drv_ctx->stream_lock);
+		return retval;
+	}
+	pr_debug("AM handle opened\n");
+
+	mutex_unlock(&sst_drv_ctx->stream_lock);
+	return retval;
+}
+
+
+int intel_sst_release_cntrl(struct inode *i_node, struct file *file_ptr)
+{
+	/* audio manager close */
+	mutex_lock(&sst_drv_ctx->stream_lock);
+	sst_pm_runtime_put(sst_drv_ctx);
+	mutex_unlock(&sst_drv_ctx->stream_lock);
+	pr_debug("AM handle closed\n");
+	return 0;
+}
+
+/**
+ * sst_get_max_streams - Function to populate the drv info structure
+ *				with the max streams
+ * @info: the out params that holds the drv info
+ *
+ * This function is called when max streams count is required
+**/
+void sst_get_max_streams(struct snd_sst_driver_info *info)
+{
+	pr_debug("info.max_streams %d num_probes %d\n", sst_drv_ctx->info.max_streams,
+					sst_drv_ctx->info.num_probes);
+	info->max_streams = sst_drv_ctx->info.max_streams - sst_drv_ctx->info.num_probes;
+}
+
+/**
+ * sst_create_algo_ipc - create ipc msg for algorithm parameters
+ *
+ * @algo_params: Algorithm parameters
+ * @msg: post msg pointer
+ * @pvt_id: Checked by wake_up_block
+ *
+ * This function is called to create ipc msg
+ * For copying the mailbox data the function returns offset in bytes to mailbox
+ * memory where the mailbox data should be copied after msg header
+ */
+static int sst_create_algo_ipc(struct snd_ppp_params *algo_params,
+					struct ipc_post **msg, int pvt_id)
+{
+	u32 header_size = 0;
+	u32 ipc_msg_size = sizeof(u32) + sizeof(*algo_params)
+			 - sizeof(algo_params->params) + algo_params->size;
+	u32 offset = 0;
+
+	if (ipc_msg_size > SST_MAILBOX_SIZE)
+		return -ENOMEM;
+	if (sst_create_ipc_msg(msg, true))
+		return -ENOMEM;
+	sst_fill_header(&(*msg)->header,
+			IPC_IA_ALG_PARAMS, 1, pvt_id);
+	(*msg)->header.part.data = ipc_msg_size;
+	memcpy((*msg)->mailbox_data, &(*msg)->header, sizeof(u32));
+	offset = sizeof(u32);
+	header_size = sizeof(*algo_params) - sizeof(algo_params->params);
+	memcpy((*msg)->mailbox_data + offset, algo_params, header_size);
+	offset += header_size;
+	return offset;
+}
+
+static long sst_send_algo(struct snd_ppp_params *algo_params,
+		struct sst_block *block, enum sst_algo_ops algo)
+{
+	struct ipc_post *msg;
+	int retval;
+	int offset;
+
+	pr_debug("Algo ID %d Str id %d Enable %d Size %d\n",
+		algo_params->algo_id, algo_params->str_id,
+		algo_params->enable, algo_params->size);
+
+	algo_params->operation = algo;
+
+	offset = sst_create_algo_ipc(algo_params, &msg, block->drv_id);
+	if (offset < 0)
+		return offset;
+
+	if (copy_from_user(msg->mailbox_data + offset,
+			algo_params->params, algo_params->size)) {
+		kfree(msg);
+		return -EFAULT;
+	}
+
+	sst_add_to_dispatch_list_and_post(sst_drv_ctx, msg);
+	retval = sst_wait_timeout(sst_drv_ctx, block);
+	if (retval) {
+		pr_debug("%s: failed for algo ops %s with retval %d\n",
+				__func__, algo ? "SST_GET_ALGO" : "SST_SET_ALGO", retval);
+		return -EIO;
+	}
+	return 0;
+}
+
+/**
+ * intel_sst_ioctl_dsp - receives the device ioctl's
+ *
+ * @cmd:Ioctl cmd
+ * @arg:data
+ *
+ * This function is called when a user space component
+ * sends a DSP Ioctl to SST driver
+ */
+long intel_sst_ioctl_dsp(unsigned int cmd,
+		struct snd_ppp_params *algo_params, unsigned long arg)
+{
+	int retval = 0;
+	struct snd_ppp_params *algo_params_copied;
+	struct sst_block *block;
+	int pvt_id;
+
+	pvt_id = sst_assign_pvt_id(sst_drv_ctx);
+	block = sst_create_block(sst_drv_ctx, IPC_IA_ALG_PARAMS, pvt_id);
+	if (block == NULL)
+		return -ENOMEM;
+
+	switch (_IOC_NR(cmd)) {
+	case _IOC_NR(SNDRV_SST_SET_ALGO):
+		retval = sst_send_algo(algo_params, block, SST_SET_ALGO);
+		break;
+
+	case _IOC_NR(SNDRV_SST_GET_ALGO):
+		retval = sst_send_algo(algo_params, block, SST_GET_ALGO);
+		if (retval)
+			break;
+		algo_params_copied = (struct snd_ppp_params *)block->data;
+
+		if (algo_params_copied->size > algo_params->size) {
+			pr_debug("mem insufficient to copy\n");
+			retval = -EMSGSIZE;
+			break;
+		} else {
+			char __user *tmp;
+			struct snd_ppp_params *get_params;
+			char *pp;
+
+			tmp = (char __user *)arg + offsetof(
+					struct snd_ppp_params, size);
+			if (copy_to_user(tmp, &algo_params_copied->size,
+						 sizeof(u32))) {
+				retval = -EFAULT;
+				break;
+			}
+			tmp = (char __user *)arg + offsetof(
+					struct snd_ppp_params, enable);
+			if (copy_to_user(tmp, &algo_params_copied->enable,
+						 sizeof(u8))) {
+				retval = -EFAULT;
+				break;
+			}
+			if (algo_params_copied->size == 0)
+				break;
+
+			get_params = kmalloc(sizeof(*get_params), GFP_KERNEL);
+			if (!get_params) {
+				pr_err("sst: mem alloc failed\n");
+				break;
+			}
+			memcpy(get_params, algo_params_copied,
+							sizeof(*get_params));
+
+			get_params->params = kmalloc(get_params->size, GFP_KERNEL);
+			if (!get_params->params) {
+				pr_err("sst: mem alloc failed\n");
+				goto free_mem;
+			}
+			pp = (char *)algo_params_copied;
+			pp = pp + sizeof(*get_params) -
+						sizeof(get_params->params);
+			memcpy(get_params->params, pp, get_params->size);
+			if (copy_to_user(algo_params->params,
+					get_params->params,
+					get_params->size)) {
+				retval = -EFAULT;
+			}
+			kfree(get_params->params);
+
+free_mem:
+			kfree(get_params);
+
+		}
+		break;
+	}
+	sst_free_block(sst_drv_ctx, block);
+	pr_debug("ioctl dsp return = %d, for cmd = %x\n", retval, cmd);
+	return retval;
+}
+
+static long sst_ioctl_tuning_params(unsigned int cmd, unsigned long arg)
+{
+	struct snd_sst_tuning_params params;
+	struct ipc_post *msg;
+	unsigned long address;
+
+	if (copy_from_user(&params, (void __user *)arg, sizeof(params)))
+		return -EFAULT;
+	pr_debug("sst: Parameter %d, Stream %d, Size %d\n", params.type,
+			params.str_id, params.size);
+	if (sst_create_ipc_msg(&msg, true))
+		return -ENOMEM;
+	address = (unsigned long)params.addr;
+
+	switch (_IOC_NR(cmd)) {
+	case _IOC_NR(SNDRV_SST_TUNING_PARAMS):
+		sst_fill_header(&msg->header, IPC_IA_TUNING_PARAMS, 1,
+				params.str_id);
+		break;
+	}
+	msg->header.part.data = sizeof(u32) + sizeof(params) + params.size;
+	memcpy(msg->mailbox_data, &msg->header.full, sizeof(u32));
+	memcpy(msg->mailbox_data + sizeof(u32), &params, sizeof(params));
+	/* driver doesn't need to send address, so overwrite addr with data */
+	if (copy_from_user(msg->mailbox_data + sizeof(u32)
+				+ sizeof(params) - sizeof(params.addr),
+			(void __user *)address, params.size)) {
+		kfree(msg->mailbox_data);
+		kfree(msg);
+		return -EFAULT;
+	}
+
+	sst_add_to_dispatch_list_and_post(sst_drv_ctx, msg);
+	return 0;
+}
+/**
+ * intel_sst_ioctl - receives the device ioctl's
+ * @file_ptr:pointer to file
+ * @cmd:Ioctl cmd
+ * @arg:data
+ *
+ * This function is called by OS when a user space component
+ * sends an Ioctl to SST driver
+ */
+long intel_sst_ioctl(struct file *file_ptr, unsigned int cmd, unsigned long arg)
+{
+	int retval = 0;
+	struct snd_ppp_params algo_params;
+
+	if (sst_drv_ctx->sst_state != SST_FW_RUNNING)
+		return -EBUSY;
+
+	switch (_IOC_NR(cmd)) {
+	case _IOC_NR(SNDRV_SST_DRIVER_INFO): {
+		struct snd_sst_driver_info info;
+
+		pr_debug("SNDRV_SST_DRIVER_INFO received\n");
+		sst_get_max_streams(&info);
+
+		if (copy_to_user((void __user *)arg, &info,
+				sizeof(info)))
+			retval = -EFAULT;
+		break;
+	}
+	case _IOC_NR(SNDRV_SST_GET_ALGO):
+	case _IOC_NR(SNDRV_SST_SET_ALGO):
+		if (copy_from_user(&algo_params, (void __user *)arg,
+						sizeof(algo_params))) {
+			return -EFAULT;
+		}
+		retval = intel_sst_ioctl_dsp(cmd, &algo_params, arg);
+		break;
+
+	case _IOC_NR(SNDRV_SST_TUNING_PARAMS):
+		retval = sst_ioctl_tuning_params(cmd, arg);
+		break;
+
+	default:
+		retval = -EINVAL;
+	}
+	pr_debug("intel_sst_ioctl:complete ret code = %d for command = %x\n", retval, cmd);
+	return retval;
+}
+
diff --git a/sound/soc/intel/sst/sst_debug.c b/sound/soc/intel/sst/sst_debug.c
new file mode 100644
index 0000000..8b7e778
--- /dev/null
+++ b/sound/soc/intel/sst/sst_debug.c
@@ -0,0 +1,1368 @@
+/*
+ *  sst_debug.c - Intel SST Driver debugfs support
+ *
+ *  Copyright (C) 2012	Intel Corp
+ *  Authors:	Vinod Koul <vinod.koul@intel.com>
+ *		Omair Mohammed Abdullah <omair.m.abdullah@linux.intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This file contains all debugfs functions
+ *  Support includes:
+ *   - Disabling/Enabling runtime PM for SST
+ *   - Reading/Writing SST SHIM registers
+ *   - Reading/Enabling Input OSC Clock
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": debugfs: " fmt
+
+#include <linux/fs.h>
+#include <linux/pci.h>
+#include <linux/ctype.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/pm_runtime.h>
+#include <linux/uaccess.h>
+#include "../sst_platform.h"
+#include "../platform_ipc_v2.h"
+#include "sst.h"
+
+#define DMA_NUM_CH	8
+#define DEBUGFS_SSP_BUF_SIZE	300  /* 22 chars * 12 reg*/
+#define DEBUGFS_DMA_BUF_SIZE	2500 /* 32 chars * 78 regs*/
+
+/* Register Offsets of SSP3 and LPE DMA */
+u32 ssp_reg_off[] = {0x0, 0x4, 0x8, 0xC, 0x10, 0x28, 0x2C, 0x30, 0x34, 0x38,
+			0x3C, 0x40};
+/* Excludes the channel registers */
+u32 dma_reg_off[] = {0x2C0, 0x2C8, 0x2D0, 0x2D8, 0x2E0, 0x2E8,
+		0x2F0, 0x2F8, 0x300, 0x308, 0x310, 0x318, 0x320, 0x328, 0x330,
+		0x338, 0x340, 0x348, 0x350, 0x358, 0x360, 0x368, 0x370, 0x378,
+		0x380, 0x388, 0x390, 0x398, 0x3A0, 0x3A8, 0x3B0, 0x3C8, 0x3D0,
+		0x3D8, 0x3E0, 0x3E8, 0x3F0, 0x3F8};
+
+static inline int is_fw_running(struct intel_sst_drv *drv);
+
+static ssize_t sst_debug_shim_read(struct file *file, char __user *user_buf,
+				   size_t count, loff_t *ppos)
+{
+	struct intel_sst_drv *drv = file->private_data;
+	unsigned long long val = 0;
+	unsigned int addr;
+	char buf[512];
+	char name[8];
+	int pos = 0, ret = 0;
+
+	buf[0] = 0;
+
+	ret = is_fw_running(drv);
+	if (ret) {
+		pr_err("FW not running, cannot read SHIM registers\n");
+		return ret;
+	}
+
+	for (addr = SST_SHIM_BEGIN; addr <= SST_SHIM_END; addr += 8) {
+		switch (drv->pci_id) {
+		case SST_CLV_PCI_ID:
+			val = sst_shim_read(drv->shim, addr);
+			break;
+		case SST_MRFLD_PCI_ID:
+		case SST_BYT_PCI_ID:
+		case SST_CHT_PCI_ID:
+			val = sst_shim_read64(drv->shim, addr);
+			break;
+		}
+
+		name[0] = 0;
+		switch (addr) {
+		case SST_ISRX:
+			strcpy(name, "ISRX"); break;
+		case SST_ISRD:
+			strcpy(name, "ISRD"); break;
+		case SST_IPCX:
+			strcpy(name, "IPCX"); break;
+		case SST_IPCD:
+			strcpy(name, "IPCD"); break;
+		case SST_IMRX:
+			strcpy(name, "IMRX"); break;
+		case SST_IMRD:
+			strcpy(name, "IMRD"); break;
+		}
+		pos += sprintf(buf + pos, "0x%.2x: %.8llx  %s\n", addr, val, name);
+	}
+
+	sst_pm_runtime_put(drv);
+	return simple_read_from_buffer(user_buf, count, ppos,
+			buf, strlen(buf));
+}
+
+
+
+static ssize_t sst_debug_shim_write(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct intel_sst_drv *drv = file->private_data;
+	char buf[32];
+	char *start = buf, *end;
+	unsigned long long value;
+	unsigned long reg_addr;
+	int ret_val = 0;
+	size_t buf_size = min(count, sizeof(buf)-1);
+
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+	buf[buf_size] = 0;
+
+	ret_val = is_fw_running(drv);
+	if (ret_val) {
+		pr_err("FW not running, cannot read SHIM registers\n");
+		return ret_val;
+	}
+
+	while (*start == ' ')
+		start++;
+	end = start;
+	while (isalnum(*end))
+		end++;
+	*end = 0;
+
+	ret_val = kstrtoul(start, 16, &reg_addr);
+	if (ret_val) {
+		pr_err("kstrtoul failed, ret_val = %d\n", ret_val);
+		goto put_pm_runtime;
+	}
+	if (!(SST_SHIM_BEGIN < reg_addr && reg_addr < SST_SHIM_END)) {
+		pr_err("invalid shim address: 0x%lx\n", reg_addr);
+		ret_val = -EINVAL;
+		goto put_pm_runtime;
+	}
+
+	start = end + 1;
+	while (*start == ' ')
+		start++;
+
+	ret_val = kstrtoull(start, 16, &value);
+	if (ret_val) {
+		pr_err("kstrtoul failed, ret_val = %d\n", ret_val);
+		goto put_pm_runtime;
+	}
+
+	pr_debug("writing shim: 0x%.2lx=0x%.8llx", reg_addr, value);
+
+	if (drv->pci_id == SST_CLV_PCI_ID)
+		sst_shim_write(drv->shim, reg_addr, (u32) value);
+	else if (drv->pci_id == SST_MRFLD_PCI_ID) /*||
+			(drv->pci_id == PCI_DEVICE_ID_INTEL_SST_MOOR)) */
+		sst_shim_write64(drv->shim, reg_addr, (u64) value);
+
+	/* Userspace has been fiddling around behind the kernel's back */
+	add_taint(TAINT_USER, LOCKDEP_NOW_UNRELIABLE);
+	ret_val = buf_size;
+
+put_pm_runtime:
+	sst_pm_runtime_put(drv);
+	return ret_val;
+}
+
+static const struct file_operations sst_debug_shim_ops = {
+	.open = simple_open,
+	.read = sst_debug_shim_read,
+	.write = sst_debug_shim_write,
+	.llseek = default_llseek,
+};
+
+#define RESVD_DUMP_SZ		40
+#define IA_LPE_MAILBOX_DUMP_SZ	100
+#define LPE_IA_MAILBOX_DUMP_SZ	100
+#define SCU_LPE_MAILBOX_DUMP_SZ	256
+#define LPE_SCU_MAILBOX_DUMP_SZ	256
+
+static inline int is_fw_running(struct intel_sst_drv *drv)
+{
+	pm_runtime_get_sync(drv->dev);
+	atomic_inc(&drv->pm_usage_count);
+	if (drv->sst_state != SST_FW_RUNNING) {
+		pr_err("FW not running\n");
+		sst_pm_runtime_put(drv);
+		return -EFAULT;
+	}
+	return 0;
+}
+
+static inline int read_buffer_fromio(char *dest, unsigned int sz,
+				     const u32 __iomem *from,
+				     unsigned int num_dwords)
+{
+	int i;
+	const unsigned int rowsz = 16, groupsz = 4;
+	const unsigned int size = num_dwords * sizeof(u32);
+	unsigned int linelen, printed = 0, remaining = size;
+
+	u8 *tmp = kmalloc(size, GFP_KERNEL);
+	if (!tmp)
+		return -ENOMEM;
+	memcpy_fromio(tmp, from, size);
+	for (i = 0; i < size; i += rowsz) {
+		linelen = min(remaining, rowsz);
+		remaining -= rowsz;
+		hex_dump_to_buffer(tmp + i, linelen, rowsz, groupsz,
+				   dest + printed, sz - printed, false);
+		printed += linelen * 2 + linelen / groupsz - 1;
+		*(dest + printed++) = '\n';
+		*(dest + printed) = 0;
+	}
+	kfree(tmp);
+	return 0;
+}
+
+static inline int copy_sram_to_user_buffer(char __user *user_buf, size_t count, loff_t *ppos,
+					   unsigned int num_dwords, const u32 __iomem *from,
+					   u32 offset)
+{
+	ssize_t bytes_read;
+	char *buf;
+	int pos;
+	unsigned int bufsz = 48 + sizeof(u32) * num_dwords * (2 + 1) + 1;
+
+	buf = kmalloc(bufsz, GFP_KERNEL);
+	if (!buf) {
+		pr_err("%s: no memory\n", __func__);
+		return -ENOMEM;
+	}
+	*buf = 0;
+	pos = scnprintf(buf, 48, "Reading %u dwords from offset %#x\n",
+			num_dwords, offset);
+	read_buffer_fromio(buf + pos, bufsz - pos, from, num_dwords);
+	bytes_read = simple_read_from_buffer(user_buf, count, ppos,
+					     buf, strlen(buf));
+	kfree(buf);
+	return bytes_read;
+}
+
+static ssize_t sst_debug_sram_lpe_debug_read(struct file *file,
+		char __user *user_buf, size_t count, loff_t *ppos)
+{
+
+	struct intel_sst_drv *drv = file->private_data;
+	int ret = 0;
+
+	ret = is_fw_running(drv);
+	if (ret)
+		return ret;
+
+	ret = copy_sram_to_user_buffer(user_buf, count, ppos, RESVD_DUMP_SZ,
+				       (u32 *)(drv->mailbox + SST_RESERVED_OFFSET),
+				       SST_RESERVED_OFFSET);
+	sst_pm_runtime_put(drv);
+	return ret;
+}
+
+static const struct file_operations sst_debug_sram_lpe_debug_ops = {
+	.open = simple_open,
+	.read = sst_debug_sram_lpe_debug_read,
+	.llseek = default_llseek,
+};
+
+static ssize_t sst_debug_sram_lpe_checkpoint_read(struct file *file,
+		char __user *user_buf, size_t count, loff_t *ppos)
+{
+
+	struct intel_sst_drv *drv = file->private_data;
+	int ret = 0;
+	u32 offset;
+
+	ret = is_fw_running(drv);
+	if (ret)
+		return ret;
+
+	offset = sst_drv_ctx->pdata->debugfs_data->checkpoint_offset;
+
+	ret = copy_sram_to_user_buffer(user_buf, count, ppos,
+				sst_drv_ctx->pdata->debugfs_data->checkpoint_size,
+				(u32 *)(drv->mailbox + offset), offset);
+	sst_pm_runtime_put(drv);
+	return ret;
+}
+
+static const struct file_operations sst_debug_sram_lpe_checkpoint_ops = {
+	.open = simple_open,
+	.read = sst_debug_sram_lpe_checkpoint_read,
+	.llseek = default_llseek,
+};
+
+static ssize_t sst_debug_sram_ia_lpe_mbox_read(struct file *file,
+		char __user *user_buf, size_t count, loff_t *ppos)
+{
+
+	struct intel_sst_drv *drv = file->private_data;
+	int ret = 0;
+
+	ret = is_fw_running(drv);
+	if (ret)
+		return ret;
+	ret = copy_sram_to_user_buffer(user_buf, count, ppos, IA_LPE_MAILBOX_DUMP_SZ,
+				       (u32 *)(drv->mailbox + SST_MAILBOX_SEND),
+				       SST_MAILBOX_SEND);
+	sst_pm_runtime_put(drv);
+	return ret;
+}
+
+static const struct file_operations sst_debug_sram_ia_lpe_mbox_ops = {
+	.open = simple_open,
+	.read = sst_debug_sram_ia_lpe_mbox_read,
+	.llseek = default_llseek,
+};
+
+static ssize_t sst_debug_sram_lpe_ia_mbox_read(struct file *file,
+		char __user *user_buf, size_t count, loff_t *ppos)
+{
+
+	struct intel_sst_drv *drv = file->private_data;
+	int ret = 0;
+
+	ret = is_fw_running(drv);
+	if (ret)
+		return ret;
+
+	ret = copy_sram_to_user_buffer(user_buf, count, ppos, LPE_IA_MAILBOX_DUMP_SZ,
+				       (u32 *)(drv->mailbox + drv->mailbox_recv_offset),
+				       drv->mailbox_recv_offset);
+	sst_pm_runtime_put(drv);
+	return ret;
+}
+
+static const struct file_operations sst_debug_sram_lpe_ia_mbox_ops = {
+	.open = simple_open,
+	.read = sst_debug_sram_lpe_ia_mbox_read,
+	.llseek = default_llseek,
+};
+
+static ssize_t sst_debug_sram_lpe_scu_mbox_read(struct file *file,
+		char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct intel_sst_drv *drv = file->private_data;
+	int ret = 0;
+
+	ret = is_fw_running(drv);
+	if (ret)
+		return ret;
+	ret = copy_sram_to_user_buffer(user_buf, count, ppos, LPE_SCU_MAILBOX_DUMP_SZ,
+				       (u32 *)(drv->mailbox + SST_LPE_SCU_MAILBOX),
+				       SST_LPE_SCU_MAILBOX);
+	sst_pm_runtime_put(drv);
+	return ret;
+}
+
+static const struct file_operations sst_debug_sram_lpe_scu_mbox_ops = {
+	.open = simple_open,
+	.read = sst_debug_sram_lpe_scu_mbox_read,
+	.llseek = default_llseek,
+};
+
+static ssize_t sst_debug_sram_scu_lpe_mbox_read(struct file *file,
+		char __user *user_buf, size_t count, loff_t *ppos)
+{	struct intel_sst_drv *drv = file->private_data;
+	int ret = 0;
+
+	ret = is_fw_running(drv);
+	if (ret)
+		return ret;
+	ret = copy_sram_to_user_buffer(user_buf, count, ppos, SCU_LPE_MAILBOX_DUMP_SZ,
+				       (u32 *)(drv->mailbox + SST_SCU_LPE_MAILBOX),
+				       SST_SCU_LPE_MAILBOX);
+	sst_pm_runtime_put(drv);
+	return ret;
+}
+
+static const struct file_operations sst_debug_sram_scu_lpe_mbox_ops = {
+	.open = simple_open,
+	.read = sst_debug_sram_scu_lpe_mbox_read,
+	.llseek = default_llseek,
+};
+
+static ssize_t sst_debug_lpe_log_enable_write(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct intel_sst_drv *drv = file->private_data;
+	struct ipc_post *msg = NULL;
+	char buf[32];
+	int str_id = 0;	/* DUMMY, required by post message */
+	struct snd_sst_lpe_log_params params;
+	int ret_val = 0;
+	char *start = buf, *end;
+	int i = 0;
+	u8 *addr;
+	unsigned long tmp;
+
+	size_t buf_size = min(count, sizeof(buf)-1);
+	memset(&params, 0, sizeof(params));
+
+	ret_val = is_fw_running(drv);
+	if (ret_val)
+		return ret_val;
+
+	if (copy_from_user(buf, user_buf, buf_size)) {
+		ret_val = -EFAULT;
+		goto put_pm_runtime;
+	}
+
+	buf[buf_size] = 0;
+
+	addr = &params.dbg_type;
+	for (i = 0; i < (sizeof(params) - sizeof(u8)); i++) {
+		while (*start == ' ')
+			start++;
+		end = start;
+		while (isalnum(*end))
+			end++;
+		*end = 0;
+		ret_val = kstrtoul(start, 16, &tmp);
+		if (ret_val) {
+			pr_err("kstrtoul failed, ret_val = %d\n", ret_val);
+			goto put_pm_runtime;
+		}
+		*addr++ = (u8)tmp;
+		start = end + 1;
+	}
+
+	pr_debug("dbg_type = %d module_id = %d log_level = %d\n",
+			params.dbg_type, params.module_id, params.log_level);
+
+	if (params.dbg_type < NO_DEBUG || params.dbg_type > PTI_DEBUG) {
+		ret_val = -EINVAL;
+		goto put_pm_runtime;
+	}
+
+	ret_val = sst_create_ipc_msg(&msg, true);
+	if (ret_val != 0)
+		goto put_pm_runtime;
+
+	if ((sst_drv_ctx->pci_id != SST_MRFLD_PCI_ID) /* &&
+		(sst_drv_ctx->pci_id != PCI_DEVICE_ID_INTEL_SST_MOOR) */) {
+		sst_fill_header(&msg->header, IPC_IA_DBG_LOG_ENABLE, 1,
+							str_id);
+		msg->header.part.data = sizeof(u32) + sizeof(params);
+		memcpy(msg->mailbox_data, &msg->header.full, sizeof(u32));
+		memcpy(msg->mailbox_data + sizeof(u32), &params,
+							sizeof(params));
+	}
+	drv->ops->sync_post_message(msg);
+	ret_val = buf_size;
+put_pm_runtime:
+	sst_pm_runtime_put(drv);
+	return ret_val;
+}
+
+/*
+ * Circular buffer hdr -> 0x1000
+ * log data starts at 0x1010
+ */
+static ssize_t sst_debug_lpe_log_enable_read(struct file *file,
+		char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct intel_sst_drv *drv = file->private_data;
+	struct lpe_log_buf_hdr buf_hdr;
+	size_t size1, size2, offset, bytes_read;
+	char *buf = NULL;
+	int ret;
+
+	ret = is_fw_running(drv);
+	if (ret)
+		return ret;
+
+	/* Get the sram lpe log buffer header */
+	memcpy_fromio(&buf_hdr, (u32 *)(drv->mailbox + SST_SCU_LPE_MAILBOX),
+							sizeof(buf_hdr));
+	if (buf_hdr.rd_addr == buf_hdr.wr_addr) {
+		pr_err("SRAM emptry\n");
+		ret = -ENODATA;
+		goto put_pm_runtime;
+	} else if (buf_hdr.rd_addr < buf_hdr.wr_addr) {
+		size1 = buf_hdr.wr_addr - buf_hdr.rd_addr;
+		offset = (buf_hdr.rd_addr - buf_hdr.base_addr)
+						+ SST_SCU_LPE_LOG_BUF;
+		pr_debug("Size = %zu, offset = %zx\n", size1, offset);
+		buf = vmalloc(size1);
+		if (buf == NULL) {
+			pr_err("Not enough memory to allocate\n");
+			ret = -ENOMEM;
+			goto put_pm_runtime;
+		}
+		memcpy_fromio(buf, (u32 *)(drv->mailbox + offset), size1);
+		bytes_read = simple_read_from_buffer(user_buf, count, ppos,
+							buf, size1);
+
+		buf_hdr.rd_addr = buf_hdr.rd_addr + bytes_read;
+
+	} else {
+		/* Read including the end address as well */
+		size1 = buf_hdr.end_addr - buf_hdr.rd_addr + 1;
+		offset = (buf_hdr.rd_addr - buf_hdr.base_addr)
+						+ SST_SCU_LPE_LOG_BUF;
+		pr_debug("Size = %zu, offset = %zx\n", size1, offset);
+		buf = vmalloc(size1);
+		if (buf == NULL) {
+			pr_err("Not enough memory to allocate\n");
+			ret = -ENOMEM;
+			goto put_pm_runtime;
+		}
+		memcpy_fromio(buf, (u32 *)(drv->mailbox + offset), size1);
+		bytes_read = simple_read_from_buffer(user_buf, count, ppos,
+							buf, size1);
+		if (bytes_read != size1) {
+			buf_hdr.rd_addr = buf_hdr.rd_addr + bytes_read;
+			goto update_rd_ptr;
+		}
+
+		/* Wrap around lpe log buffer here */
+		vfree(buf);
+		buf = NULL;
+		size2 = (buf_hdr.wr_addr - buf_hdr.base_addr);
+		offset = SST_SCU_LPE_LOG_BUF;
+		pr_debug("Size = %zu, offset = %zx\n", size2, offset);
+		buf = vmalloc(size2);
+		if (buf == NULL) {
+			pr_err("Not enough memory to allocate\n");
+			ret = -ENOMEM;
+			goto put_pm_runtime;
+		}
+		memcpy_fromio(buf, (u32 *)(drv->mailbox + offset), size2);
+		bytes_read += simple_read_from_buffer(user_buf,
+				(count - bytes_read), ppos, buf, size2);
+		buf_hdr.rd_addr = buf_hdr.base_addr + bytes_read - size1;
+
+	}
+update_rd_ptr:
+	if (bytes_read != 0) {
+		memcpy_toio((u32 *)(drv->mailbox + SST_SCU_LPE_MAILBOX +
+				2 * sizeof(u32)), &(buf_hdr.rd_addr), sizeof(u32));
+		pr_debug("read pointer restored\n");
+	}
+	vfree(buf);
+	buf = NULL;
+	ret = bytes_read;
+put_pm_runtime:
+	sst_pm_runtime_put(drv);
+	return ret;
+}
+
+static const struct file_operations sst_debug_lpe_log_enable_ops = {
+	.open = simple_open,
+	.write = sst_debug_lpe_log_enable_write,
+	.read = sst_debug_lpe_log_enable_read,
+	.llseek = default_llseek,
+};
+
+static ssize_t sst_debug_rtpm_read(struct file *file, char __user *user_buf,
+				   size_t count, loff_t *ppos)
+{
+	struct intel_sst_drv *drv = file->private_data;
+	char *status;
+
+	int usage = atomic_read(&drv->pm_usage_count);
+
+	pr_debug("RTPM usage: %d\n", usage);
+	status = drv->debugfs.runtime_pm_status ? "enabled\n" : "disabled\n";
+	return simple_read_from_buffer(user_buf, count, ppos,
+			status, strlen(status));
+}
+
+static ssize_t sst_debug_rtpm_write(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct intel_sst_drv *drv = file->private_data;
+	char buf[16];
+	int sz = min(count, sizeof(buf)-1);
+
+	int usage = atomic_read(&drv->pm_usage_count);
+
+	pr_debug("RTPM Usage: %d\n", usage);
+	if (copy_from_user(buf, user_buf, sz))
+		return -EFAULT;
+	buf[sz] = 0;
+
+	if (!strncmp(buf, "enable\n", sz)) {
+		/* already enabled? */
+		if (drv->debugfs.runtime_pm_status)
+			return -EINVAL;
+		drv->debugfs.runtime_pm_status = 1;
+		pm_runtime_allow(drv->dev);
+		sz = 6; /* strlen("enable") */
+	} else if (!strncmp(buf, "disable\n", sz)) {
+		if (!drv->debugfs.runtime_pm_status)
+			return -EINVAL;
+		drv->debugfs.runtime_pm_status = 0;
+		pm_runtime_forbid(drv->dev);
+		sz = 7; /* strlen("disable") */
+	} else
+		return -EINVAL;
+	return sz;
+}
+
+static const struct file_operations sst_debug_rtpm_ops = {
+	.open = simple_open,
+	.read = sst_debug_rtpm_read,
+	.write = sst_debug_rtpm_write,
+	.llseek = default_llseek,
+};
+
+
+static ssize_t sst_debug_readme_read(struct file *file, char __user *user_buf,
+				   size_t count, loff_t *ppos)
+{
+	const char *buf =
+		"\nAll files can be read using 'cat'\n"
+		"1. 'echo disable > runtime_pm' disables runtime PM and will prevent SST from suspending.\n"
+		"To enable runtime PM, echo 'enable' to runtime_pm. Dmesg will print the runtime pm usage\n"
+		"if logs are enabled.\n"
+		"2. Write to shim register using 'echo <addr> <value> > shim_dump'.\n"
+		"Valid address range is between 0x00 to 0x80 in increments of 8.\n"
+		"3. echo 1 > fw_clear_context , This sets the flag to skip the context restore\n"
+		"4. echo 1 > fw_clear_cache , This sets the flag to clear the cached copy of firmware\n"
+		"5. echo 1 > fw_reset_state ,This sets the fw state to RESET\n"
+		"6. echo memcpy > fw_dwnld_mode, This will set the firmware download mode to memcpy\n"
+		"   echo lli > fw_dwnld_mode, This will set the firmware download mode to\n"
+					"dma lli mode\n"
+		"   echo dma > fw_dwnld_mode, This will set the firmware download mode to\n"
+					"dma single block mode\n"
+		"7. iram_dump, dram_dump, interfaces provide mmap support to\n"
+		"get the iram and dram dump, these buffers will have data only\n"
+		"after the recovery is triggered\n";
+
+	const char *ctp_buf =
+		"8. Enable input clock by 'echo enable > osc_clk0'.\n"
+		"This prevents the input OSC clock from switching off till it is disabled by\n"
+		"'echo disable > osc_clk0'. The status of the clock indicated who are using it.\n"
+		"9. lpe_log_enable usage:\n"
+		"	echo <dbg_type> <module_id> <log_level> > lpe_log_enable.\n"
+		"10. cat fw_ssp_reg,This will dump the ssp register contents\n"
+		"11. cat fw_dma_reg,This will dump the dma register contents\n";
+
+	const char *mrfld_buf =
+		"8. lpe_log_enable usage:\n"
+		"	echo <dbg_type> <module_id> <log_level> > lpe_log_enable.\n"
+		"9. cat fw_ssp_reg,This will dump the ssp register contents\n"
+		"10. cat fw_dma_reg,This will dump the dma register contents\n"
+		"11. ddr_imr_dump interface provides mmap support to get the imr dump,\n"
+		"this buffer will have data only after the recovery is triggered\n"
+		"12. ipc usage:\n"
+		"\t ipc file works only in binary mode. The ipc format is <IPC hdr><dsp hdr><payload>.\n"
+		"\t drv_id in the ipc header will be overwritten with unique driver id in the driver\n";
+
+	char *readme = NULL;
+	const char *buf2 = NULL;
+	int size, ret = 0;
+
+	switch (sst_drv_ctx->pci_id) {
+	case SST_CLV_PCI_ID:
+		size = strlen(buf) + strlen(ctp_buf) + 2;
+		buf2 = ctp_buf;
+		break;
+	case SST_MRFLD_PCI_ID:
+		size = strlen(buf) + strlen(mrfld_buf) + 2;
+		buf2 = mrfld_buf;
+		break;
+	default:
+		size = strlen(buf) + 1;
+	};
+
+	readme = kmalloc(size, GFP_KERNEL);
+	if (readme == NULL) {
+		pr_err("%s: no memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	if (buf2)
+		sprintf(readme, "%s%s\n", buf, buf2);
+	else
+		sprintf(readme, "%s\n", buf);
+
+	ret = simple_read_from_buffer(user_buf, count, ppos,
+			readme, strlen(readme));
+	kfree(readme);
+	return ret;
+}
+
+static const struct file_operations sst_debug_readme_ops = {
+	.open = simple_open,
+	.read = sst_debug_readme_read,
+};
+
+static ssize_t sst_debug_osc_clk0_read(struct file *file, char __user *user_buf,
+				   size_t count, loff_t *ppos)
+{
+	char status[16];
+	int mode = -1;
+#ifdef CONFIG_INTEL_SCU_IPC_UTIL
+	mode = intel_scu_ipc_set_osc_clk0(0, CLK0_QUERY);
+#endif
+
+	snprintf(status, 16, "0x%x\n", mode);
+	return simple_read_from_buffer(user_buf, count, ppos,
+			status, strlen(status));
+}
+
+static ssize_t sst_debug_osc_clk0_write(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char buf[16];
+	int sz = min(count, sizeof(buf)-1);
+
+	if (copy_from_user(buf, user_buf, sz))
+		return -EFAULT;
+	buf[sz] = 0;
+
+#ifdef CONFIG_INTEL_SCU_IPC_UTIL
+	if (!strncmp(buf, "enable\n", sz)) {
+		intel_scu_ipc_set_osc_clk0(true, CLK0_DEBUG);
+		sz = 6; /* strlen("enable") */
+	} else if (!strncmp(buf, "disable\n", sz)) {
+		intel_scu_ipc_set_osc_clk0(false, CLK0_DEBUG);
+		sz = 7; /* strlen("disable") */
+	} else
+		return -EINVAL;
+#endif
+	return sz;
+}
+
+static const struct file_operations sst_debug_osc_clk0_ops = {
+	.open = simple_open,
+	.read = sst_debug_osc_clk0_read,
+	.write = sst_debug_osc_clk0_write,
+};
+
+#define VLV2_BASE 0xFED0306C
+static ssize_t sst_debug_fw_clear_cntx_read(struct file *file,
+		char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char *status;
+	void __iomem *addr;
+	u32 value;
+
+	addr = ioremap_nocache(VLV2_BASE, 0x100);
+	if (!addr) {
+		printk("Unable to MAP VLV2 CLK\n");
+		return -EINVAL;
+	}
+	value = readl(addr);
+	printk("VLV2 Value = %d\n", value);
+#if 1
+	status = atomic_read(&sst_drv_ctx->fw_clear_context) ? \
+			"clear fw cntx\n" : "do not clear fw cntx\n";
+#endif
+	iounmap(addr);
+	return simple_read_from_buffer(user_buf, count, ppos,
+			status, strlen(status));
+
+}
+
+static ssize_t sst_debug_fw_clear_cntx_write(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+
+{
+	char buf[16];
+	void __iomem *addr;
+	int sz = min(count, sizeof(buf)-1);
+
+	addr = ioremap_nocache(VLV2_BASE, 0x100);
+	if (!addr) {
+		printk("Unable to MAP VLV2 CLK\n");
+		return -EINVAL;
+	}
+
+	if (copy_from_user(buf, user_buf, sz))
+		return -EFAULT;
+	buf[sz] = 0;
+#if 0
+	if (!strncmp(buf, "1\n", sz))
+		atomic_set(&sst_drv_ctx->fw_clear_context, 1);
+	else
+		atomic_set(&sst_drv_ctx->fw_clear_context, 0);
+#endif
+	printk("Writing to address\n");
+	if (!strncmp(buf, "1\n", sz))
+		writel(0x1, addr);
+	else
+		 writel(0x2, addr);
+
+	iounmap(addr);
+	return sz;
+
+}
+
+static const struct file_operations sst_debug_fw_clear_cntx = {
+	.open = simple_open,
+	.read = sst_debug_fw_clear_cntx_read,
+	.write = sst_debug_fw_clear_cntx_write,
+};
+
+static ssize_t sst_debug_fw_clear_cache_read(struct file *file,
+		char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char *status;
+
+	status = atomic_read(&sst_drv_ctx->fw_clear_cache) ? \
+			"cache clear flag set\n" : "cache clear flag not set\n";
+
+	return simple_read_from_buffer(user_buf, count, ppos,
+			status, strlen(status));
+
+}
+
+static ssize_t sst_debug_fw_clear_cache_write(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+
+{
+	char buf[16];
+	int sz = min(count, sizeof(buf)-1);
+
+	if (copy_from_user(buf, user_buf, sz))
+		return -EFAULT;
+	buf[sz] = 0;
+
+	if (!strncmp(buf, "1\n", sz))
+		atomic_set(&sst_drv_ctx->fw_clear_cache, 1);
+	else
+		return -EINVAL;
+
+	return sz;
+}
+
+static const struct file_operations sst_debug_fw_clear_cache = {
+	.open = simple_open,
+	.read = sst_debug_fw_clear_cache_read,
+	.write = sst_debug_fw_clear_cache_write,
+};
+
+static ssize_t sst_debug_fw_reset_state_read(struct file *file,
+		char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char state[16];
+
+	sprintf(state, "%d\n", sst_drv_ctx->sst_state);
+
+	return simple_read_from_buffer(user_buf, count, ppos,
+			state, strlen(state));
+
+}
+
+static ssize_t sst_debug_fw_reset_state_write(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+
+{
+	char buf[16];
+	int sz = min(count, sizeof(buf)-1);
+
+	if (copy_from_user(buf, user_buf, sz))
+		return -EFAULT;
+	buf[sz] = 0;
+
+	if (!strncmp(buf, "1\n", sz))
+		sst_set_fw_state_locked(sst_drv_ctx, SST_RESET);
+	else
+		return -EINVAL;
+
+	return sz;
+
+}
+
+static const struct file_operations sst_debug_fw_reset_state = {
+	.open = simple_open,
+	.read = sst_debug_fw_reset_state_read,
+	.write = sst_debug_fw_reset_state_write,
+};
+
+static ssize_t sst_debug_dwnld_mode_read(struct file *file,
+		char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char *state = "error\n";
+
+	if (sst_drv_ctx->use_dma == 0) {
+		state = "memcpy\n";
+	} else if (sst_drv_ctx->use_dma == 1) {
+		state = sst_drv_ctx->use_lli ? \
+				"lli\n" : "dma\n";
+
+	}
+
+	return simple_read_from_buffer(user_buf, count, ppos,
+			state, strlen(state));
+
+}
+
+static ssize_t sst_debug_dwnld_mode_write(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+
+{
+	char buf[16];
+	int sz = min(count, sizeof(buf)-1);
+
+	if (atomic_read(&sst_drv_ctx->pm_usage_count) &&
+	    sst_drv_ctx->sst_state != SST_RESET) {
+		pr_err("FW should be in suspended/RESET state\n");
+		return -EFAULT;
+	}
+
+	if (copy_from_user(buf, user_buf, sz))
+		return -EFAULT;
+	buf[sz] = '\0';
+
+	/* Firmware needs to be downloaded again to populate the lists */
+	atomic_set(&sst_drv_ctx->fw_clear_cache, 1);
+
+	if (!strncmp(buf, "memcpy\n", sz)) {
+		sst_drv_ctx->use_dma = 0;
+	} else if (!strncmp(buf, "lli\n", sz)) {
+		sst_drv_ctx->use_dma = 1;
+		sst_drv_ctx->use_lli = 1;
+	} else if (!strncmp(buf, "dma\n", sz)) {
+		sst_drv_ctx->use_dma = 1;
+		sst_drv_ctx->use_lli = 0;
+	}
+	return sz;
+
+}
+
+static const struct file_operations sst_debug_dwnld_mode = {
+	.open = simple_open,
+	.read = sst_debug_dwnld_mode_read,
+	.write = sst_debug_dwnld_mode_write,
+};
+
+static int dump_ssp_port(void __iomem *ssp_base, char *buf, int pos)
+{
+	int index = 0;
+
+	while (index < ARRAY_SIZE(ssp_reg_off)) {
+		pos += sprintf(buf + pos, "Reg: 0x%x: 0x%x\n", ssp_reg_off[index],
+			sst_reg_read(ssp_base, ssp_reg_off[index]));
+		index++;
+	}
+	return pos;
+}
+
+static ssize_t sst_debug_ssp_reg_read(struct file *file,
+			char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char *buf;
+	int i, pos = 0, off = 0;
+	struct intel_sst_drv *drv = file->private_data;
+	int num_ssp, buf_size, ret;
+
+	num_ssp = sst_drv_ctx->pdata->debugfs_data->num_ssp;
+	buf_size = DEBUGFS_SSP_BUF_SIZE * num_ssp;
+
+	buf = kmalloc(buf_size, GFP_KERNEL);
+	if (!buf) {
+		pr_err("%s: no memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	ret = is_fw_running(drv);
+	if (ret)
+		goto err;
+
+	buf[0] = 0;
+
+	for (i = 0; i < num_ssp ; i++) {
+		if (!sst_drv_ctx->debugfs.ssp[i]) {
+			pr_err("ssp %d port not mapped\n", i);
+			continue;
+		}
+		off = sst_drv_ctx->pdata->debugfs_data->ssp_reg_size * i;
+		pos = dump_ssp_port((sst_drv_ctx->debugfs.ssp[i]), buf, pos);
+	}
+	sst_pm_runtime_put(drv);
+
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, pos);
+err:
+	kfree(buf);
+	return ret;
+}
+
+static const struct file_operations sst_debug_ssp_reg = {
+		.open = simple_open,
+		.read = sst_debug_ssp_reg_read,
+};
+
+static int dump_dma_reg(char *buf, int pos, int dma)
+{
+	int i, index = 0;
+	int off = 0 ;
+	void __iomem *dma_reg;
+
+	if (!sst_drv_ctx->debugfs.dma_reg[dma]) {
+		pr_err("dma %d not mapped\n", dma);
+		return pos;
+	}
+
+	pos += sprintf(buf + pos, "\nDump DMA%d Reg\n\n", dma);
+
+	dma_reg = sst_drv_ctx->debugfs.dma_reg[dma];
+
+	/* Dump the DMA channel registers */
+	for (i = 0; i < DMA_NUM_CH; i++) {
+		pos += sprintf(buf + pos, "SAR%d: 0x%x: 0x%llx\n", i, off,
+			sst_reg_read64(dma_reg, off));
+		off += 8;
+
+		pos += sprintf(buf + pos, "DAR%d: 0x%x: 0x%llx\n", i, off,
+			sst_reg_read64(dma_reg, off));
+		off += 8;
+
+		pos += sprintf(buf + pos, "LLP%d: 0x%x: 0x%llx\n", i, off,
+			sst_reg_read64(dma_reg, off));
+		off += 8;
+
+		pos += sprintf(buf + pos, "CTL%d: 0x%x: 0x%llx\n", i, off,
+			sst_reg_read64(dma_reg, off));
+		off += 0x28;
+
+		pos += sprintf(buf + pos, "CFG%d: 0x%x: 0x%llx\n", i, off,
+			sst_reg_read64(dma_reg, off));
+		off += 0x18;
+	}
+
+	/* Dump the remaining DMA registers */
+	while (index < ARRAY_SIZE(dma_reg_off)) {
+		pos += sprintf(buf + pos, "Reg: 0x%x: 0x%llx\n", dma_reg_off[index],
+				sst_reg_read64(dma_reg, dma_reg_off[index]));
+		index++;
+	}
+	return pos;
+}
+
+static ssize_t sst_debug_dma_reg_read(struct file *file,
+		char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char *buf;
+	int pos = 0;
+	int ret, i;
+	struct intel_sst_drv *drv = file->private_data;
+	int num_dma, buf_size;
+
+	num_dma = sst_drv_ctx->pdata->debugfs_data->num_dma;
+	buf_size = DEBUGFS_DMA_BUF_SIZE * num_dma;
+
+	buf = kmalloc(buf_size, GFP_KERNEL);
+	if (!buf) {
+		pr_err("%s: no memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	ret = is_fw_running(drv);
+	if (ret)
+		goto err;
+
+	buf[0] = 0;
+
+	for (i = 0; i < num_dma; i++)
+		pos = dump_dma_reg(buf, pos, i);
+
+	sst_pm_runtime_put(drv);
+
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, pos);
+err:
+	kfree(buf);
+	return ret;
+}
+
+static const struct file_operations sst_debug_dma_reg = {
+		.open = simple_open,
+		.read = sst_debug_dma_reg_read,
+};
+
+/**
+ * sst_debug_remap - function remaps the iram/dram buff to userspace
+ *
+ * @vma: vm_area_struct passed from userspace
+ * @buf: Physical addr of the pointer to be remapped
+ * @type: type of the buffer
+ *
+ * Remaps the kernel buffer to the userspace
+ */
+static int sst_debug_remap(struct vm_area_struct *vma, char *buf,
+					enum sst_ram_type type)
+{
+	int retval, length;
+	void *mem_area;
+
+	if (!buf)
+		return -EIO;
+
+	length = vma->vm_end - vma->vm_start;
+	pr_debug("iram length 0x%x\n", length);
+
+	/* round it up to the page bondary  */
+	mem_area = (void *)PAGE_ALIGN((unsigned long)buf);
+
+	/* map the whole physically contiguous area in one piece  */
+	retval = remap_pfn_range(vma,
+			vma->vm_start,
+			virt_to_phys((void *)mem_area) >> PAGE_SHIFT,
+			length,
+			vma->vm_page_prot);
+	if (retval)
+		pr_err("mapping failed %d ", retval);
+	return retval;
+}
+
+int sst_debug_iram_dump_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	int retval;
+	struct intel_sst_drv *sst = sst_drv_ctx;
+
+	retval = sst_debug_remap(vma, sst->dump_buf.iram_buf.buf, SST_IRAM);
+
+	return retval;
+}
+
+static const struct file_operations sst_debug_iram_dump = {
+	.open = simple_open,
+	.mmap = sst_debug_iram_dump_mmap,
+};
+
+int sst_debug_dram_dump_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	int retval;
+	struct intel_sst_drv *sst = sst_drv_ctx;
+
+	retval = sst_debug_remap(vma, sst->dump_buf.dram_buf.buf, SST_DRAM);
+
+	return retval;
+}
+
+static const struct file_operations sst_debug_dram_dump = {
+	.open = simple_open,
+	.mmap = sst_debug_dram_dump_mmap,
+};
+
+int sst_debug_ddr_imr_dump_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	int retval;
+	struct intel_sst_drv *sst = sst_drv_ctx;
+
+	retval = sst_debug_remap(vma, sst->ddr, 0);
+
+	return retval;
+}
+
+static const struct file_operations sst_debug_ddr_imr_dump = {
+	.open = simple_open,
+	.mmap = sst_debug_ddr_imr_dump_mmap,
+};
+
+static ssize_t sst_debug_ipc_write(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct intel_sst_drv *ctx = (struct intel_sst_drv *)file->private_data;
+	unsigned char *buf;
+	struct sst_block *block = NULL;
+	struct ipc_dsp_hdr *dsp_hdr;
+	struct ipc_post *msg = NULL;
+	int ret, res_rqd, msg_id, drv_id;
+	u32 low_payload;
+
+	if (count > 1024)
+		return -EINVAL;
+
+	ret = is_fw_running(ctx);
+	if (ret)
+		return ret;
+
+	buf = kzalloc((sizeof(unsigned char) * (count)), GFP_KERNEL);
+	if (!buf) {
+		ret = -ENOMEM;
+		goto put_pm_runtime;
+	}
+	if (copy_from_user(buf, user_buf, count)) {
+		ret = -EFAULT;
+		goto free_mem;
+	}
+
+	if (sst_create_ipc_msg(&msg, true)) {
+		ret = -ENOMEM;
+		goto free_mem;
+	}
+
+	msg->mrfld_header.full = *((u64 *)buf);
+	pr_debug("ipc hdr: %llx\n", msg->mrfld_header.full);
+
+	/* Override the drv id with unique drv id */
+	drv_id = sst_assign_pvt_id(ctx);
+	msg->mrfld_header.p.header_high.part.drv_id = drv_id;
+
+	res_rqd = msg->mrfld_header.p.header_high.part.res_rqd;
+	msg_id = msg->mrfld_header.p.header_high.part.msg_id;
+	pr_debug("res_rqd: %d, msg_id: %d, drv_id: %d\n",
+					res_rqd, msg_id, drv_id);
+	if (res_rqd) {
+		block = sst_create_block(ctx, msg_id, drv_id);
+		if (block == NULL) {
+			ret = -ENOMEM;
+			kfree(msg);
+			goto free_mem;
+		}
+	}
+
+	dsp_hdr = (struct ipc_dsp_hdr *)(buf + 8);
+	pr_debug("dsp hdr: %llx\n", *((u64 *)(dsp_hdr)));
+	low_payload = msg->mrfld_header.p.header_low_payload;
+	if (low_payload > (1024 - sizeof(union ipc_header_mrfld))) {
+		pr_err("Invalid low payload length: %x\n", low_payload);
+		ret = -EINVAL;
+		kfree(msg);
+		goto free_block;
+	}
+
+	memcpy(msg->mailbox_data, (buf+(sizeof(union ipc_header_mrfld))),
+			low_payload);
+	sst_add_to_dispatch_list_and_post(ctx, msg);
+	if (res_rqd) {
+		ret = sst_wait_timeout(ctx, block);
+		if (ret) {
+			pr_err("%s: fw returned err %d\n", __func__, ret);
+			goto free_block;
+		}
+
+		if (msg_id == IPC_GET_PARAMS) {
+			unsigned char *r = block->data;
+			/* Copy the IPC header first and then append dsp header
+			 * and payload data*/
+			memcpy(ctx->debugfs.get_params_data, &msg->mrfld_header.full, sizeof(msg->mrfld_header.full));
+			memcpy(ctx->debugfs.get_params_data + sizeof(msg->mrfld_header.full), r, dsp_hdr->length);
+			ctx->debugfs.get_params_len = sizeof(msg->mrfld_header.full) + dsp_hdr->length;
+		}
+
+	}
+	ret = count;
+free_block:
+	if (res_rqd)
+		sst_free_block(sst_drv_ctx, block);
+free_mem:
+	kfree(buf);
+put_pm_runtime:
+	sst_pm_runtime_put(ctx);
+	return ret;
+}
+
+static ssize_t sst_debug_ipc_read(struct file *file,
+		char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct intel_sst_drv *ctx = (struct intel_sst_drv *)file->private_data;
+	return simple_read_from_buffer(user_buf, count, ppos,
+			ctx->debugfs.get_params_data,
+			ctx->debugfs.get_params_len);
+}
+
+static const struct file_operations sst_debug_ipc_ops = {
+	.open = simple_open,
+	.write = sst_debug_ipc_write,
+	.read = sst_debug_ipc_read,
+	.llseek = default_llseek,
+};
+
+struct sst_debug {
+	const char *name;
+	const struct file_operations *fops;
+	umode_t mode;
+};
+
+static const struct sst_debug sst_common_dbg_entries[] = {
+	{"runtime_pm", &sst_debug_rtpm_ops, 0600},
+	{"shim_dump", &sst_debug_shim_ops, 0600},
+	{"fw_clear_context", &sst_debug_fw_clear_cntx, 0600},
+	{"fw_clear_cache", &sst_debug_fw_clear_cache, 0600},
+	{"fw_reset_state", &sst_debug_fw_reset_state, 0600},
+	{"fw_dwnld_mode", &sst_debug_dwnld_mode, 0600},
+	{"iram_dump", &sst_debug_iram_dump, 0400},
+	{"dram_dump", &sst_debug_dram_dump, 0400},
+	{"sram_ia_lpe_mailbox", &sst_debug_sram_ia_lpe_mbox_ops, 0400},
+	{"sram_lpe_ia_mailbox", &sst_debug_sram_lpe_ia_mbox_ops, 0400},
+	{"README", &sst_debug_readme_ops, 0400},
+};
+
+static const struct sst_debug ctp_dbg_entries[] = {
+	{"sram_lpe_debug", &sst_debug_sram_lpe_debug_ops, 0400},
+	{"sram_lpe_checkpoint", &sst_debug_sram_lpe_checkpoint_ops, 0400},
+	{"sram_lpe_scu_mailbox", &sst_debug_sram_lpe_scu_mbox_ops, 0400},
+	{"sram_scu_lpe_mailbox", &sst_debug_sram_scu_lpe_mbox_ops, 0400},
+	{"lpe_log_enable", &sst_debug_lpe_log_enable_ops, 0400},
+	{"fw_ssp_reg", &sst_debug_ssp_reg, 0400},
+	{"fw_dma_reg", &sst_debug_dma_reg, 0400},
+	{"osc_clk0", &sst_debug_osc_clk0_ops, 0600},
+};
+
+static const struct sst_debug mrfld_dbg_entries[] = {
+	{"sram_lpe_checkpoint", &sst_debug_sram_lpe_checkpoint_ops, 0400},
+	{"fw_ssp_reg", &sst_debug_ssp_reg, 0400},
+	{"fw_dma_reg", &sst_debug_dma_reg, 0400},
+	{"ddr_imr_dump", &sst_debug_ddr_imr_dump, 0400},
+	{"ipc", &sst_debug_ipc_ops, 0400},
+};
+
+void sst_debugfs_create_files(struct intel_sst_drv *sst,
+			const struct sst_debug *entries, int size)
+{
+	int i;
+
+	for (i = 0; i < size; i++) {
+		struct dentry *dentry;
+		const struct sst_debug *entry = &entries[i];
+
+		dentry = debugfs_create_file(entry->name, entry->mode,
+				sst->debugfs.root, sst, entry->fops);
+		if (dentry == NULL) {
+			pr_err("Failed to create %s file\n", entry->name);
+			return;
+		}
+	}
+}
+
+void sst_debugfs_init(struct intel_sst_drv *sst)
+{
+	int size = 0;
+	const struct sst_debug *debug = NULL;
+
+	sst->debugfs.root = debugfs_create_dir("sst", NULL);
+	if (IS_ERR(sst->debugfs.root) || !sst->debugfs.root) {
+		pr_err("Failed to create debugfs directory\n");
+		return;
+	}
+
+	sst_debugfs_create_files(sst, sst_common_dbg_entries,
+				ARRAY_SIZE(sst_common_dbg_entries));
+
+	/* Initial status is enabled */
+	sst->debugfs.runtime_pm_status = 1;
+
+	if ((sst->pci_id == SST_MRFLD_PCI_ID) /* ||
+			(sst->pci_id == PCI_DEVICE_ID_INTEL_SST_MOOR) */) {
+		debug = mrfld_dbg_entries;
+		size = ARRAY_SIZE(mrfld_dbg_entries);
+	} else if (sst->pci_id == SST_CLV_PCI_ID) {
+		debug = ctp_dbg_entries;
+		size = ARRAY_SIZE(ctp_dbg_entries);
+	}
+
+	if (debug)
+		sst_debugfs_create_files(sst, debug, size);
+
+}
+
+void sst_debugfs_exit(struct intel_sst_drv *sst)
+{
+	if (sst->debugfs.runtime_pm_status)
+		pm_runtime_allow(sst->dev);
+	debugfs_remove_recursive(sst->debugfs.root);
+}
diff --git a/sound/soc/intel/sst/sst_drv_interface.c b/sound/soc/intel/sst/sst_drv_interface.c
new file mode 100644
index 0000000..2867ab8
--- /dev/null
+++ b/sound/soc/intel/sst/sst_drv_interface.c
@@ -0,0 +1,1117 @@
+/*
+ *  sst_drv_interface.c - Intel SST Driver for audio engine
+ *
+ *  Copyright (C) 2008-10 Intel Corp
+ *  Authors:	Vinod Koul <vinod.koul@intel.com>
+ *		Harsha Priya <priya.harsha@intel.com>
+ *		Dharageswari R <dharageswari.r@intel.com)
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * This file defines the interface  between the platform driver and the SST
+ * driver.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include <linux/fs.h>
+#include <linux/firmware.h>
+#include <linux/pm_runtime.h>
+#include <linux/pm_qos.h>
+#include <linux/math64.h>
+#include <linux/intel_mid_pm.h>
+#include <sound/compress_offload.h>
+#include <sound/pcm.h>
+#include <sound/intel_sst_ioctl.h>
+#include "../sst_platform.h"
+#include "../platform_ipc_v2.h"
+#include "sst.h"
+
+#define NUM_CODEC 2
+#define MIN_FRAGMENT 2
+#define MAX_FRAGMENT 4
+#define MIN_FRAGMENT_SIZE (50 * 1024)
+#define MAX_FRAGMENT_SIZE (1024 * 1024)
+#define SST_GET_BYTES_PER_SAMPLE(pcm_wd_sz)  (((pcm_wd_sz + 15) >> 4) << 1)
+
+void sst_restore_fw_context(void)
+{
+	struct snd_sst_ctxt_params fw_context;
+	struct ipc_post *msg = NULL;
+	int retval = 0;
+	struct sst_block *block;
+
+	/* Skip the context restore, when fw_clear_context is set */
+	/* fw_clear_context set through debugfs support */
+	if (atomic_read(&sst_drv_ctx->fw_clear_context)) {
+		pr_debug("Skipping restore_fw_context\n");
+		atomic_set(&sst_drv_ctx->fw_clear_context, 0);
+		return;
+	}
+
+	pr_debug("restore_fw_context\n");
+	/*nothing to restore*/
+	if (!sst_drv_ctx->fw_cntx_size)
+		return;
+	pr_debug("restoring context......\n");
+	/*send msg to fw*/
+	retval = sst_create_block_and_ipc_msg(&msg, true, sst_drv_ctx, &block,
+			IPC_IA_SET_FW_CTXT, 0);
+	if (retval) {
+		pr_err("Can't allocate block/msg. No restore fw_context\n");
+		return;
+	}
+
+	sst_fill_header(&msg->header, IPC_IA_SET_FW_CTXT, 1, 0);
+
+	msg->header.part.data = sizeof(fw_context) + sizeof(u32);
+	fw_context.address = virt_to_phys((void *)sst_drv_ctx->fw_cntx);
+	fw_context.size = sst_drv_ctx->fw_cntx_size;
+	memcpy(msg->mailbox_data, &msg->header, sizeof(u32));
+	memcpy(msg->mailbox_data + sizeof(u32),
+				&fw_context, sizeof(fw_context));
+	sst_add_to_dispatch_list_and_post(sst_drv_ctx, msg);
+	retval = sst_wait_timeout(sst_drv_ctx, block);
+	sst_free_block(sst_drv_ctx, block);
+	if (retval)
+		pr_err("sst_restore_fw_context..timeout!\n");
+	return;
+}
+
+/*
+ * sst_download_fw - download the audio firmware to DSP
+ *
+ * This function is called when the FW needs to be downloaded to SST DSP engine
+ */
+int sst_download_fw(void)
+{
+	int retval = 0;
+
+	retval = sst_load_fw();
+	if (retval)
+		return retval;
+	pr_debug("fw loaded successful!!!\n");
+
+	if (sst_drv_ctx->ops->restore_dsp_context)
+		sst_drv_ctx->ops->restore_dsp_context();
+	sst_drv_ctx->sst_state = SST_FW_RUNNING;
+	return retval;
+}
+
+int free_stream_context(unsigned int str_id)
+{
+	struct stream_info *stream;
+	int ret = 0;
+
+	stream = get_stream_info(str_id);
+	if (stream) {
+		/* str_id is valid, so stream is alloacted */
+		ret = sst_free_stream(str_id);
+		if (ret)
+			sst_clean_stream(&sst_drv_ctx->streams[str_id]);
+		return ret;
+	}
+	return ret;
+}
+
+/*
+ * sst_send_algo_param - send LPE Mixer param to SST
+ *
+ * this function sends the algo parameter to sst dsp engine
+ */
+static int sst_send_algo_param(struct snd_ppp_params *algo_params)
+{
+	u32 header_size = 0;
+	struct ipc_post *msg = NULL;
+	u32 ipc_msg_size = sizeof(u32) + sizeof(*algo_params)
+			 - sizeof(algo_params->params) + algo_params->size;
+	u32 offset = 0;
+
+	if (ipc_msg_size > SST_MAILBOX_SIZE)
+		return -ENOMEM;
+	if (sst_create_ipc_msg(&msg, true))
+		return -ENOMEM;
+	sst_fill_header(&msg->header,
+			IPC_IA_ALG_PARAMS, 1, algo_params->str_id);
+	msg->header.part.data = sizeof(u32) + sizeof(*algo_params)
+			 - sizeof(algo_params->params) + algo_params->size;
+	memcpy(msg->mailbox_data, &msg->header, sizeof(u32));
+	offset = sizeof(u32);
+	header_size = sizeof(*algo_params) - sizeof(algo_params->params);
+	memcpy(msg->mailbox_data + sizeof(u32), algo_params,
+		sizeof(*algo_params) - sizeof(algo_params->params));
+	offset += header_size;
+	memcpy(msg->mailbox_data + offset , algo_params->params,
+			algo_params->size);
+	sst_add_to_dispatch_list_and_post(sst_drv_ctx, msg);
+	return 0;
+}
+
+static int sst_send_lpe_mixer_algo_params(void)
+{
+	struct snd_ppp_params algo_param;
+	struct snd_ppp_mixer_params mixer_param;
+	unsigned int input_mixer, stream_device_id;
+	int retval = 0;
+
+	retval = intel_sst_check_device();
+	if (retval) {
+		pr_err("sst_check_device failed %d\n", retval);
+		return retval;
+	}
+
+	mutex_lock(&sst_drv_ctx->mixer_ctrl_lock);
+	input_mixer = (sst_drv_ctx->device_input_mixer)
+				& SST_INPUT_STREAM_MIXED;
+	pr_debug("Input Mixer settings %d", input_mixer);
+	stream_device_id = sst_drv_ctx->device_input_mixer - input_mixer;
+	algo_param.algo_id = SST_ALGO_MIXER;
+	algo_param.str_id = stream_device_id;
+	algo_param.enable = 1;
+	algo_param.operation = SST_SET_ALGO;
+	algo_param.size = sizeof(mixer_param);
+	mixer_param.type = SST_ALGO_PARAM_MIXER_STREAM_CFG;
+	mixer_param.input_stream_bitmap = input_mixer;
+	mixer_param.size = sizeof(input_mixer);
+	algo_param.params = &mixer_param;
+	mutex_unlock(&sst_drv_ctx->mixer_ctrl_lock);
+	pr_debug("setting pp param\n");
+	pr_debug("Algo ID %d Str id %d Enable %d Size %d\n",
+			algo_param.algo_id, algo_param.str_id,
+			algo_param.enable, algo_param.size);
+	sst_send_algo_param(&algo_param);
+	sst_pm_runtime_put(sst_drv_ctx);
+	return retval;
+}
+
+/*
+ * sst_get_stream_allocated - this function gets a stream allocated with
+ * the given params
+ *
+ * @str_param : stream params
+ * @lib_dnld : pointer to pointer of lib downlaod struct
+ *
+ * This creates new stream id for a stream, in case lib is to be downloaded to
+ * DSP, it downloads that
+ */
+int sst_get_stream_allocated(struct snd_sst_params *str_param,
+		struct snd_sst_lib_download **lib_dnld)
+{
+	int retval, str_id;
+	struct sst_block *block;
+	struct snd_sst_alloc_response *response;
+	struct stream_info *str_info;
+
+	pr_debug("In %s\n", __func__);
+	block = sst_create_block(sst_drv_ctx, 0, 0);
+	if (block == NULL)
+		return -ENOMEM;
+
+	retval = sst_drv_ctx->ops->alloc_stream((char *) str_param, block);
+	str_id = retval;
+	if (retval < 0) {
+		pr_err("sst_alloc_stream failed %d\n", retval);
+		goto free_block;
+	}
+	pr_debug("Stream allocated %d\n", retval);
+	str_info = get_stream_info(str_id);
+	if (str_info == NULL) {
+		pr_err("get stream info returned null\n");
+		str_id = -EINVAL;
+		goto free_block;
+	}
+
+	/* Block the call for reply */
+	retval = sst_wait_timeout(sst_drv_ctx, block);
+	if (block->data) {
+		response = (struct snd_sst_alloc_response *)block->data;
+		retval = response->str_type.result;
+		if (!retval)
+			goto free_block;
+
+		pr_err("sst: FW alloc failed retval %d\n", retval);
+		if (retval == SST_ERR_STREAM_IN_USE) {
+			pr_err("sst:FW not in clean state, send free for:%d\n",
+					str_id);
+			sst_free_stream(str_id);
+			*lib_dnld = NULL;
+		}
+		if (retval == SST_LIB_ERR_LIB_DNLD_REQUIRED) {
+			*lib_dnld = kzalloc(sizeof(**lib_dnld), GFP_KERNEL);
+			if (*lib_dnld == NULL) {
+				str_id = -ENOMEM;
+				goto free_block;
+			}
+			memcpy(*lib_dnld, &response->lib_dnld, sizeof(**lib_dnld));
+			sst_clean_stream(str_info);
+		} else {
+			*lib_dnld = NULL;
+		}
+		str_id = -retval;
+	} else if (retval != 0) {
+		pr_err("sst: FW alloc failed retval %d\n", retval);
+		/* alloc failed, so reset the state to uninit */
+		str_info->status = STREAM_UN_INIT;
+		str_id = retval;
+	}
+free_block:
+	sst_free_block(sst_drv_ctx, block);
+	return str_id; /*will ret either error (in above if) or correct str id*/
+}
+
+/*
+ * sst_get_sfreq - this function returns the frequency of the stream
+ *
+ * @str_param : stream params
+ */
+int sst_get_sfreq(struct snd_sst_params *str_param)
+{
+	switch (str_param->codec) {
+	case SST_CODEC_TYPE_PCM:
+		return str_param->sparams.uc.pcm_params.sfreq;
+	case SST_CODEC_TYPE_AAC:
+		return str_param->sparams.uc.aac_params.externalsr;
+	case SST_CODEC_TYPE_MP3:
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+/*
+ * sst_get_sfreq - this function returns the frequency of the stream
+ *
+ * @str_param : stream params
+ */
+int sst_get_num_channel(struct snd_sst_params *str_param)
+{
+	switch (str_param->codec) {
+	case SST_CODEC_TYPE_PCM:
+		return str_param->sparams.uc.pcm_params.num_chan;
+	case SST_CODEC_TYPE_MP3:
+		return str_param->sparams.uc.mp3_params.num_chan;
+	case SST_CODEC_TYPE_AAC:
+		return str_param->sparams.uc.aac_params.num_chan;
+	default:
+		return -EINVAL;
+	}
+}
+
+/*
+ * sst_get_stream - this function prepares for stream allocation
+ *
+ * @str_param : stream param
+ */
+int sst_get_stream(struct snd_sst_params *str_param)
+{
+	int retval;
+	struct stream_info *str_info;
+	struct snd_sst_lib_download *lib_dnld;
+
+	pr_debug("In %s\n", __func__);
+	/* stream is not allocated, we are allocating */
+	retval = sst_get_stream_allocated(str_param, &lib_dnld);
+
+	if (retval == -(SST_LIB_ERR_LIB_DNLD_REQUIRED)) {
+		/* codec download is required */
+
+		pr_debug("Codec is required.... trying that\n");
+		if (lib_dnld == NULL) {
+			pr_err("lib download null!!! abort\n");
+			return -EIO;
+		}
+
+		retval = sst_load_library(lib_dnld, str_param->ops);
+		kfree(lib_dnld);
+
+		if (!retval) {
+			pr_debug("codec was downloaded successfully\n");
+
+			retval = sst_get_stream_allocated(str_param, &lib_dnld);
+			if (retval <= 0) {
+				retval = -EIO;
+				goto err;
+			}
+
+			pr_debug("Alloc done stream id %d\n", retval);
+		} else {
+			pr_debug("codec download failed\n");
+			retval = -EIO;
+			goto err;
+		}
+	} else if  (retval <= 0) {
+		retval = -EIO;
+		goto err;
+	}
+	/* store sampling freq */
+	str_info = &sst_drv_ctx->streams[retval];
+	str_info->sfreq = sst_get_sfreq(str_param);
+
+err:
+	return retval;
+}
+
+/**
+* intel_sst_check_device - checks SST device
+*
+* This utility function checks the state of SST device and downlaods FW if
+* not done, or resumes the device if suspended
+*/
+int intel_sst_check_device(void)
+{
+	int retval = 0;
+
+	pr_debug("In %s\n", __func__);
+
+	pm_runtime_get_sync(sst_drv_ctx->dev);
+	atomic_inc(&sst_drv_ctx->pm_usage_count);
+
+	pr_debug("%s: count is %d now\n", __func__,
+				atomic_read(&sst_drv_ctx->pm_usage_count));
+
+	mutex_lock(&sst_drv_ctx->sst_lock);
+
+	if (sst_drv_ctx->sst_state == SST_RESET) {
+
+		/* FW is not downloaded */
+		pr_debug("DSP Downloading FW now...\n");
+		retval = sst_download_fw();
+		if (retval) {
+			pr_err("FW download fail %x\n", retval);
+			sst_drv_ctx->sst_state = SST_RESET;
+			mutex_unlock(&sst_drv_ctx->sst_lock);
+			sst_pm_runtime_put(sst_drv_ctx);
+			return retval;
+		}
+	}
+	mutex_unlock(&sst_drv_ctx->sst_lock);
+	return retval;
+}
+
+void sst_process_mad_ops(struct work_struct *work)
+{
+
+	struct mad_ops_wq *mad_ops =
+			container_of(work, struct mad_ops_wq, wq);
+	int retval = 0;
+
+	switch (mad_ops->control_op) {
+	case SST_SND_PAUSE:
+		retval = sst_pause_stream(mad_ops->stream_id);
+		break;
+	case SST_SND_RESUME:
+		retval = sst_resume_stream(mad_ops->stream_id);
+		break;
+	default:
+		pr_err(" wrong control_ops reported\n");
+	}
+	if (retval)
+		pr_err("%s(): op: %d, retval: %d\n",
+				__func__, mad_ops->control_op, retval);
+	kfree(mad_ops);
+	return;
+}
+
+static int sst_power_control(bool state)
+{
+	pr_debug("%s for %d", __func__, state);
+
+	/* should we do ref count here, or rely on pcm handle?? */
+	if (state == true)
+		return intel_sst_check_device();
+	else
+		return sst_pm_runtime_put(sst_drv_ctx);
+}
+/*
+ * sst_open_pcm_stream - Open PCM interface
+ *
+ * @str_param: parameters of pcm stream
+ *
+ * This function is called by MID sound card driver to open
+ * a new pcm interface
+ */
+static int sst_open_pcm_stream(struct snd_sst_params *str_param)
+{
+	int retval;
+
+	if (!str_param)
+		return -EINVAL;
+
+	pr_debug("%s: doing rtpm_get\n", __func__);
+
+	retval = intel_sst_check_device();
+
+	if (retval)
+		return retval;
+	retval = sst_get_stream(str_param);
+	if (retval > 0) {
+		sst_drv_ctx->stream_cnt++;
+	} else {
+		pr_err("sst_get_stream returned err %d\n", retval);
+		sst_pm_runtime_put(sst_drv_ctx);
+	}
+
+	return retval;
+}
+
+static int sst_cdev_open(struct snd_sst_params *str_params,
+		struct sst_compress_cb *cb)
+{
+	int str_id, retval;
+	struct stream_info *stream;
+
+	pr_debug("%s: doing rtpm_get\n", __func__);
+
+	retval = intel_sst_check_device();
+	if (retval)
+		return retval;
+
+	str_id = sst_get_stream(str_params);
+	if (str_id > 0) {
+		pr_debug("stream allocated in sst_cdev_open %d\n", str_id);
+		stream = &sst_drv_ctx->streams[str_id];
+		stream->compr_cb = cb->compr_cb;
+		stream->compr_cb_param = cb->param;
+		stream->drain_notify = cb->drain_notify;
+		stream->drain_cb_param = cb->drain_cb_param;
+	} else {
+		pr_err("stream encountered error during alloc %d\n", str_id);
+		str_id = -EINVAL;
+		sst_pm_runtime_put(sst_drv_ctx);
+	}
+	return str_id;
+}
+
+static int sst_cdev_close(unsigned int str_id)
+{
+	int retval;
+	struct stream_info *stream;
+
+	pr_debug("%s: Entry\n", __func__);
+	stream = get_stream_info(str_id);
+	if (!stream) {
+		pr_err("stream info is NULL for str %d!!!\n", str_id);
+		return -EINVAL;
+	}
+
+	if (stream->status == STREAM_RESET) {
+		/* silently fail here as we have cleaned the stream */
+		pr_debug("stream in reset state...\n");
+		stream->status = STREAM_UN_INIT;
+
+		retval = 0;
+		goto put;
+	}
+
+	retval = sst_free_stream(str_id);
+put:
+	stream->compr_cb_param = NULL;
+	stream->compr_cb = NULL;
+
+	/* The free_stream will return a error if there is no stream to free,
+	(i.e. the alloc failure case). And in this case the open does a put in
+	the error scenario, so skip in this case.
+		In the close we need to handle put in the success scenario and
+	the timeout error(EBUSY) scenario. */
+	if (!retval || (retval == -EBUSY))
+		sst_pm_runtime_put(sst_drv_ctx);
+	else
+		pr_err("%s: free stream returned err %d\n", __func__, retval);
+
+	pr_debug("%s: End\n", __func__);
+	return retval;
+
+}
+
+static int sst_cdev_ack(unsigned int str_id, unsigned long bytes)
+{
+	struct stream_info *stream;
+	struct snd_sst_tstamp fw_tstamp = {0,};
+	int offset;
+	void __iomem *addr;
+
+	pr_debug("sst:  ackfor %d\n", str_id);
+	stream = get_stream_info(str_id);
+	if (!stream)
+		return -EINVAL;
+
+	/* update bytes sent */
+	stream->cumm_bytes += bytes;
+	pr_debug("bytes copied %d inc by %ld\n", stream->cumm_bytes, bytes);
+
+	memcpy_fromio(&fw_tstamp,
+		((void *)(sst_drv_ctx->mailbox + sst_drv_ctx->tstamp)
+		+(str_id * sizeof(fw_tstamp))),
+		sizeof(fw_tstamp));
+
+	fw_tstamp.bytes_copied = stream->cumm_bytes;
+	pr_debug("bytes sent to fw %llu inc by %ld\n", fw_tstamp.bytes_copied,
+							 bytes);
+
+	addr =  ((void *)(sst_drv_ctx->mailbox + sst_drv_ctx->tstamp)) +
+			(str_id * sizeof(fw_tstamp));
+	offset =  offsetof(struct snd_sst_tstamp, bytes_copied);
+	sst_shim_write(addr, offset, fw_tstamp.bytes_copied);
+	return 0;
+
+}
+
+static int sst_cdev_set_metadata(unsigned int str_id,
+				struct snd_compr_metadata *metadata)
+{
+	int retval = 0, pvt_id, len;
+	struct ipc_post *msg = NULL;
+	struct stream_info *str_info;
+	struct ipc_dsp_hdr dsp_hdr;
+
+	pr_debug("set metadata for stream %d\n", str_id);
+
+	str_info = get_stream_info(str_id);
+	if (!str_info)
+		return -EINVAL;
+
+	if (sst_create_ipc_msg(&msg, 1))
+		return -ENOMEM;
+
+	if (!sst_drv_ctx->use_32bit_ops) {
+		pvt_id = sst_assign_pvt_id(sst_drv_ctx);
+		pr_debug("pvt id = %d\n", pvt_id);
+		pr_debug("pipe id = %d\n", str_info->pipe_id);
+		sst_fill_header_mrfld(&msg->mrfld_header,
+			IPC_CMD, str_info->task_id, 1, pvt_id);
+
+		len = sizeof(*metadata) + sizeof(dsp_hdr);
+		msg->mrfld_header.p.header_low_payload = len;
+		sst_fill_header_dsp(&dsp_hdr, IPC_IA_SET_STREAM_PARAMS_MRFLD,
+				str_info->pipe_id, sizeof(*metadata));
+		memcpy(msg->mailbox_data, &dsp_hdr, sizeof(dsp_hdr));
+		memcpy(msg->mailbox_data + sizeof(dsp_hdr),
+				metadata, sizeof(*metadata));
+	} else {
+		sst_fill_header(&msg->header, IPC_IA_SET_STREAM_PARAMS,
+					1, str_id);
+		msg->header.part.data = sizeof(u32) + sizeof(*metadata);
+		memcpy(msg->mailbox_data, &msg->header, sizeof(u32));
+		memcpy(msg->mailbox_data + sizeof(u32),
+				metadata, sizeof(*metadata));
+	}
+
+	sst_drv_ctx->ops->sync_post_message(msg);
+	return retval;
+}
+
+static int sst_cdev_control(unsigned int cmd, unsigned int str_id)
+{
+	pr_debug("recieved cmd %d on stream %d\n", cmd, str_id);
+
+	if (sst_drv_ctx->sst_state != SST_FW_RUNNING)
+		return 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		return sst_pause_stream(str_id);
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		return sst_resume_stream(str_id);
+	case SNDRV_PCM_TRIGGER_START: {
+		struct stream_info *str_info;
+		str_info = get_stream_info(str_id);
+		if (!str_info)
+			return -EINVAL;
+		str_info->prev = str_info->status;
+		str_info->status = STREAM_RUNNING;
+		return sst_start_stream(str_id);
+	}
+	case SNDRV_PCM_TRIGGER_STOP:
+		return sst_drop_stream(str_id);
+	case SND_COMPR_TRIGGER_DRAIN:
+		return sst_drain_stream(str_id, false);
+	case SND_COMPR_TRIGGER_NEXT_TRACK:
+		return sst_next_track();
+	case SND_COMPR_TRIGGER_PARTIAL_DRAIN:
+		return sst_drain_stream(str_id, true);
+	default:
+		return -EINVAL;
+	}
+}
+
+static int sst_cdev_tstamp(unsigned int str_id, struct snd_compr_tstamp *tstamp)
+{
+	struct snd_sst_tstamp fw_tstamp = {0,};
+	struct stream_info *stream;
+
+	memcpy_fromio(&fw_tstamp,
+		((void *)(sst_drv_ctx->mailbox + sst_drv_ctx->tstamp)
+		+(str_id * sizeof(fw_tstamp))),
+		sizeof(fw_tstamp));
+
+	stream = get_stream_info(str_id);
+	if (!stream)
+		return -EINVAL;
+	pr_debug("rb_counter %llu in bytes\n", fw_tstamp.ring_buffer_counter);
+
+	tstamp->copied_total = fw_tstamp.ring_buffer_counter;
+	tstamp->pcm_frames = fw_tstamp.frames_decoded;
+	tstamp->pcm_io_frames = div_u64(fw_tstamp.hardware_counter,
+			(u64)((stream->num_ch) * SST_GET_BYTES_PER_SAMPLE(24)));
+	tstamp->sampling_rate = fw_tstamp.sampling_frequency;
+	pr_debug("PCM  = %u\n", tstamp->pcm_io_frames);
+	pr_debug("Pointer Query on strid = %d  copied_total %d, decodec %d\n",
+		str_id, tstamp->copied_total, tstamp->pcm_frames);
+	pr_debug("rendered %d\n", tstamp->pcm_io_frames);
+	return 0;
+}
+
+static int sst_cdev_caps(struct snd_compr_caps *caps)
+{
+	caps->num_codecs = NUM_CODEC;
+	caps->min_fragment_size = MIN_FRAGMENT_SIZE;  /* 50KB */
+	caps->max_fragment_size = MAX_FRAGMENT_SIZE;  /* 1024KB */
+	caps->min_fragments = MIN_FRAGMENT;
+	caps->max_fragments = MAX_FRAGMENT;
+	caps->codecs[0] = SND_AUDIOCODEC_MP3;
+	caps->codecs[1] = SND_AUDIOCODEC_AAC;
+	return 0;
+}
+
+static int sst_cdev_codec_caps(struct snd_compr_codec_caps *codec)
+{
+
+	if (codec->codec == SND_AUDIOCODEC_MP3) {
+		codec->num_descriptors = 2;
+		codec->descriptor[0].max_ch = 2;
+		codec->descriptor[1].sample_rates[0] = SNDRV_PCM_RATE_8000;
+		codec->descriptor[1].sample_rates[1] = SNDRV_PCM_RATE_11025;
+		codec->descriptor[1].sample_rates[2] = SNDRV_PCM_RATE_16000;
+		codec->descriptor[1].sample_rates[3] = SNDRV_PCM_RATE_22050;
+		codec->descriptor[1].sample_rates[4] = SNDRV_PCM_RATE_32000;
+		codec->descriptor[1].sample_rates[5] = SNDRV_PCM_RATE_44100;
+		codec->descriptor[1].sample_rates[6] = SNDRV_PCM_RATE_48000;
+		codec->descriptor[0].bit_rate[0] = 320; /* 320kbps */
+		codec->descriptor[0].bit_rate[1] = 192;
+		codec->descriptor[0].num_bitrates = 2;
+		codec->descriptor[0].profiles = 0;
+		codec->descriptor[0].modes = SND_AUDIOCHANMODE_MP3_STEREO;
+		codec->descriptor[0].formats = 0;
+	} else if (codec->codec == SND_AUDIOCODEC_AAC) {
+		codec->num_descriptors = 2;
+		codec->descriptor[1].max_ch = 2;
+		codec->descriptor[1].sample_rates[0] = SNDRV_PCM_RATE_8000;
+		codec->descriptor[1].sample_rates[1] = SNDRV_PCM_RATE_11025;
+		codec->descriptor[1].sample_rates[2] = SNDRV_PCM_RATE_16000;
+		codec->descriptor[1].sample_rates[3] = SNDRV_PCM_RATE_22050;
+		codec->descriptor[1].sample_rates[4] = SNDRV_PCM_RATE_32000;
+		codec->descriptor[1].sample_rates[5] = SNDRV_PCM_RATE_44100;
+		codec->descriptor[1].sample_rates[6] = SNDRV_PCM_RATE_48000;
+		codec->descriptor[1].bit_rate[0] = 320; /* 320kbps */
+		codec->descriptor[1].bit_rate[1] = 192;
+		codec->descriptor[1].num_bitrates = 2;
+		codec->descriptor[1].profiles = 0;
+		codec->descriptor[1].modes = 0;
+		codec->descriptor[1].formats =
+			(SND_AUDIOSTREAMFORMAT_MP4ADTS |
+				SND_AUDIOSTREAMFORMAT_RAW);
+	} else {
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+void sst_cdev_fragment_elapsed(int str_id)
+{
+	struct stream_info *stream;
+
+	pr_debug("fragment elapsed from firmware for str_id %d\n", str_id);
+	stream = &sst_drv_ctx->streams[str_id];
+	if (stream->compr_cb)
+		stream->compr_cb(stream->compr_cb_param);
+}
+
+/*
+ * sst_close_pcm_stream - Close PCM interface
+ *
+ * @str_id: stream id to be closed
+ *
+ * This function is called by MID sound card driver to close
+ * an existing pcm interface
+ */
+static int sst_close_pcm_stream(unsigned int str_id)
+{
+	struct stream_info *stream;
+	int retval = 0;
+
+	pr_debug("%s: Entry\n", __func__);
+	stream = get_stream_info(str_id);
+	if (!stream) {
+		pr_err("stream info is NULL for str %d!!!\n", str_id);
+		return -EINVAL;
+	}
+
+	if (stream->status == STREAM_RESET) {
+		/* silently fail here as we have cleaned the stream */
+		pr_debug("stream in reset state...\n");
+
+		retval = 0;
+		goto put;
+	}
+
+	retval = free_stream_context(str_id);
+put:
+	stream->pcm_substream = NULL;
+	stream->status = STREAM_UN_INIT;
+	stream->period_elapsed = NULL;
+	sst_drv_ctx->stream_cnt--;
+
+	/* The free_stream will return a error if there is no stream to free,
+	(i.e. the alloc failure case). And in this case the open does a put in
+	the error scenario, so skip in this case.
+		In the close we need to handle put in the success scenario and
+	the timeout error(EBUSY) scenario. */
+	if (!retval || (retval == -EBUSY))
+		sst_pm_runtime_put(sst_drv_ctx);
+	else
+		pr_err("%s: free stream returned err %d\n", __func__, retval);
+
+	pr_debug("%s: Exit\n", __func__);
+	return 0;
+}
+
+int sst_send_sync_msg(int ipc, int str_id)
+{
+	struct ipc_post *msg = NULL;
+
+	if (sst_create_ipc_msg(&msg, false))
+		return -ENOMEM;
+	sst_fill_header(&msg->header, ipc, 0, str_id);
+	return sst_drv_ctx->ops->sync_post_message(msg);
+}
+
+static inline int sst_calc_tstamp(struct pcm_stream_info *info,
+		struct snd_pcm_substream *substream,
+		struct snd_sst_tstamp *fw_tstamp)
+{
+	size_t delay_bytes, delay_frames;
+	size_t buffer_sz;
+	u32 pointer_bytes, pointer_samples;
+
+	pr_debug("mrfld ring_buffer_counter %llu in bytes\n",
+			fw_tstamp->ring_buffer_counter);
+	pr_debug("mrfld hardware_counter %llu in bytes\n",
+			 fw_tstamp->hardware_counter);
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		delay_bytes = (size_t) (fw_tstamp->ring_buffer_counter -
+					fw_tstamp->hardware_counter);
+	else
+		delay_bytes = (size_t) (fw_tstamp->hardware_counter -
+					fw_tstamp->ring_buffer_counter);
+	delay_frames = bytes_to_frames(substream->runtime, delay_bytes);
+	buffer_sz = snd_pcm_lib_buffer_bytes(substream);
+	div_u64_rem(fw_tstamp->ring_buffer_counter, buffer_sz, &pointer_bytes);
+	pointer_samples = bytes_to_samples(substream->runtime, pointer_bytes);
+
+	pr_debug("pcm delay %zu in bytes\n", delay_bytes);
+
+	info->buffer_ptr = pointer_samples / substream->runtime->channels;
+
+	info->pcm_delay = delay_frames / substream->runtime->channels;
+	pr_debug("buffer ptr %llu pcm_delay rep: %llu\n",
+			info->buffer_ptr, info->pcm_delay);
+	return 0;
+}
+
+static int sst_read_timestamp(struct pcm_stream_info *info)
+{
+	struct stream_info *stream;
+	struct snd_pcm_substream *substream;
+	struct snd_sst_tstamp fw_tstamp;
+	unsigned int str_id;
+
+	str_id = info->str_id;
+	stream = get_stream_info(str_id);
+	if (!stream)
+		return -EINVAL;
+
+	if (!stream->pcm_substream)
+		return -EINVAL;
+	substream = stream->pcm_substream;
+
+	memcpy_fromio(&fw_tstamp,
+		((void *)(sst_drv_ctx->mailbox + sst_drv_ctx->tstamp)
+			+ (str_id * sizeof(fw_tstamp))),
+		sizeof(fw_tstamp));
+	return sst_calc_tstamp(info, substream, &fw_tstamp);
+}
+
+/*
+ * sst_device_control - Set Control params
+ *
+ * @cmd: control cmd to be set
+ * @arg: command argument
+ *
+ * This function is called by MID sound card driver to set
+ * SST/Sound card controls for an opened stream.
+ * This is registered with MID driver
+ */
+static int sst_device_control(int cmd, void *arg)
+{
+	int retval = 0, str_id = 0;
+
+
+	if (sst_drv_ctx->sst_state != SST_FW_RUNNING)
+		return 0;
+
+	switch (cmd) {
+	case SST_SND_PAUSE:
+	case SST_SND_RESUME: {
+		struct mad_ops_wq *work = kzalloc(sizeof(*work), GFP_ATOMIC);
+		if (!work)
+			return -ENOMEM;
+		INIT_WORK(&work->wq, sst_process_mad_ops);
+		work->control_op = cmd;
+		work->stream_id = *(int *)arg;
+		queue_work(sst_drv_ctx->mad_wq, &work->wq);
+		break;
+	}
+	case SST_SND_START: {
+		struct stream_info *str_info;
+		int ipc;
+		str_id = *(int *)arg;
+		str_info = get_stream_info(str_id);
+		if (!str_info)
+			return -EINVAL;
+		ipc = IPC_IA_START_STREAM;
+		str_info->prev = str_info->status;
+		str_info->status = STREAM_RUNNING;
+		sst_start_stream(str_id);
+
+		break;
+	}
+	case SST_SND_DROP: {
+		struct stream_info *str_info;
+		int ipc;
+		str_id = *(int *)arg;
+		str_info = get_stream_info(str_id);
+		if (!str_info)
+			return -EINVAL;
+		ipc = IPC_IA_DROP_STREAM;
+		str_info->prev = STREAM_UN_INIT;
+		str_info->status = STREAM_INIT;
+		if (sst_drv_ctx->use_32bit_ops)
+			retval = sst_send_sync_msg(ipc, str_id);
+		else
+			retval = sst_drop_stream(str_id);
+		break;
+	}
+	case SST_SND_STREAM_INIT: {
+		struct pcm_stream_info *str_info;
+		struct stream_info *stream;
+
+		pr_debug("stream init called\n");
+		str_info = (struct pcm_stream_info *)arg;
+		str_id = str_info->str_id;
+		stream = get_stream_info(str_id);
+		if (!stream) {
+			retval = -EINVAL;
+			break;
+		}
+		pr_debug("setting the period ptrs\n");
+		stream->pcm_substream = str_info->mad_substream;
+		stream->period_elapsed = str_info->period_elapsed;
+		stream->sfreq = str_info->sfreq;
+		stream->prev = stream->status;
+		stream->status = STREAM_INIT;
+		pr_debug("pcm_substream %p, period_elapsed %p, sfreq %d, status %d\n",
+				stream->pcm_substream, stream->period_elapsed, stream->sfreq, stream->status);
+		break;
+	}
+
+	case SST_SND_BUFFER_POINTER: {
+		struct pcm_stream_info *stream_info;
+
+		stream_info = (struct pcm_stream_info *)arg;
+		retval = sst_read_timestamp(stream_info);
+		pr_debug("pointer %llu, delay %llu\n",
+			stream_info->buffer_ptr, stream_info->pcm_delay);
+		break;
+	}
+	default:
+		/* Illegal case */
+		pr_warn("illegal req\n");
+		return -EINVAL;
+	}
+
+	return retval;
+}
+
+/*
+ * sst_copy_runtime_param - copy runtime params from src to dst
+ *				 structure.
+ *
+ *@dst: destination runtime structure
+ *@src: source runtime structure
+ *
+ * This helper function is called to copy the runtime parameter
+ * structure.
+*/
+static int sst_copy_runtime_param(struct snd_sst_runtime_params *dst,
+			struct snd_sst_runtime_params *src)
+{
+	dst->type = src->type;
+	dst->str_id = src->str_id;
+	dst->size = src->size;
+	if (dst->addr) {
+		pr_err("mem allocated in prev setting, use the same memory\n");
+		return -EINVAL;
+	}
+	dst->addr = kzalloc(dst->size, GFP_KERNEL);
+	if (!dst->addr)
+		return -ENOMEM;
+	memcpy(dst->addr, src->addr, dst->size);
+	return 0;
+}
+/*
+ * sst_set_generic_params - Set generic params
+ *
+ * @cmd: control cmd to be set
+ * @arg: command argument
+ *
+ * This function is called by MID sound card driver to configure
+ * SST runtime params.
+ */
+static int sst_set_generic_params(enum sst_controls cmd, void *arg)
+{
+	int ret_val = 0;
+	pr_debug("Enter:%s, cmd:%d\n", __func__, cmd);
+
+	if (NULL == arg)
+		return -EINVAL;
+
+	switch (cmd) {
+	case SST_SET_RUNTIME_PARAMS: {
+		struct snd_sst_runtime_params *src;
+		struct snd_sst_runtime_params *dst;
+
+		src = (struct snd_sst_runtime_params *)arg;
+		dst = &(sst_drv_ctx->runtime_param.param);
+		ret_val = sst_copy_runtime_param(dst, src);
+		break;
+		}
+	case SST_SET_ALGO_PARAMS: {
+		unsigned int device_input_mixer = *((unsigned int *)arg);
+		pr_debug("LPE mixer algo param set %x\n", device_input_mixer);
+		mutex_lock(&sst_drv_ctx->mixer_ctrl_lock);
+		sst_drv_ctx->device_input_mixer = device_input_mixer;
+		mutex_unlock(&sst_drv_ctx->mixer_ctrl_lock);
+		ret_val = sst_send_lpe_mixer_algo_params();
+		break;
+	}
+	case SST_SET_BYTE_STREAM: {
+		ret_val = intel_sst_check_device();
+		if (ret_val)
+			return ret_val;
+
+		ret_val = sst_send_byte_stream_mrfld(arg);
+		sst_pm_runtime_put(sst_drv_ctx);
+		break;
+	}
+	case SST_GET_PROBE_BYTE_STREAM: {
+		struct snd_sst_probe_bytes *prb_bytes = (struct snd_sst_probe_bytes *)arg;
+
+		if (sst_drv_ctx->probe_bytes) {
+			prb_bytes->len = sst_drv_ctx->probe_bytes->len;
+			memcpy(prb_bytes->bytes, &sst_drv_ctx->probe_bytes->bytes, prb_bytes->len);
+		}
+		break;
+	}
+	case SST_SET_PROBE_BYTE_STREAM: {
+		struct snd_sst_probe_bytes *prb_bytes = (struct snd_sst_probe_bytes *)arg;
+
+		if (sst_drv_ctx->probe_bytes) {
+			sst_drv_ctx->probe_bytes->len = prb_bytes->len;
+			memcpy(&sst_drv_ctx->probe_bytes->bytes, prb_bytes->bytes, prb_bytes->len);
+		}
+
+		ret_val = intel_sst_check_device();
+		if (ret_val)
+			return ret_val;
+
+		ret_val = sst_send_probe_bytes(sst_drv_ctx);
+		break;
+	}
+	case SST_SET_VTSV_INFO: {
+		ret_val = intel_sst_check_device();
+		if (ret_val)
+			return ret_val;
+
+		ret_val = sst_send_vtsv_data_to_fw(sst_drv_ctx);
+		if (ret_val)
+			pr_err("vtsv data send failed\n");
+		sst_pm_runtime_put(sst_drv_ctx);
+		break;
+	}
+	default:
+		pr_err("Invalid cmd request:%d\n", cmd);
+		ret_val = -EINVAL;
+	}
+	return ret_val;
+}
+
+static struct sst_ops pcm_ops = {
+	.open = sst_open_pcm_stream,
+	.device_control = sst_device_control,
+	.set_generic_params = sst_set_generic_params,
+	.close = sst_close_pcm_stream,
+	.power = sst_power_control,
+};
+
+static struct compress_sst_ops compr_ops = {
+	.open = sst_cdev_open,
+	.close = sst_cdev_close,
+	.control = sst_cdev_control,
+	.tstamp = sst_cdev_tstamp,
+	.ack = sst_cdev_ack,
+	.get_caps = sst_cdev_caps,
+	.get_codec_caps = sst_cdev_codec_caps,
+	.set_metadata = sst_cdev_set_metadata,
+};
+
+
+static struct sst_device sst_dsp_device = {
+	.name = "Intel(R) SST LPE",
+	.dev = NULL,
+	.ops = &pcm_ops,
+	.compr_ops = &compr_ops,
+};
+
+/*
+ * register_sst - function to register DSP
+ *
+ * This functions registers DSP with the platform driver
+ */
+int register_sst(struct device *dev)
+{
+	int ret_val;
+	sst_dsp_device.dev = dev;
+	ret_val = sst_register_dsp(&sst_dsp_device);
+	if (ret_val)
+		pr_err("Unable to register DSP with platform driver\n");
+
+	return ret_val;
+}
+
+int unregister_sst(struct device *dev)
+{
+	return sst_unregister_dsp(&sst_dsp_device);
+}
diff --git a/sound/soc/intel/sst/sst_dsp.c b/sound/soc/intel/sst/sst_dsp.c
new file mode 100644
index 0000000..780308a
--- /dev/null
+++ b/sound/soc/intel/sst/sst_dsp.c
@@ -0,0 +1,2008 @@
+/*
+ *  sst_dsp.c - Intel SST Driver for audio engine
+ *
+ *  Copyright (C) 2008-10	Intel Corp
+ *  Authors:	Vinod Koul <vinod.koul@intel.com>
+ *		Harsha Priya <priya.harsha@intel.com>
+ *		Dharageswari R <dharageswari.r@intel.com>
+ *		KP Jeeja <jeeja.kp@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This file contains all dsp controlling functions like firmware download,
+ * setting/resetting dsp cores, etc
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/firmware.h>
+#include <linux/dmaengine.h>
+#include <linux/intel_mid_dma.h>
+#include <linux/pm_qos.h>
+#include <linux/intel_mid_pm.h>
+#include <linux/elf.h>
+#include "../sst_platform.h"
+#include "../platform_ipc_v2.h"
+#include "sst.h"
+#include "sst_trace.h"
+
+#ifndef CONFIG_X86_64
+#define MEMCPY_TOIO memcpy_toio
+#else
+#define MEMCPY_TOIO memcpy32_toio
+#endif
+
+static struct sst_module_info sst_modules_mrfld[] = {
+	{"mp3_dec", SST_CODEC_TYPE_MP3, 0, SST_LIB_NOT_FOUND},
+	{"aac_dec", SST_CODEC_TYPE_AAC, 0, SST_LIB_NOT_FOUND},
+	{"audclass_lib", SST_ALGO_AUDCLASSIFIER, 0, SST_LIB_NOT_FOUND},
+	{"vtsv_lib", SST_ALGO_VTSV, 0, SST_LIB_NOT_FOUND},
+	{"geq_lib", SST_ALGO_GEQ, 0, SST_LIB_NOT_FOUND},
+};
+
+static struct sst_module_info sst_modules_byt[] = {
+	{"mp3_dec", SST_CODEC_TYPE_MP3, 0, SST_LIB_NOT_FOUND},
+	{"aac_dec", SST_CODEC_TYPE_AAC, 0, SST_LIB_NOT_FOUND},
+};
+
+/**
+ * memcpy32_toio: Copy using writel commands
+ *
+ * This is needed because the hardware does not support
+ * 64-bit moveq insructions while writing to PCI MMIO
+ */
+void memcpy32_toio(void *dst, const void *src, int count)
+{
+	int i;
+	const u32 *src_32 = src;
+	u32 *dst_32 = dst;
+
+	for (i = 0; i < count/sizeof(u32); i++)
+		writel(*src_32++, dst_32++);
+}
+
+/**
+ * intel_sst_reset_dsp_medfield - Resetting SST DSP
+ *
+ * This resets DSP in case of Medfield platfroms
+ */
+int intel_sst_reset_dsp_mfld(void)
+{
+	union config_status_reg csr;
+
+	pr_debug("Resetting the DSP in medfield\n");
+	mutex_lock(&sst_drv_ctx->csr_lock);
+	csr.full = sst_shim_read(sst_drv_ctx->shim, SST_CSR);
+	csr.full |= 0x382;
+	csr.part.run_stall = 0x1;
+	sst_shim_write(sst_drv_ctx->shim, SST_CSR, csr.full);
+	mutex_unlock(&sst_drv_ctx->csr_lock);
+
+	return 0;
+}
+
+/**
+ * sst_start_medfield - Start the SST DSP processor
+ *
+ * This starts the DSP in MRST platfroms
+ */
+int sst_start_mfld(void)
+{
+	union config_status_reg csr;
+
+	mutex_lock(&sst_drv_ctx->csr_lock);
+	csr.full = sst_shim_read(sst_drv_ctx->shim, SST_CSR);
+	csr.part.bypass = 0;
+	sst_shim_write(sst_drv_ctx->shim, SST_CSR, csr.full);
+	csr.full = sst_shim_read(sst_drv_ctx->shim, SST_CSR);
+	csr.part.mfld_strb = 1;
+	sst_shim_write(sst_drv_ctx->shim, SST_CSR, csr.full);
+	csr.full = sst_shim_read(sst_drv_ctx->shim, SST_CSR);
+	csr.part.run_stall = 0;
+	csr.part.sst_reset = 0;
+	pr_debug("Starting the DSP_medfld %x\n", csr.full);
+	sst_shim_write(sst_drv_ctx->shim, SST_CSR, csr.full);
+	pr_debug("Starting the DSP_medfld\n");
+	mutex_unlock(&sst_drv_ctx->csr_lock);
+
+	return 0;
+}
+/**
+ * intel_sst_reset_dsp_mrfld - Resetting SST DSP
+ *
+ * This resets DSP in case of MRFLD platfroms
+ */
+int intel_sst_reset_dsp_mrfld(void)
+{
+	union config_status_reg_mrfld csr;
+
+	pr_debug("sst: Resetting the DSP in mrfld\n");
+	mutex_lock(&sst_drv_ctx->csr_lock);
+	csr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);
+
+	pr_debug("value:0x%llx\n", csr.full);
+
+	csr.full |= 0x7;
+	sst_shim_write64(sst_drv_ctx->shim, SST_CSR, csr.full);
+	csr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);
+
+	pr_debug("value:0x%llx\n", csr.full);
+
+	csr.full &= ~(0x1);
+	sst_shim_write64(sst_drv_ctx->shim, SST_CSR, csr.full);
+
+	csr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);
+	pr_debug("value:0x%llx\n", csr.full);
+	mutex_unlock(&sst_drv_ctx->csr_lock);
+	return 0;
+}
+
+/**
+ * sst_start_merrifield - Start the SST DSP processor
+ *
+ * This starts the DSP in MERRIFIELD platfroms
+ */
+int sst_start_mrfld(void)
+{
+	union config_status_reg_mrfld csr;
+
+	pr_debug("sst: Starting the DSP in mrfld LALALALA\n");
+	mutex_lock(&sst_drv_ctx->csr_lock);
+	csr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);
+	pr_debug("value:0x%llx\n", csr.full);
+
+	csr.full |= 0x7;
+	sst_shim_write64(sst_drv_ctx->shim, SST_CSR, csr.full);
+
+	csr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);
+	pr_debug("value:0x%llx\n", csr.full);
+
+	csr.part.xt_snoop = 1;
+	csr.full &= ~(0x5);
+	sst_shim_write64(sst_drv_ctx->shim, SST_CSR, csr.full);
+
+	csr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);
+	pr_debug("sst: Starting the DSP_merrifield:%llx\n", csr.full);
+	mutex_unlock(&sst_drv_ctx->csr_lock);
+	return 0;
+}
+
+/**
+ * intel_sst_set_bypass - Sets/clears the bypass bits
+ *
+ * This sets/clears the bypass bits
+ */
+void intel_sst_set_bypass_mfld(bool set)
+{
+	union config_status_reg csr;
+
+	mutex_lock(&sst_drv_ctx->csr_lock);
+	csr.full = sst_shim_read(sst_drv_ctx->shim, SST_CSR);
+	if (set == true)
+		csr.full |= 0x380;
+	else
+		csr.part.bypass = 0;
+	pr_debug("SetupByPass set %d Val 0x%x\n", set, csr.full);
+	sst_shim_write(sst_drv_ctx->shim, SST_CSR, csr.full);
+	mutex_unlock(&sst_drv_ctx->csr_lock);
+
+}
+#define SST_CALC_DMA_DSTN(lpe_viewpt_rqd, ia_viewpt_addr, elf_paddr, \
+			lpe_viewpt_addr) ((lpe_viewpt_rqd) ? \
+		elf_paddr : (ia_viewpt_addr + elf_paddr - lpe_viewpt_addr))
+
+static int sst_fill_dstn(struct intel_sst_drv *sst, struct sst_info info,
+			Elf32_Phdr *pr, void **dstn, unsigned int *dstn_phys, int *mem_type)
+{
+#ifdef MRFLD_WORD_WA
+	/* work arnd-since only 4 byte align copying is only allowed for ICCM */
+	if ((pr->p_paddr >= info.iram_start) && (pr->p_paddr < info.iram_end)) {
+		size_t data_size = pr->p_filesz % SST_ICCM_BOUNDARY;
+
+		if (data_size)
+			pr->p_filesz += 4 - data_size;
+		*dstn = sst->iram + (pr->p_paddr - info.iram_start);
+		*dstn_phys = SST_CALC_DMA_DSTN(info.lpe_viewpt_rqd,
+				sst->iram_base, pr->p_paddr, info.iram_start);
+		*mem_type = 1;
+	}
+#else
+	if ((pr->p_paddr >= info.iram_start) &&
+	    (pr->p_paddr < info.iram_end)) {
+
+		*dstn = sst->iram + (pr->p_paddr - info.iram_start);
+		*dstn_phys = SST_CALC_DMA_DSTN(info.lpe_viewpt_rqd,
+				sst->iram_base, pr->p_paddr, info.iram_start);
+		*mem_type = 1;
+	}
+#endif
+	else if ((pr->p_paddr >= info.dram_start) &&
+		 (pr->p_paddr < info.dram_end)) {
+
+		*dstn = sst->dram + (pr->p_paddr - info.dram_start);
+		*dstn_phys = SST_CALC_DMA_DSTN(info.lpe_viewpt_rqd,
+				sst->dram_base, pr->p_paddr, info.dram_start);
+		*mem_type = 1;
+	} else if ((pr->p_paddr >= info.imr_start) &&
+		   (pr->p_paddr < info.imr_end)) {
+
+		*dstn = sst->ddr + (pr->p_paddr - info.imr_start);
+		*dstn_phys =  sst->ddr_base + pr->p_paddr - info.imr_start;
+		*mem_type = 0;
+	} else {
+	       return -EINVAL;
+	}
+	return 0;
+}
+
+static void sst_fill_info(struct intel_sst_drv *sst,
+			struct sst_info *info)
+{
+	/* first we setup addresses to be used for elf sections */
+	if (sst->info.iram_use) {
+		info->iram_start = sst->info.iram_start;
+		info->iram_end = sst->info.iram_end;
+	} else {
+		info->iram_start = sst->iram_base;
+		info->iram_end = sst->iram_end;
+	}
+	if (sst->info.dram_use) {
+		info->dram_start = sst->info.dram_start;
+		info->dram_end = sst->info.dram_end;
+	} else {
+		info->dram_start = sst->dram_base;
+		info->dram_end = sst->dram_end;
+	}
+	if (sst->info.imr_use) {
+		info->imr_start = sst->info.imr_start;
+		info->imr_end = sst->info.imr_end;
+	} else {
+		info->imr_start = relocate_imr_addr_mrfld(sst->ddr_base);
+		info->imr_end = relocate_imr_addr_mrfld(sst->ddr_end);
+	}
+
+	info->lpe_viewpt_rqd = sst->info.lpe_viewpt_rqd;
+	info->dma_max_len = sst->info.dma_max_len;
+	pr_debug("%s: dma_max_len 0x%x", __func__, info->dma_max_len);
+}
+
+static inline int sst_validate_elf(const struct firmware *sst_bin, bool dynamic)
+{
+	Elf32_Ehdr *elf;
+
+	BUG_ON(!sst_bin);
+
+	pr_debug("IN %s\n", __func__);
+
+	elf = (Elf32_Ehdr *)sst_bin->data;
+
+	if ((elf->e_ident[0] != 0x7F) || (elf->e_ident[1] != 'E') ||
+	    (elf->e_ident[2] != 'L') || (elf->e_ident[3] != 'F')) {
+		pr_debug("ELF Header Not found!%zu\n", sst_bin->size);
+		return -EINVAL;
+	}
+
+	if (dynamic == true) {
+		if (elf->e_type != ET_DYN) {
+			pr_err("Not a dynamic loadable library\n");
+			return -EINVAL;
+		}
+	}
+	pr_debug("Valid ELF Header...%zu\n", sst_bin->size);
+	return 0;
+}
+
+/**
+ * sst_validate_fw_image - validates the firmware signature
+ *
+ * @sst_fw_in_mem	: pointer to audio FW
+ * @size		: size of the firmware
+ * @module		: points to the FW modules
+ * @num_modules		: points to the num of modules
+ * This function validates the header signature in the FW image
+ */
+static int sst_validate_fw_image(const void *sst_fw_in_mem, unsigned long size,
+		struct fw_module_header **module, u32 *num_modules)
+{
+	struct fw_header *header;
+
+	pr_debug("%s\n", __func__);
+
+	/* Read the header information from the data pointer */
+	header = (struct fw_header *)sst_fw_in_mem;
+	pr_debug("header sign=%s size=%x modules=%x fmt=%x size=%zx\n",
+			header->signature, header->file_size, header->modules,
+			header->file_format, sizeof(*header));
+
+	/* verify FW */
+	if ((strncmp(header->signature, SST_FW_SIGN, 4) != 0) ||
+		(size != header->file_size + sizeof(*header))) {
+		/* Invalid FW signature */
+		pr_err("InvalidFW sign/filesize mismatch\n");
+		return -EINVAL;
+	}
+	*num_modules = header->modules;
+	*module = (void *)sst_fw_in_mem + sizeof(*header);
+
+	return 0;
+}
+
+/**
+ * sst_validate_library - validates the library signature
+ *
+ * @fw_lib			: pointer to FW library
+ * @slot			: pointer to the lib slot info
+ * @entry_point		: out param, which contains the module entry point
+ * This function is called before downloading the codec/postprocessing
+ * library
+ */
+static int sst_validate_library(const struct firmware *fw_lib,
+		struct lib_slot_info *slot,
+		u32 *entry_point)
+{
+	struct fw_header *header;
+	struct fw_module_header *module;
+	struct fw_block_info *block;
+	unsigned int n_blk, isize = 0, dsize = 0;
+	int err = 0;
+
+	header = (struct fw_header *)fw_lib->data;
+	if (header->modules != 1) {
+		pr_err("Module no mismatch found\n");
+		err = -EINVAL;
+		goto exit;
+	}
+	module = (void *)fw_lib->data + sizeof(*header);
+	*entry_point = module->entry_point;
+	pr_debug("Module entry point 0x%x\n", *entry_point);
+	pr_debug("Module Sign %s, Size 0x%x, Blocks 0x%x Type 0x%x\n",
+			module->signature, module->mod_size,
+			module->blocks, module->type);
+
+	block = (void *)module + sizeof(*module);
+	for (n_blk = 0; n_blk < module->blocks; n_blk++) {
+		switch (block->type) {
+		case SST_IRAM:
+			isize += block->size;
+			break;
+		case SST_DRAM:
+			dsize += block->size;
+			break;
+		default:
+			pr_err("Invalid block type for 0x%x\n", n_blk);
+			err = -EINVAL;
+			goto exit;
+		}
+		block = (void *)block + sizeof(*block) + block->size;
+	}
+	if (isize > slot->iram_size || dsize > slot->dram_size) {
+		pr_err("library exceeds size allocated\n");
+		err = -EINVAL;
+		goto exit;
+	} else
+		pr_debug("Library is safe for download...\n");
+
+	pr_debug("iram 0x%x, dram 0x%x, iram 0x%x, dram 0x%x\n",
+			isize, dsize, slot->iram_size, slot->dram_size);
+exit:
+	return err;
+
+}
+
+static bool chan_filter(struct dma_chan *chan, void *param)
+{
+	struct sst_dma *dma = (struct sst_dma *)param;
+
+	/* we only need MID_DMAC1 as that can access DSP RAMs*/
+	if (chan->device->dev == dma->dev)
+		return true;
+
+	return false;
+}
+
+static unsigned int
+sst_get_elf_sg_len(struct intel_sst_drv *sst, Elf32_Ehdr *elf, Elf32_Phdr *pr,
+		struct sst_info info)
+{
+	unsigned int i = 0, count = 0;
+
+	pr_debug("in %s: dma_max_len 0x%x\n", __func__, info.dma_max_len);
+
+	while (i < elf->e_phnum) {
+		if (pr[i].p_type == PT_LOAD) {
+
+			if ((pr[i].p_paddr >= info.iram_start) &&
+					(pr[i].p_paddr < info.iram_end &&
+						pr[i].p_filesz)) {
+				count += (pr[i].p_filesz) / info.dma_max_len;
+
+				if ((pr[i].p_filesz) % info.dma_max_len)
+					count++;
+
+			} else if ((pr[i].p_paddr >= info.dram_start) &&
+					(pr[i].p_paddr < info.dram_end &&
+						pr[i].p_filesz)) {
+				count += (pr[i].p_filesz) / info.dma_max_len;
+
+				if ((pr[i].p_filesz) % info.dma_max_len)
+					count++;
+
+			} else if ((pr[i].p_paddr >= info.imr_start) &&
+					(pr[i].p_paddr < info.imr_end &&
+						pr[i].p_filesz)) {
+				count += (pr[i].p_filesz) / info.dma_max_len;
+
+				if ((pr[i].p_filesz) % info.dma_max_len)
+					count++;
+			}
+		}
+		i++;
+	}
+
+	pr_debug("gotcha count %d\n", count);
+	return count;
+}
+
+static int
+sst_init_dma_sg_list(struct intel_sst_drv *sst, unsigned int len,
+		struct scatterlist **src, struct scatterlist **dstn)
+{
+	struct scatterlist *sg_src = NULL, *sg_dst = NULL;
+
+	sg_src = kzalloc(sizeof(*sg_src)*(len), GFP_KERNEL);
+	if (NULL == sg_src)
+		return -ENOMEM;
+	sg_init_table(sg_src, len);
+	sg_dst = kzalloc(sizeof(*sg_dst)*(len), GFP_KERNEL);
+	if (NULL == sg_dst) {
+		kfree(sg_src);
+		return -ENOMEM;
+	}
+	sg_init_table(sg_dst, len);
+	*src = sg_src;
+	*dstn = sg_dst;
+
+	return 0;
+}
+
+static int sst_alloc_dma_chan(struct sst_dma *dma)
+{
+	dma_cap_mask_t mask;
+	struct intel_mid_dma_slave *slave = &dma->slave;
+	int retval;
+	struct pci_dev *dmac = NULL;
+	const char *hid;
+
+	pr_debug("%s\n", __func__);
+	dma->dev = NULL;
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_MEMCPY, mask);
+
+	if (sst_drv_ctx->pci_id == SST_CLV_PCI_ID)
+		dmac = pci_get_device(PCI_VENDOR_ID_INTEL,
+				      PCI_DMAC_CLV_ID, NULL);
+	else if (sst_drv_ctx->pci_id == SST_MRFLD_PCI_ID)
+		dmac = pci_get_device(PCI_VENDOR_ID_INTEL,
+				      PCI_DMAC_MRFLD_ID, NULL);
+#if 0
+	else if (sst_drv_ctx->pci_id == PCI_DEVICE_ID_INTEL_SST_MOOR)
+		dmac = pci_get_device(PCI_VENDOR_ID_INTEL,
+			      PCI_DEVICE_ID_INTEL_AUDIO_DMAC0_MOOR, NULL);
+#endif
+	else if (sst_drv_ctx->pci_id == SST_BYT_PCI_ID ||
+			sst_drv_ctx->pci_id == SST_CHT_PCI_ID) {
+		hid = sst_drv_ctx->hid;
+		if (!strncmp(hid, "LPE0F281", 8))
+			dma->dev = intel_mid_get_acpi_dma("DMA0F28");
+		else if (!strncmp(hid, "80860F28", 8))
+			dma->dev = intel_mid_get_acpi_dma("ADMA0F28");
+		else if (!strncmp(hid, "808622A8", 8))
+			dma->dev = intel_mid_get_acpi_dma("ADMA22A8");
+		else if (!strncmp(hid, "LPE0F28", 7))
+			dma->dev = intel_mid_get_acpi_dma("DMA0F28");
+	}
+
+	if (!dmac && !dma->dev) {
+		pr_err("Can't find DMAC\n");
+		return -ENODEV;
+	}
+	if (dmac)
+		dma->dev = &dmac->dev;
+
+	dma->ch = dma_request_channel(mask, chan_filter, dma);
+	if (!dma->ch) {
+		pr_err("unable to request dma channel\n");
+		return -EIO;
+	}
+
+	slave->dma_slave.direction = DMA_MEM_TO_MEM;
+	slave->hs_mode = 0;
+	slave->cfg_mode = LNW_DMA_MEM_TO_MEM;
+	slave->dma_slave.src_addr_width = slave->dma_slave.dst_addr_width =
+						DMA_SLAVE_BUSWIDTH_4_BYTES;
+	slave->dma_slave.src_maxburst = slave->dma_slave.dst_maxburst =
+							LNW_DMA_MSIZE_16;
+
+	retval = dmaengine_slave_config(dma->ch, &slave->dma_slave);
+	if (retval) {
+		pr_err("unable to set slave config, err %d\n", retval);
+		dma_release_channel(dma->ch);
+		return -EIO;
+	}
+	return retval;
+}
+
+static void sst_dma_transfer_complete(void *arg)
+{
+	sst_drv_ctx  = (struct intel_sst_drv *)arg;
+	pr_debug(" sst_dma_transfer_complete\n");
+	sst_wake_up_block(sst_drv_ctx, 0, FW_DWNL_ID, FW_DWNL_ID, NULL, 0);
+}
+
+static inline int sst_dma_wait_for_completion(struct intel_sst_drv *sst)
+{
+	int ret = 0;
+	struct sst_block *block;
+	/* call prep and wait */
+	sst->desc->callback = sst_dma_transfer_complete;
+	sst->desc->callback_param = sst;
+
+	block = sst_create_block(sst, FW_DWNL_ID, FW_DWNL_ID);
+	if (block == NULL)
+		return -ENOMEM;
+
+	sst->desc->tx_submit(sst_drv_ctx->desc);
+	ret = sst_wait_timeout(sst, block);
+	if (ret)
+		dma_wait_for_async_tx(sst_drv_ctx->desc);
+	sst_free_block(sst, block);
+	return ret;
+}
+
+static int sst_dma_firmware(struct sst_dma *dma, struct sst_sg_list *sg_list)
+{
+	int retval = 0;
+	enum dma_ctrl_flags flag = DMA_CTRL_ACK;
+	struct scatterlist *sg_src_list, *sg_dst_list;
+	int length;
+	pr_debug("%s: use_lli %d\n", __func__, sst_drv_ctx->use_lli);
+
+	sg_src_list = sg_list->src;
+	sg_dst_list = sg_list->dst;
+	length = sg_list->list_len;
+
+	/* BY default PIMR is unsmasked
+	 * FW gets unmaksed dma intr too, so mask it for FW to execute on mrfld
+	 */
+	/*FIXME: Need to check if this workaround is valid for CHT*/
+	if (sst_drv_ctx->pci_id == SST_MRFLD_PCI_ID ||
+	    sst_drv_ctx->pci_id == SST_BYT_PCI_ID ||
+#if 0
+	    sst_drv_ctx->pci_id == PCI_DEVICE_ID_INTEL_SST_MOOR ||
+#endif
+			sst_drv_ctx->pci_id == SST_CHT_PCI_ID)
+		sst_shim_write(sst_drv_ctx->shim, SST_PIMR, 0xFFFF0034);
+
+	if (sst_drv_ctx->use_lli) {
+		sst_drv_ctx->desc = dma->ch->device->device_prep_dma_sg(dma->ch,
+					sg_dst_list, length,
+					sg_src_list, length, flag);
+		if (!sst_drv_ctx->desc)
+			return -EFAULT;
+		retval = sst_dma_wait_for_completion(sst_drv_ctx);
+		if (retval)
+			pr_err("sst_dma_firmware..timeout!\n");
+	} else {
+		struct scatterlist *sg;
+		dma_addr_t src_addr, dstn_addr;
+		int i = 0;
+
+		/* dma single block mode */
+		for_each_sg(sg_src_list, sg, length, i) {
+			pr_debug("dma desc %d, length %d\n", i, sg->length);
+			src_addr = sg_phys(sg);
+			dstn_addr = sg_phys(sg_dst_list);
+			if (sg_dst_list)
+				sg_dst_list = sg_next(sg_dst_list);
+			sst_drv_ctx->desc = dma->ch->device->device_prep_dma_memcpy(
+					dma->ch, dstn_addr, src_addr, sg->length, flag);
+			if (!sst_drv_ctx->desc)
+				return -EFAULT;
+			retval = sst_dma_wait_for_completion(sst_drv_ctx);
+			if (retval)
+				pr_err("sst_dma_firmware..timeout!\n");
+
+		}
+	}
+
+	return retval;
+}
+
+/*
+ * sst_fill_sglist - Fill the sg list
+ *
+ * @from: src address of the fw
+ * @to: virtual address of IRAM/DRAM
+ * @block_size: size of the block
+ * @sg_src: source scatterlist pointer
+ * @sg_dst: Destination scatterlist pointer
+ * @fw_sg_list: Pointer to the sg_list
+ * @dma_max_len: maximum len of the DMA block
+ *
+ * Parses modules that need to be placed in SST IRAM and DRAM
+ * and stores them in a sg list for transfer
+ * returns error or 0 if list creation fails or pass.
+  */
+static int sst_fill_sglist(unsigned long from, unsigned long to,
+		u32 block_size, struct scatterlist **sg_src, struct scatterlist **sg_dstn,
+		struct sst_sg_list *fw_sg_list, u32 dma_max_len)
+{
+	u32 offset = 0;
+	int len = 0;
+	unsigned long dstn, src;
+
+	pr_debug("%s entry", __func__);
+	if (!sg_src || !sg_dstn)
+		return -EINVAL;
+
+	do {
+		dstn = (unsigned long) (to + offset);
+		src = (unsigned long) (from + offset);
+
+		/* split blocks to dma_max_len */
+
+		len = block_size - offset;
+		pr_debug("DMA blk src %lx,dstn %lx,len %d,offset %d, size %d\n",
+			src, dstn, len, offset, block_size);
+		if (len > dma_max_len) {
+			pr_debug("block size exceeds %d\n", dma_max_len);
+			len = dma_max_len;
+			offset += len;
+		} else {
+			pr_debug("Node length less that %d\n", dma_max_len);
+			offset = 0;
+		}
+
+		if (!(*sg_src) || !(*sg_dstn))
+			return -ENOMEM;
+
+		sg_set_page(*sg_src, virt_to_page((void *) src), len,
+				offset_in_page((void *) src));
+		sg_set_page(*sg_dstn, virt_to_page((void *) dstn), len,
+				offset_in_page((void *) dstn));
+
+		*sg_src = sg_next(*sg_src);
+		*sg_dstn = sg_next(*sg_dstn);
+
+		/* TODO: is sg_idx required? */
+		if (sst_drv_ctx->info.use_elf == true)
+			fw_sg_list->sg_idx++;
+	} while (offset > 0);
+
+	return 0;
+}
+
+static int sst_parse_elf_module_dma(struct intel_sst_drv *sst, const void *fw,
+		 struct sst_info info, Elf32_Phdr *pr,
+		 struct scatterlist **sg_src, struct scatterlist **sg_dstn,
+		 struct sst_sg_list *fw_sg_list)
+{
+	unsigned long dstn, src;
+	unsigned int dstn_phys;
+	int ret_val = 0;
+	int mem_type;
+
+	ret_val = sst_fill_dstn(sst, info, pr, (void *)&dstn, &dstn_phys, &mem_type);
+	if (ret_val)
+		return ret_val;
+
+	dstn = (unsigned long) phys_to_virt(dstn_phys);
+	src = (unsigned long) (fw + pr->p_offset);
+
+	ret_val = sst_fill_sglist(src, dstn, pr->p_filesz,
+				sg_src, sg_dstn, fw_sg_list, sst->info.dma_max_len);
+
+	return ret_val;
+}
+
+static int
+sst_parse_elf_fw_dma(struct intel_sst_drv *sst, const void *fw_in_mem,
+			struct sst_sg_list *fw_sg_list)
+{
+	int i = 0, ret = 0;
+	Elf32_Ehdr *elf;
+	Elf32_Phdr *pr;
+	struct sst_info info;
+	struct scatterlist *sg_src = NULL, *sg_dst = NULL;
+	unsigned int sg_len;
+
+	BUG_ON(!fw_in_mem);
+
+	elf = (Elf32_Ehdr *)fw_in_mem;
+	pr = (Elf32_Phdr *) (fw_in_mem + elf->e_phoff);
+	pr_debug("%s entry\n", __func__);
+
+	sst_fill_info(sst, &info);
+
+	sg_len = sst_get_elf_sg_len(sst, elf, pr, info);
+	if (sg_len == 0) {
+		pr_err("we got NULL sz ELF, abort\n");
+		return -EIO;
+	}
+
+	if (sst_init_dma_sg_list(sst, sg_len, &sg_src, &sg_dst)) {
+		ret = -ENOMEM;
+		goto err1;
+	}
+
+	fw_sg_list->src = sg_src;
+	fw_sg_list->dst = sg_dst;
+	fw_sg_list->list_len = sg_len;
+	fw_sg_list->sg_idx = 0;
+
+	while (i < elf->e_phnum) {
+		if ((pr[i].p_type == PT_LOAD) && (pr[i].p_filesz)) {
+			ret = sst_parse_elf_module_dma(sst, fw_in_mem, info,
+					&pr[i], &sg_src, &sg_dst, fw_sg_list);
+			if (ret)
+				goto err;
+		}
+		i++;
+	}
+	return 0;
+err:
+	kfree(fw_sg_list->src);
+	kfree(fw_sg_list->dst);
+err1:
+	fw_sg_list->src = NULL;
+	fw_sg_list->dst = NULL;
+	fw_sg_list->list_len = 0;
+	fw_sg_list->sg_idx = 0;
+
+	return ret;
+}
+
+/**
+ * sst_parse_module_dma - Parse audio FW modules and populate the dma list
+ *
+ * @sst_ctx	: sst driver context
+ * @module	: FW module header
+ * @sg_list	: Pointer to the sg_list to be populated
+ * Count the length for scattergather list
+ * and create the scattergather list of same length
+ * returns error or 0 if module sizes are proper
+ */
+static int sst_parse_module_dma(struct intel_sst_drv *sst_ctx,
+				struct fw_module_header *module,
+				struct sst_sg_list *sg_list)
+{
+	struct fw_block_info *block;
+	u32 count;
+	unsigned long ram, src;
+	int retval, sg_len = 0;
+	struct scatterlist *sg_src, *sg_dst;
+
+	pr_debug("module sign %s size %x blocks %x type %x\n",
+			module->signature, module->mod_size,
+			module->blocks, module->type);
+	pr_debug("module entrypoint 0x%x\n", module->entry_point);
+
+	block = (void *)module + sizeof(*module);
+
+	for (count = 0; count < module->blocks; count++) {
+		if (block->type != SST_CUSTOM_INFO) {
+			sg_len += (block->size) / sst_drv_ctx->info.dma_max_len;
+			if (block->size % sst_drv_ctx->info.dma_max_len)
+				sg_len = sg_len + 1;
+		}
+		block = (void *)block + sizeof(*block) + block->size;
+	}
+
+	if (sst_init_dma_sg_list(sst_ctx, sg_len, &sg_src, &sg_dst)) {
+		retval = -ENOMEM;
+		goto err1;
+	}
+
+	sg_list->src = sg_src;
+	sg_list->dst = sg_dst;
+	sg_list->list_len = sg_len;
+
+	block = (void *)module + sizeof(*module);
+
+	for (count = 0; count < module->blocks; count++) {
+		if (block->size <= 0) {
+			pr_err("block size invalid\n");
+			retval = -EINVAL;
+			goto err;
+		}
+		switch (block->type) {
+		case SST_IRAM:
+			ram = sst_ctx->iram_base;
+			break;
+		case SST_DRAM:
+			ram = sst_ctx->dram_base;
+			break;
+		case SST_DDR:
+			ram = sst_drv_ctx->ddr_base;
+			break;
+		case SST_CUSTOM_INFO:
+			block = (void *)block + sizeof(*block) + block->size;
+			continue;
+		default:
+			pr_err("wrong ram type0x%x in block0x%x\n",
+					block->type, count);
+			retval = -EINVAL;
+			goto err;
+		}
+
+		/*converting from physical to virtual because
+		scattergather list works on virtual pointers*/
+		ram = (unsigned long) phys_to_virt(ram);
+		ram = (unsigned long)(ram + block->ram_offset);
+		src = (unsigned long) (void *)block + sizeof(*block);
+
+		retval = sst_fill_sglist(src, ram,
+				block->size, &sg_src, &sg_dst,
+				sg_list, sst_ctx->info.dma_max_len);
+		if (retval)
+			goto err;
+
+		block = (void *)block + sizeof(*block) + block->size;
+	}
+	return 0;
+err:
+	kfree(sg_list->src);
+	kfree(sg_list->dst);
+err1:
+	sg_list->src = NULL;
+	sg_list->dst = NULL;
+	sg_list->list_len = 0;
+
+	return retval;
+}
+
+/**
+ * sst_parse_fw_dma - parse the firmware image & populate the list for dma
+ *
+ * @sst_fw_in_mem	: pointer to audio fw
+ * @size		: size of the firmware
+ * @fw_list		: pointer to sst_sg_list to be populated
+ * This function parses the FW image and saves the parsed image in the list
+ * for dma
+ */
+static int sst_parse_fw_dma(const void *sst_fw_in_mem, unsigned long size,
+				struct sst_sg_list *fw_list)
+{
+	struct fw_module_header *module;
+	u32 count, num_modules;
+	int ret_val;
+
+	ret_val = sst_validate_fw_image(sst_fw_in_mem, size,
+				&module, &num_modules);
+	if (ret_val)
+		return ret_val;
+
+	for (count = 0; count < num_modules; count++) {
+		/* module */
+		ret_val = sst_parse_module_dma(sst_drv_ctx, module, fw_list);
+		if (ret_val)
+			return ret_val;
+		module = (void *)module + sizeof(*module) + module->mod_size ;
+	}
+
+	return 0;
+}
+
+static void sst_dma_free_resources(struct sst_dma *dma)
+{
+	pr_debug("entry:%s\n", __func__);
+
+	dma_release_channel(dma->ch);
+}
+
+void sst_fill_config(struct intel_sst_drv *sst_ctx, unsigned int offset)
+{
+	struct sst_fill_config sst_config;
+
+	 if (!(sst_ctx->pdata->bdata && sst_ctx->pdata->pdata))
+		return;
+
+	sst_config.sign = SST_CONFIG_SSP_SIGN;
+	memcpy(&sst_config.sst_bdata, sst_ctx->pdata->bdata, sizeof(struct sst_board_config_data));
+	memcpy(&sst_config.sst_pdata, sst_ctx->pdata->pdata, sizeof(struct sst_platform_config_data));
+	sst_config.shim_phy_add = sst_ctx->shim_phy_add;
+	sst_config.mailbox_add = sst_ctx->mailbox_add;
+	MEMCPY_TOIO(sst_ctx->dram + offset, &sst_config, sizeof(sst_config));
+
+}
+
+/**
+ * sst_do_dma - function allocs and initiates the DMA
+ *
+ * @sg_list: Pointer to dma list on which the dma needs to be initiated
+ *
+ * Triggers the DMA
+ */
+static int sst_do_dma(struct sst_sg_list *sg_list)
+{
+	int ret_val;
+
+	/* get a dmac channel */
+	ret_val = sst_alloc_dma_chan(&sst_drv_ctx->dma);
+	if (ret_val)
+		return ret_val;
+
+	/* allocate desc for transfer and submit */
+	ret_val = sst_dma_firmware(&sst_drv_ctx->dma, sg_list);
+
+	sst_dma_free_resources(&sst_drv_ctx->dma);
+
+	return ret_val;
+}
+
+/*
+ * sst_fill_memcpy_list - Fill the memcpy list
+ *
+ * @memcpy_list: List to be filled
+ * @destn: Destination addr to be filled in the list
+ * @src: Source addr to be filled in the list
+ * @size: Size to be filled in the list
+ *
+ * Adds the node to the list after required fields
+ * are populated in the node
+ */
+
+static int sst_fill_memcpy_list(struct list_head *memcpy_list,
+			void *destn, const void *src, u32 size, bool is_io)
+{
+	struct sst_memcpy_list *listnode;
+
+	listnode = kzalloc(sizeof(*listnode), GFP_KERNEL);
+	if (listnode == NULL)
+		return -ENOMEM;
+	listnode->dstn = destn;
+	listnode->src = src;
+	listnode->size = size;
+	listnode->is_io = is_io;
+	list_add_tail(&listnode->memcpylist, memcpy_list);
+
+	return 0;
+}
+
+static int sst_parse_elf_module_memcpy(struct intel_sst_drv *sst,
+		const void *fw, struct sst_info info, Elf32_Phdr *pr,
+		struct list_head *memcpy_list)
+{
+	void *dstn;
+	unsigned int dstn_phys;
+	int ret_val = 0;
+	int mem_type;
+
+	ret_val = sst_fill_dstn(sst, info, pr, &dstn, &dstn_phys, &mem_type);
+	if (ret_val)
+		return ret_val;
+
+	ret_val = sst_fill_memcpy_list(memcpy_list, dstn,
+			(void *)fw + pr->p_offset, pr->p_filesz, mem_type);
+	if (ret_val)
+		return ret_val;
+
+	return 0;
+}
+
+static int
+sst_parse_elf_fw_memcpy(struct intel_sst_drv *sst, const void *fw_in_mem,
+			struct list_head *memcpy_list)
+{
+	int i = 0;
+
+	Elf32_Ehdr *elf;
+	Elf32_Phdr *pr;
+	struct sst_info info;
+
+	BUG_ON(!fw_in_mem);
+
+	elf = (Elf32_Ehdr *)fw_in_mem;
+	pr = (Elf32_Phdr *) (fw_in_mem + elf->e_phoff);
+	pr_debug("%s entry\n", __func__);
+
+	sst_fill_info(sst, &info);
+
+	while (i < elf->e_phnum) {
+		if (pr[i].p_type == PT_LOAD)
+			sst_parse_elf_module_memcpy(sst, fw_in_mem, info,
+					&pr[i], memcpy_list);
+		i++;
+	}
+	return 0;
+}
+
+/**
+ * sst_parse_module_memcpy - Parse audio FW modules and populate the memcpy list
+ *
+ * @module		: FW module header
+ * @memcpy_list	: Pointer to the list to be populated
+ * Create the memcpy list as the number of block to be copied
+ * returns error or 0 if module sizes are proper
+ */
+static int sst_parse_module_memcpy(struct fw_module_header *module,
+				struct list_head *memcpy_list)
+{
+	struct fw_block_info *block;
+	u32 count;
+	int ret_val = 0;
+	void __iomem *ram_iomem;
+
+	pr_debug("module sign %s size %x blocks %x type %x\n",
+			module->signature, module->mod_size,
+			module->blocks, module->type);
+	pr_debug("module entrypoint 0x%x\n", module->entry_point);
+
+	block = (void *)module + sizeof(*module);
+
+	for (count = 0; count < module->blocks; count++) {
+		if (block->size <= 0) {
+			pr_err("block size invalid\n");
+			return -EINVAL;
+		}
+		switch (block->type) {
+		case SST_IRAM:
+			ram_iomem = sst_drv_ctx->iram;
+			break;
+		case SST_DRAM:
+			ram_iomem = sst_drv_ctx->dram;
+			break;
+		case SST_DDR:
+			ram_iomem = sst_drv_ctx->ddr;
+			break;
+		case SST_CUSTOM_INFO:
+			block = (void *)block + sizeof(*block) + block->size;
+			continue;
+		default:
+			pr_err("wrong ram type0x%x in block0x%x\n",
+					block->type, count);
+			return -EINVAL;
+		}
+
+		ret_val = sst_fill_memcpy_list(memcpy_list,
+				ram_iomem + block->ram_offset,
+				(void *)block + sizeof(*block), block->size, 1);
+		if (ret_val)
+			return ret_val;
+
+		block = (void *)block + sizeof(*block) + block->size;
+	}
+	return 0;
+}
+
+/**
+ * sst_parse_fw_memcpy - parse the firmware image & populate the list for memcpy
+ *
+ * @sst_fw_in_mem	: pointer to audio fw
+ * @size		: size of the firmware
+ * @fw_list		: pointer to list_head to be populated
+ * This function parses the FW image and saves the parsed image in the list
+ * for memcpy
+ */
+static int sst_parse_fw_memcpy(const void *sst_fw_in_mem, unsigned long size,
+				struct list_head *fw_list)
+{
+	struct fw_module_header *module;
+	u32 count, num_modules;
+	int ret_val;
+
+	ret_val = sst_validate_fw_image(sst_fw_in_mem, size,
+				&module, &num_modules);
+	if (ret_val)
+		return ret_val;
+
+	for (count = 0; count < num_modules; count++) {
+		/* module */
+		ret_val = sst_parse_module_memcpy(module, fw_list);
+		if (ret_val)
+			return ret_val;
+		module = (void *)module + sizeof(*module) + module->mod_size ;
+	}
+
+	return 0;
+}
+
+/**
+ * sst_do_memcpy - function initiates the memcpy
+ *
+ * @memcpy_list: Pter to memcpy list on which the memcpy needs to be initiated
+ *
+ * Triggers the memcpy
+ */
+static void sst_do_memcpy(struct list_head *memcpy_list)
+{
+	struct sst_memcpy_list *listnode;
+
+	list_for_each_entry(listnode, memcpy_list, memcpylist) {
+		if (listnode->is_io == true)
+			MEMCPY_TOIO((void __iomem *)listnode->dstn, listnode->src,
+							listnode->size);
+		else
+			memcpy(listnode->dstn, listnode->src, listnode->size);
+	}
+}
+
+static void sst_memcpy_free_lib_resources(void)
+{
+	struct sst_memcpy_list *listnode, *tmplistnode;
+
+	pr_debug("entry:%s\n", __func__);
+
+	/*Free the list*/
+	if (!list_empty(&sst_drv_ctx->libmemcpy_list)) {
+		list_for_each_entry_safe(listnode, tmplistnode,
+				&sst_drv_ctx->libmemcpy_list, memcpylist) {
+			list_del(&listnode->memcpylist);
+			kfree(listnode);
+		}
+	}
+}
+
+void sst_memcpy_free_resources(void)
+{
+	struct sst_memcpy_list *listnode, *tmplistnode;
+
+	pr_debug("entry:%s\n", __func__);
+
+	/*Free the list*/
+	if (!list_empty(&sst_drv_ctx->memcpy_list)) {
+		list_for_each_entry_safe(listnode, tmplistnode,
+				&sst_drv_ctx->memcpy_list, memcpylist) {
+			list_del(&listnode->memcpylist);
+			kfree(listnode);
+		}
+	}
+	sst_memcpy_free_lib_resources();
+}
+
+void sst_firmware_load_cb(const struct firmware *fw, void *context)
+{
+	struct intel_sst_drv *ctx = context;
+	int ret = 0;
+
+	pr_debug("In %s\n", __func__);
+
+	if (fw == NULL) {
+		pr_err("request fw failed\n");
+		return;
+	}
+
+	mutex_lock(&sst_drv_ctx->sst_lock);
+
+	if (sst_drv_ctx->sst_state != SST_RESET ||
+			ctx->fw_in_mem != NULL)
+		goto out;
+
+	pr_debug("Request Fw completed\n");
+	trace_sst_fw_download("End of FW request", ctx->sst_state);
+
+	if (ctx->info.use_elf == true)
+		ret = sst_validate_elf(fw, false);
+
+	if (ret != 0) {
+		pr_err("FW image invalid...\n");
+		goto out;
+	}
+
+	ctx->fw_in_mem = kzalloc(fw->size, GFP_KERNEL);
+	if (!ctx->fw_in_mem) {
+		pr_err("%s unable to allocate memory\n", __func__);
+		goto out;
+	}
+
+	pr_debug("copied fw to %p", ctx->fw_in_mem);
+	pr_debug("phys: %lx", (unsigned long)virt_to_phys(ctx->fw_in_mem));
+	memcpy(ctx->fw_in_mem, fw->data, fw->size);
+
+	trace_sst_fw_download("Start FW parsing", ctx->sst_state);
+	if (ctx->use_dma) {
+		if (ctx->info.use_elf == true)
+			ret = sst_parse_elf_fw_dma(ctx, ctx->fw_in_mem,
+							&ctx->fw_sg_list);
+		else
+			ret = sst_parse_fw_dma(ctx->fw_in_mem, fw->size,
+							&ctx->fw_sg_list);
+	} else {
+		if (ctx->info.use_elf == true)
+			ret = sst_parse_elf_fw_memcpy(ctx, ctx->fw_in_mem,
+							&ctx->memcpy_list);
+		else
+			ret = sst_parse_fw_memcpy(ctx->fw_in_mem, fw->size,
+							&ctx->memcpy_list);
+	}
+	trace_sst_fw_download("End FW parsing", ctx->sst_state);
+	if (ret) {
+		kfree(ctx->fw_in_mem);
+		ctx->fw_in_mem = NULL;
+		goto out;
+	}
+	/* If static module download(download at boot time) is supported,
+	 * set the flag to indicate lib download is to be done
+	 */
+	if (ctx->pdata->lib_info)
+		if (ctx->pdata->lib_info->mod_ddr_dnld)
+			ctx->lib_dwnld_reqd = true;
+
+out:
+	mutex_unlock(&sst_drv_ctx->sst_lock);
+	if (fw != NULL)
+		release_firmware(fw);
+}
+
+/*
+ * sst_request_fw - requests audio fw from kernel and saves a copy
+ *
+ * This function requests the SST FW from the kernel, parses it and
+ * saves a copy in the driver context
+ */
+static int sst_request_fw(struct intel_sst_drv *sst)
+{
+	int retval = 0;
+	char name[20];
+	const struct firmware *fw;
+
+	snprintf(name, sizeof(name), "%s%04x%s", "fw_sst_",
+				sst->pci_id, ".bin");
+	pr_debug("Requesting FW %s now...\n", name);
+
+	retval = request_firmware(&fw, name, sst->dev);
+	if (fw == NULL) {
+		pr_err("fw is returning as null\n");
+		return -EINVAL;
+	}
+	if (retval) {
+		pr_err("request fw failed %d\n", retval);
+		return retval;
+	}
+	trace_sst_fw_download("End of FW request", sst->sst_state);
+	if (sst->info.use_elf == true)
+		retval = sst_validate_elf(fw, false);
+	if (retval != 0) {
+		pr_err("FW image invalid...\n");
+		goto end_release;
+	}
+	sst->fw_in_mem = kzalloc(fw->size, GFP_KERNEL);
+	if (!sst->fw_in_mem) {
+		pr_err("%s unable to allocate memory\n", __func__);
+		retval = -ENOMEM;
+		goto end_release;
+	}
+	pr_debug("copied fw to %p", sst->fw_in_mem);
+	pr_debug("phys: %lx", (unsigned long)virt_to_phys(sst->fw_in_mem));
+	memcpy(sst->fw_in_mem, fw->data, fw->size);
+	trace_sst_fw_download("Start FW parsing", sst->sst_state);
+	if (sst->use_dma) {
+		if (sst->info.use_elf == true)
+			retval = sst_parse_elf_fw_dma(sst, sst->fw_in_mem,
+							&sst->fw_sg_list);
+		else
+			retval = sst_parse_fw_dma(sst->fw_in_mem, fw->size,
+							&sst->fw_sg_list);
+	} else {
+		if (sst->info.use_elf == true)
+			retval = sst_parse_elf_fw_memcpy(sst, sst->fw_in_mem,
+							&sst->memcpy_list);
+		else
+			retval = sst_parse_fw_memcpy(sst->fw_in_mem, fw->size,
+							&sst->memcpy_list);
+	}
+	trace_sst_fw_download("End FW parsing", sst->sst_state);
+	if (retval) {
+		kfree(sst->fw_in_mem);
+		sst->fw_in_mem = NULL;
+	}
+
+	/* If static module download(download at boot time) is supported,
+	 * set the flag to indicate lib download is to be done
+	 */
+	if (sst->pdata->lib_info)
+		if (sst->pdata->lib_info->mod_ddr_dnld)
+			sst->lib_dwnld_reqd = true;
+end_release:
+	release_firmware(fw);
+	return retval;
+}
+
+static inline void print_lib_info(struct snd_sst_lib_download_info *resp)
+{
+	pr_debug("codec Type %d Ver %d Built %s: %s\n",
+		resp->dload_lib.lib_info.lib_type,
+		resp->dload_lib.lib_info.lib_version,
+		resp->dload_lib.lib_info.b_date,
+		resp->dload_lib.lib_info.b_time);
+}
+
+/* sst_download_library - This function is called when any
+ codec/post processing library needs to be downloaded */
+static int sst_download_library(const struct firmware *fw_lib,
+				struct snd_sst_lib_download_info *lib)
+{
+	int ret_val = 0;
+
+	/* send IPC message and wait */
+	u8 pvt_id;
+	struct ipc_post *msg = NULL;
+	union config_status_reg csr;
+	struct snd_sst_str_type str_type = {0};
+	int retval = 0;
+	void *codec_fw;
+	struct sst_block *block;
+
+	pvt_id = sst_assign_pvt_id(sst_drv_ctx);
+	ret_val = sst_create_block_and_ipc_msg(&msg, true, sst_drv_ctx, &block,
+				IPC_IA_PREP_LIB_DNLD, pvt_id);
+	if (ret_val) {
+		pr_err("library download failed\n");
+		return ret_val;
+	}
+
+	sst_fill_header(&msg->header, IPC_IA_PREP_LIB_DNLD, 1, pvt_id);
+	msg->header.part.data = sizeof(u32) + sizeof(str_type);
+	str_type.codec_type = lib->dload_lib.lib_info.lib_type;
+	/*str_type.pvt_id = pvt_id;*/
+	memcpy(msg->mailbox_data, &msg->header, sizeof(u32));
+	memcpy(msg->mailbox_data + sizeof(u32), &str_type, sizeof(str_type));
+	sst_add_to_dispatch_list_and_post(sst_drv_ctx, msg);
+	retval = sst_wait_timeout(sst_drv_ctx, block);
+	if (block->data) {
+		struct snd_sst_str_type *str_type =
+			(struct snd_sst_str_type *)block->data;
+		if (str_type->result) {
+			/* error */
+			pr_err("Prep codec downloaded failed %d\n",
+					str_type->result);
+			retval = -EIO;
+			goto free_block;
+		}
+		kfree(block->data);
+	} else if (retval != 0) {
+		retval = -EIO;
+		goto free_block;
+	}
+	pr_debug("FW responded, ready for download now...\n");
+	codec_fw = kzalloc(fw_lib->size, GFP_KERNEL);
+	if (!codec_fw) {
+		memset(lib, 0, sizeof(*lib));
+		retval = -ENOMEM;
+		goto send_ipc;
+	}
+	memcpy(codec_fw, fw_lib->data, fw_lib->size);
+
+	if (sst_drv_ctx->use_dma)
+		retval = sst_parse_fw_dma(codec_fw, fw_lib->size,
+				 &sst_drv_ctx->library_list);
+	else
+		retval = sst_parse_fw_memcpy(codec_fw, fw_lib->size,
+				 &sst_drv_ctx->libmemcpy_list);
+
+	if (retval) {
+		memset(lib, 0, sizeof(*lib));
+		goto send_ipc;
+	}
+
+	/* downloading on success */
+	mutex_lock(&sst_drv_ctx->sst_lock);
+	mutex_lock(&sst_drv_ctx->csr_lock);
+
+	sst_drv_ctx->sst_state = SST_FW_LOADING;
+	csr.full = readl(sst_drv_ctx->shim + SST_CSR);
+	csr.part.run_stall = 1;
+	sst_shim_write(sst_drv_ctx->shim, SST_CSR, csr.full);
+
+	csr.full = sst_shim_read(sst_drv_ctx->shim, SST_CSR);
+	csr.part.bypass = 0x7;
+	sst_shim_write(sst_drv_ctx->shim, SST_CSR, csr.full);
+	mutex_unlock(&sst_drv_ctx->csr_lock);
+
+	if (sst_drv_ctx->use_dma) {
+		ret_val = sst_do_dma(&sst_drv_ctx->library_list);
+		if (ret_val) {
+			pr_err("sst_do_dma failed, abort\n");
+			memset(lib, 0, sizeof(*lib));
+		}
+	} else
+		sst_do_memcpy(&sst_drv_ctx->libmemcpy_list);
+	/* set the FW to running again */
+	mutex_lock(&sst_drv_ctx->csr_lock);
+	csr.full = sst_shim_read(sst_drv_ctx->shim, SST_CSR);
+	csr.part.bypass = 0x0;
+	sst_shim_write(sst_drv_ctx->shim, SST_CSR, csr.full);
+
+	csr.full = sst_shim_read(sst_drv_ctx->shim, SST_CSR);
+	csr.part.run_stall = 0;
+	sst_shim_write(sst_drv_ctx->shim, SST_CSR, csr.full);
+	mutex_unlock(&sst_drv_ctx->csr_lock);
+send_ipc:
+	/* send download complete and wait */
+	if (sst_create_ipc_msg(&msg, true)) {
+		retval = -ENOMEM;
+		goto free_resources;
+	}
+
+	block->condition = false;
+	block->msg_id = IPC_IA_LIB_DNLD_CMPLT;
+	sst_fill_header(&msg->header, IPC_IA_LIB_DNLD_CMPLT, 1, pvt_id);
+	msg->header.part.data = sizeof(u32) + sizeof(*lib);
+	lib->pvt_id = pvt_id;
+	memcpy(msg->mailbox_data, &msg->header, sizeof(u32));
+	memcpy(msg->mailbox_data + sizeof(u32), lib, sizeof(*lib));
+	sst_add_to_dispatch_list_and_post(sst_drv_ctx, msg);
+	pr_debug("Waiting for FW response Download complete\n");
+	retval = sst_wait_timeout(sst_drv_ctx, block);
+	sst_drv_ctx->sst_state = SST_FW_RUNNING;
+	if (block->data) {
+		struct snd_sst_lib_download_info *resp = block->data;
+		retval = resp->result;
+		if (retval) {
+			pr_err("err in lib dload %x\n", resp->result);
+			goto free_resources;
+		} else {
+			pr_debug("Codec download complete...\n");
+			print_lib_info(resp);
+		}
+	} else if (retval) {
+		/* error */
+		retval = -EIO;
+		goto free_resources;
+	}
+
+	pr_debug("FW success on Download complete\n");
+
+free_resources:
+	if (sst_drv_ctx->use_dma) {
+		kfree(sst_drv_ctx->library_list.src);
+		kfree(sst_drv_ctx->library_list.dst);
+		sst_drv_ctx->library_list.list_len = 0;
+	}
+
+	kfree(codec_fw);
+	mutex_unlock(&sst_drv_ctx->sst_lock);
+free_block:
+	sst_free_block(sst_drv_ctx, block);
+	return retval;
+}
+
+/*
+ * Writing the DDR physical base to DCCM offset
+ * so that FW can use it to setup TLB
+ */
+static void sst_dccm_config_write(void __iomem *dram_base, unsigned int ddr_base)
+{
+	void __iomem *addr;
+	u32 bss_reset = 0;
+
+	addr = (void __iomem *)(dram_base + MRFLD_FW_DDR_BASE_OFFSET);
+	MEMCPY_TOIO(addr, (void *)&ddr_base, sizeof(u32));
+	bss_reset |= (1 << MRFLD_FW_BSS_RESET_BIT);
+	addr = (void __iomem *)(dram_base + MRFLD_FW_FEATURE_BASE_OFFSET);
+	MEMCPY_TOIO(addr, &bss_reset, sizeof(u32));
+	pr_debug("%s: config written to DCCM\n", __func__);
+}
+
+void sst_post_download_mrfld(struct intel_sst_drv *ctx)
+{
+	sst_dccm_config_write(ctx->dram, ctx->ddr_base);
+	/* For mrfld, download all libraries the first time fw is
+	 * downloaded */
+	pr_debug("%s: lib_dwnld = %u\n", __func__, ctx->lib_dwnld_reqd);
+	if (ctx->lib_dwnld_reqd) {
+		sst_load_all_modules_elf(ctx, sst_modules_mrfld, ARRAY_SIZE(sst_modules_mrfld));
+		ctx->lib_dwnld_reqd = false;
+	}
+}
+
+void sst_post_download_ctp(struct intel_sst_drv *ctx)
+{
+	sst_fill_config(ctx, 0);
+}
+
+void sst_post_download_byt(struct intel_sst_drv *ctx)
+{
+	sst_dccm_config_write(ctx->dram, ctx->ddr_base);
+	sst_fill_config(ctx, 2 * sizeof(u32));
+
+	pr_debug("%s: lib_dwnld = %u\n", __func__, ctx->lib_dwnld_reqd);
+	if (ctx->lib_dwnld_reqd) {
+		sst_load_all_modules_elf(ctx, sst_modules_byt,
+					ARRAY_SIZE(sst_modules_byt));
+		ctx->lib_dwnld_reqd = false;
+	}
+}
+
+static void sst_init_lib_mem_mgr(struct intel_sst_drv *ctx)
+{
+	struct sst_mem_mgr *mgr = &ctx->lib_mem_mgr;
+	const struct sst_lib_dnld_info *lib_info = ctx->pdata->lib_info;
+
+	memset(mgr, 0, sizeof(*mgr));
+	mgr->current_base = lib_info->mod_base + lib_info->mod_table_offset
+						+ lib_info->mod_table_size;
+	mgr->avail = lib_info->mod_end - mgr->current_base + 1;
+
+	pr_debug("current base = 0x%lx , avail = 0x%x\n",
+		(unsigned long)mgr->current_base, mgr->avail);
+}
+
+/**
+ * sst_load_fw - function to load FW into DSP
+ *
+ *
+ * Transfers the FW to DSP using dma/memcpy
+ */
+int sst_load_fw(void)
+{
+	int ret_val = 0;
+	struct sst_block *block;
+
+	pr_debug("sst_load_fw\n");
+
+	if (sst_drv_ctx->sst_state !=  SST_RESET ||
+			sst_drv_ctx->sst_state == SST_SHUTDOWN)
+		return -EAGAIN;
+
+	if (!sst_drv_ctx->fw_in_mem) {
+		trace_sst_fw_download("Req FW sent in check device",
+					sst_drv_ctx->sst_state);
+		pr_debug("sst: FW not in memory retry to download\n");
+		ret_val = sst_request_fw(sst_drv_ctx);
+		if (ret_val)
+			return ret_val;
+	}
+
+	BUG_ON(!sst_drv_ctx->fw_in_mem);
+	block = sst_create_block(sst_drv_ctx, 0, FW_DWNL_ID);
+	if (block == NULL)
+		return -ENOMEM;
+
+	/* Prevent C-states beyond C6 */
+	pm_qos_update_request(sst_drv_ctx->qos, CSTATE_EXIT_LATENCY_S0i1 - 1);
+
+	sst_drv_ctx->sst_state = SST_FW_LOADING;
+
+	ret_val = sst_drv_ctx->ops->reset();
+	if (ret_val)
+		goto restore;
+
+	trace_sst_fw_download("Start FW copy", sst_drv_ctx->sst_state);
+	if (sst_drv_ctx->use_dma) {
+		ret_val = sst_do_dma(&sst_drv_ctx->fw_sg_list);
+		if (ret_val) {
+			pr_err("sst_do_dma failed, abort\n");
+			goto restore;
+		}
+	} else {
+		sst_do_memcpy(&sst_drv_ctx->memcpy_list);
+	}
+
+	trace_sst_fw_download("Post download for Lib start",
+			sst_drv_ctx->sst_state);
+	/* Write the DRAM/DCCM config before enabling FW */
+	if (sst_drv_ctx->ops->post_download)
+		sst_drv_ctx->ops->post_download(sst_drv_ctx);
+	trace_sst_fw_download("Post download for Lib end",
+			sst_drv_ctx->sst_state);
+
+	/* bring sst out of reset */
+	ret_val = sst_drv_ctx->ops->start();
+	if (ret_val)
+		goto restore;
+	trace_sst_fw_download("DSP reset done",
+			sst_drv_ctx->sst_state);
+
+	ret_val = sst_wait_timeout(sst_drv_ctx, block);
+	if (ret_val) {
+		pr_err("fw download failed %d\n" , ret_val);
+		/* assume FW d/l failed due to timeout*/
+		ret_val = -EBUSY;
+
+	}
+
+restore:
+	/* Re-enable Deeper C-states beyond C6 */
+	pm_qos_update_request(sst_drv_ctx->qos, PM_QOS_DEFAULT_VALUE);
+	sst_free_block(sst_drv_ctx, block);
+
+	return ret_val;
+}
+
+/**
+ * sst_load_library - function to load FW into DSP
+ *
+ * @lib: Pointer to the lib download structure
+ * @ops: Contains the stream ops
+ * This function is called when FW requests for a particular library download
+ * This function prepares & downloads the library
+ */
+int sst_load_library(struct snd_sst_lib_download *lib, u8 ops)
+{
+	char buf[20];
+	const char *type, *dir;
+	int len = 0, error = 0;
+	u32 entry_point;
+	const struct firmware *fw_lib;
+	struct snd_sst_lib_download_info dload_info = {{{0},},};
+
+	memset(buf, 0, sizeof(buf));
+
+	pr_debug("Lib Type 0x%x, Slot 0x%x, ops 0x%x\n",
+			lib->lib_info.lib_type, lib->slot_info.slot_num, ops);
+	pr_debug("Version 0x%x, name %s, caps 0x%x media type 0x%x\n",
+		lib->lib_info.lib_version, lib->lib_info.lib_name,
+		lib->lib_info.lib_caps, lib->lib_info.media_type);
+
+	pr_debug("IRAM Size 0x%x, offset 0x%x\n",
+		lib->slot_info.iram_size, lib->slot_info.iram_offset);
+	pr_debug("DRAM Size 0x%x, offset 0x%x\n",
+		lib->slot_info.dram_size, lib->slot_info.dram_offset);
+
+	switch (lib->lib_info.lib_type) {
+	case SST_CODEC_TYPE_MP3:
+		type = "mp3_";
+		break;
+	case SST_CODEC_TYPE_AAC:
+		type = "aac_";
+		break;
+	case SST_CODEC_TYPE_AACP:
+		type = "aac_v1_";
+		break;
+	case SST_CODEC_TYPE_eAACP:
+		type = "aac_v2_";
+		break;
+	case SST_CODEC_TYPE_WMA9:
+		type = "wma9_";
+		break;
+	default:
+		pr_err("Invalid codec type\n");
+		error = -EINVAL;
+		goto wake;
+	}
+
+	if (ops == STREAM_OPS_CAPTURE)
+		dir = "enc_";
+	else
+		dir = "dec_";
+	len = strlen(type) + strlen(dir);
+	strncpy(buf, type, sizeof(buf)-1);
+	strncpy(buf + strlen(type), dir, sizeof(buf)-strlen(type)-1);
+	len += snprintf(buf + len, sizeof(buf) - len, "%d",
+			lib->slot_info.slot_num);
+	len += snprintf(buf + len, sizeof(buf) - len, ".bin");
+
+	pr_debug("Requesting %s\n", buf);
+
+	error = request_firmware(&fw_lib, buf, sst_drv_ctx->dev);
+	if (fw_lib == NULL) {
+		pr_err("fw_lib pointer is returning null\n");
+		return -EINVAL;
+	}
+	if (error) {
+		pr_err("library load failed %d\n", error);
+		goto wake;
+	}
+	error = sst_validate_library(fw_lib, &lib->slot_info, &entry_point);
+	if (error)
+		goto wake_free;
+
+	lib->mod_entry_pt = entry_point;
+	memcpy(&dload_info.dload_lib, lib, sizeof(*lib));
+	/* Prevent C-states beyond C6 */
+	pm_qos_update_request(sst_drv_ctx->qos, CSTATE_EXIT_LATENCY_S0i1 - 1);
+	error = sst_download_library(fw_lib, &dload_info);
+	/* Re-enable Deeper C-states beyond C6 */
+	pm_qos_update_request(sst_drv_ctx->qos, PM_QOS_DEFAULT_VALUE);
+	if (error)
+		goto wake_free;
+
+	/* lib is downloaded and init send alloc again */
+	pr_debug("Library is downloaded now...\n");
+wake_free:
+	/* sst_wake_up_alloc_block(sst_drv_ctx, pvt_id, error, NULL); */
+	release_firmware(fw_lib);
+wake:
+	return error;
+}
+
+/* In relocatable elf file, there can be  relocatable variables and functions.
+ * Variables are kept in Global Address Offset Table (GOT) and functions in
+ * Procedural Linkage Table (PLT). In current codec binaries only relocatable
+ * variables are seen. So we use the GOT table.
+ */
+static int sst_find_got_table(Elf32_Shdr *shdr, int nsec, char *in_elf,
+		Elf32_Rela **got, unsigned int *cnt)
+{
+	int i = 0;
+	while (i < nsec) {
+		if (shdr[i].sh_type == SHT_RELA) {
+			*got = (Elf32_Rela *)(in_elf + shdr[i].sh_offset);
+			*cnt = shdr[i].sh_size / sizeof(Elf32_Rela);
+			break;
+		}
+		i++;
+	}
+	if (i == nsec)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* For each entry in the GOT table, find the unrelocated offset. Then
+ * add the relocation base to the offset and write back the new address to the
+ * original variable location.
+ */
+static int sst_relocate_got_entries(Elf32_Rela *table, unsigned int size,
+	char *in_elf, int elf_size, u32 rel_base)
+{
+	int i;
+	Elf32_Rela *entry;
+	Elf32_Addr *target_addr, unreloc_addr;
+
+	for (i = 0; i < size; i++) {
+		entry = &table[i];
+		if (ELF32_R_SYM(entry->r_info) != 0) {
+			return -EINVAL;
+		} else {
+			if (entry->r_offset > elf_size) {
+				pr_err("GOT table target addr out of range\n");
+				return -EINVAL;
+			}
+			target_addr = (Elf32_Addr *)(in_elf + entry->r_offset);
+			unreloc_addr = *target_addr + entry->r_addend;
+			if (unreloc_addr > elf_size) {
+				pr_err("GOT table entry invalid\n");
+				continue;
+			}
+			*target_addr = unreloc_addr + rel_base;
+		}
+	}
+	return 0;
+}
+
+static int sst_relocate_elf(char *in_elf, int elf_size, phys_addr_t rel_base,
+		Elf32_Addr *entry_pt)
+{
+	int retval = 0;
+	Elf32_Ehdr *ehdr = (Elf32_Ehdr *)in_elf;
+	Elf32_Shdr *shdr = (Elf32_Shdr *) (in_elf + ehdr->e_shoff);
+	Elf32_Phdr *phdr = (Elf32_Phdr *) (in_elf + ehdr->e_phoff);
+	int i, num_sec;
+	Elf32_Rela *rel_table = NULL;
+	unsigned int rela_cnt = 0;
+	u32 rbase;
+
+	BUG_ON(rel_base > (u32)(-1));
+	rbase = (u32) (rel_base & (u32)(~0));
+
+	/* relocate the entry_pt */
+	*entry_pt = (Elf32_Addr)(ehdr->e_entry + rbase);
+	num_sec = ehdr->e_shnum;
+
+	/* Find the relocation(GOT) table through the section header */
+	retval = sst_find_got_table(shdr, num_sec, in_elf,
+					&rel_table, &rela_cnt);
+	if (retval < 0)
+		return retval;
+
+	/* Relocate all the entries in the GOT */
+	retval = sst_relocate_got_entries(rel_table, rela_cnt, in_elf,
+						elf_size, rbase);
+	if (retval < 0)
+		return retval;
+
+	pr_debug("GOT entries relocated\n");
+
+	/* Update the program headers in the ELF */
+	for (i = 0; i < ehdr->e_phnum; i++) {
+		if (phdr[i].p_type == PT_LOAD) {
+			phdr[i].p_vaddr += rbase;
+			phdr[i].p_paddr += rbase;
+		}
+	}
+	pr_debug("program header entries updated\n");
+
+	return retval;
+}
+
+#define ALIGN_256 0x100
+
+int sst_get_next_lib_mem(struct sst_mem_mgr *mgr, int size,
+			unsigned long *lib_base)
+{
+	int retval = 0;
+
+	pr_debug("library orig size = 0x%x", size);
+	if (size % ALIGN_256)
+		size += (ALIGN_256 - (size % ALIGN_256));
+	if (size > mgr->avail)
+		return -ENOMEM;
+
+	*lib_base = mgr->current_base;
+	mgr->current_base += size;
+	mgr->avail -= size;
+	mgr->count++;
+	pr_debug("library base = 0x%lx", *lib_base);
+	pr_debug("library aligned size = 0x%x", size);
+	pr_debug("lib count = %d\n", mgr->count);
+	return retval;
+
+}
+
+static int sst_download_lib_elf(struct intel_sst_drv *sst, const void *lib,
+		int size)
+{
+	int retval = 0;
+
+	pr_debug("In %s\n", __func__);
+
+	if (sst->use_dma) {
+		retval = sst_parse_elf_fw_dma(sst, lib,
+				 &sst->library_list);
+		if (retval)
+			goto free_dma_res;
+		retval = sst_do_dma(&sst->library_list);
+		if (retval)
+			pr_err("sst_do_dma failed, abort\n");
+free_dma_res:
+		kfree(sst->library_list.src);
+		kfree(sst->library_list.dst);
+		sst->library_list.list_len = 0;
+	} else {
+		retval = sst_parse_elf_fw_memcpy(sst, lib,
+				 &sst->libmemcpy_list);
+		if (retval)
+			return retval;
+		sst_do_memcpy(&sst->libmemcpy_list);
+		sst_memcpy_free_lib_resources();
+	}
+	pr_debug("download lib complete");
+	return retval;
+}
+
+static void sst_fill_fw_module_table(struct sst_module_info *mod_list,
+		int list_size, unsigned long ddr_base)
+{
+	int i;
+	u32 *write_ptr = (u32 *)ddr_base;
+
+	pr_debug("In %s\n", __func__);
+
+	for (i = 0; i < list_size; i++) {
+		if (mod_list[i].status == SST_LIB_DOWNLOADED) {
+			pr_debug("status dnwld for %d\n", i);
+			pr_debug("module id %d\n", mod_list[i].id);
+			pr_debug("entry pt 0x%x\n", mod_list[i].entry_pt);
+
+			*write_ptr++ = mod_list[i].id;
+			*write_ptr++ = mod_list[i].entry_pt;
+		}
+	}
+}
+
+static int sst_request_lib_elf(struct sst_module_info *mod_entry,
+	const struct firmware **fw_lib, int pci_id, struct device *dev)
+{
+	char name[25];
+	int retval = 0;
+
+	snprintf(name, sizeof(name), "%s%s%04x%s", mod_entry->name,
+			"_", pci_id, ".bin");
+	pr_debug("Requesting %s\n", name);
+
+	retval = request_firmware(fw_lib, name, dev);
+	if (retval) {
+		pr_err("%s library load failed %d\n", name, retval);
+		return retval;
+	}
+	pr_debug("got lib\n");
+	mod_entry->status = SST_LIB_FOUND;
+	return 0;
+}
+
+static int sst_allocate_lib_mem(const struct firmware *lib, int size,
+	struct sst_mem_mgr *mem_mgr, char **out_elf, unsigned long *lib_start)
+{
+	int retval = 0;
+
+	*out_elf = kzalloc(size, GFP_KERNEL);
+	if (!*out_elf) {
+		pr_err("cannot alloc mem for elf copy %d\n", retval);
+		goto mem_error;
+	}
+
+	memcpy(*out_elf, lib->data, size);
+	retval = sst_get_next_lib_mem(mem_mgr, size, lib_start);
+	if (retval < 0) {
+		pr_err("cannot alloc ddr mem for lib: %d\n", retval);
+		kfree(*out_elf);
+		goto mem_error;
+	}
+	return 0;
+
+mem_error:
+	release_firmware(lib);
+	return -ENOMEM;
+}
+
+int sst_load_all_modules_elf(struct intel_sst_drv *ctx, struct sst_module_info *mod_table,
+								int num_modules)
+{
+	int retval = 0;
+	int i;
+	const struct firmware *fw_lib;
+	struct sst_module_info *mod = NULL;
+	char *out_elf;
+	unsigned int lib_size = 0;
+	unsigned int mod_table_offset = ctx->pdata->lib_info->mod_table_offset;
+	unsigned long lib_base;
+
+	pr_debug("In %s", __func__);
+
+	sst_init_lib_mem_mgr(ctx);
+
+	for (i = 0; i < num_modules; i++) {
+		mod = &mod_table[i];
+		trace_sst_lib_download("Start of Request Lib", mod->name);
+		retval = sst_request_lib_elf(mod, &fw_lib,
+						ctx->pci_id, ctx->dev);
+		if (retval < 0)
+			continue;
+		lib_size = fw_lib->size;
+
+		trace_sst_lib_download("End of Request Lib", mod->name);
+		retval = sst_validate_elf(fw_lib, true);
+		if (retval < 0) {
+			pr_err("library is not valid elf %d\n", retval);
+			release_firmware(fw_lib);
+			continue;
+		}
+		pr_debug("elf validated\n");
+		retval = sst_allocate_lib_mem(fw_lib, lib_size,
+				&ctx->lib_mem_mgr, &out_elf, &lib_base);
+		if (retval < 0) {
+			pr_err("lib mem allocation failed: %d\n", retval);
+			continue;
+		}
+		pr_debug("lib space allocated\n");
+
+		/* relocate in place */
+		retval = sst_relocate_elf(out_elf, lib_size,
+						lib_base, &mod->entry_pt);
+		if (retval < 0) {
+			pr_err("lib elf relocation failed: %d\n", retval);
+			release_firmware(fw_lib);
+			kfree(out_elf);
+			continue;
+		}
+		pr_debug("relocation done\n");
+		release_firmware(fw_lib);
+		trace_sst_lib_download("Start of download Lib", mod->name);
+		/* write to ddr imr region,use memcpy method */
+		retval = sst_download_lib_elf(ctx, out_elf, lib_size);
+		trace_sst_lib_download("End of download Lib", mod->name);
+		mod->status = SST_LIB_DOWNLOADED;
+		kfree(out_elf);
+	}
+
+	/* write module table to DDR */
+	sst_fill_fw_module_table(mod_table, num_modules,
+			(unsigned long)(ctx->ddr + mod_table_offset));
+	return retval;
+}
diff --git a/sound/soc/intel/sst/sst_ipc.c b/sound/soc/intel/sst/sst_ipc.c
new file mode 100644
index 0000000..b005c53
--- /dev/null
+++ b/sound/soc/intel/sst/sst_ipc.c
@@ -0,0 +1,772 @@
+/*
+ *  sst_ipc.c - Intel SST Driver for audio engine
+ *
+ *  Copyright (C) 2008-10 Intel Corporation
+ *  Authors:	Vinod Koul <vinod.koul@intel.com>
+ *		Harsha Priya <priya.harsha@intel.com>
+ *		Dharageswari R <dharageswari.r@intel.com>
+ *		KP Jeeja <jeeja.kp@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This file defines all ipc functions
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/pci.h>
+#include <linux/firmware.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <sound/intel_sst_ioctl.h>
+#include "../sst_platform.h"
+#include "../platform_ipc_v2.h"
+#include "sst.h"
+#include "sst_trace.h"
+
+void sst_dump_to_buffer(const void *from, size_t len, char *buf)
+{
+	int i, end;
+	const unsigned char *cmd = from;
+
+	if (len == 0) {
+		buf[0] = '\0';
+		return;
+	}
+
+	for (end = len - 1; end >= 0; end--)
+		if (cmd[end])
+			break;
+	end++;
+
+	buf += snprintf(buf, 3, "%02x", cmd[0]);
+	for (i = 1; i < len; i++) {
+		buf += snprintf(buf, 4, " %02x", cmd[i]);
+		if (i == end && end != len - 1) {
+			sprintf(buf, "...");
+			break;
+		}
+	}
+}
+
+struct sst_block *sst_create_block(struct intel_sst_drv *ctx,
+					u32 msg_id, u32 drv_id)
+{
+	struct sst_block *msg = NULL;
+
+	pr_debug("in %s\n", __func__);
+	msg = kzalloc(sizeof(*msg), GFP_KERNEL);
+	if (!msg) {
+		pr_err("kzalloc block failed\n");
+		return NULL;
+	}
+	msg->condition = false;
+	msg->on = true;
+	msg->msg_id = msg_id;
+	msg->drv_id = drv_id;
+	spin_lock_bh(&ctx->block_lock);
+	list_add_tail(&msg->node, &ctx->block_list);
+	spin_unlock_bh(&ctx->block_lock);
+
+	return msg;
+}
+
+int sst_wake_up_block(struct intel_sst_drv *ctx, int result,
+		u32 drv_id, u32 ipc, void *data, u32 size)
+{
+	struct sst_block *block = NULL;
+
+	pr_debug("in %s\n", __func__);
+	spin_lock_bh(&ctx->block_lock);
+	list_for_each_entry(block, &ctx->block_list, node) {
+		pr_debug("Block ipc %d, drv_id %d\n", block->msg_id,
+							block->drv_id);
+		if (block->msg_id == ipc && block->drv_id == drv_id) {
+			pr_debug("free up the block\n");
+			block->ret_code = result;
+			block->data = data;
+			block->size = size;
+			block->condition = true;
+			spin_unlock_bh(&ctx->block_lock);
+			wake_up(&ctx->wait_queue);
+			return 0;
+		}
+	}
+	spin_unlock_bh(&ctx->block_lock);
+	pr_debug("Block not found or a response is received for a short message for ipc %d, drv_id %d\n",
+			ipc, drv_id);
+	return -EINVAL;
+}
+
+int sst_free_block(struct intel_sst_drv *ctx, struct sst_block *freed)
+{
+	struct sst_block *block = NULL, *__block;
+
+	pr_debug("in %s\n", __func__);
+	spin_lock_bh(&ctx->block_lock);
+	list_for_each_entry_safe(block, __block, &ctx->block_list, node) {
+		if (block == freed) {
+			list_del(&freed->node);
+			kfree(freed->data);
+			freed->data = NULL;
+			kfree(freed);
+			spin_unlock_bh(&ctx->block_lock);
+			return 0;
+		}
+	}
+	spin_unlock_bh(&ctx->block_lock);
+	return -EINVAL;
+}
+
+/*
+ * sst_send_runtime_param - send runtime param to SST
+ *
+ * this function sends the runtime parameter to sst dsp engine
+ */
+static int sst_send_runtime_param(struct snd_sst_runtime_params *params)
+{
+	struct ipc_post *msg = NULL;
+	int ret_val;
+
+	pr_debug("Enter:%s\n", __func__);
+	ret_val = sst_create_ipc_msg(&msg, true);
+	if (ret_val)
+		return ret_val;
+	sst_fill_header(&msg->header, IPC_IA_SET_RUNTIME_PARAMS, 1,
+							params->str_id);
+	msg->header.part.data = sizeof(u32) + sizeof(*params) - sizeof(params->addr)
+				+ params->size;
+	memcpy(msg->mailbox_data, &msg->header.full, sizeof(u32));
+	memcpy(msg->mailbox_data + sizeof(u32), params, sizeof(*params)
+				- sizeof(params->addr));
+	/* driver doesn't need to send address, so overwrite addr with data */
+	memcpy(msg->mailbox_data + sizeof(u32) + sizeof(*params)
+			- sizeof(params->addr),
+			params->addr, params->size);
+	sst_add_to_dispatch_list_and_post(sst_drv_ctx, msg);
+	return 0;
+}
+
+void sst_post_message_mrfld(struct work_struct *work)
+{
+	struct ipc_post *msg;
+	union ipc_header_mrfld header;
+	unsigned long irq_flags;
+
+	pr_debug("Enter:%s\n", __func__);
+	spin_lock_irqsave(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+	/* check list */
+	if (list_empty(&sst_drv_ctx->ipc_dispatch_list)) {
+		/* queue is empty, nothing to send */
+		spin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+		pr_debug("Empty msg queue... NO Action\n");
+		return;
+	}
+
+	/* check busy bit */
+	header.full = sst_shim_read64(sst_drv_ctx->shim, SST_IPCX);
+	if (header.p.header_high.part.busy) {
+		spin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+		pr_debug("Busy not free... post later\n");
+		return;
+	}
+	/* copy msg from list */
+	msg = list_entry(sst_drv_ctx->ipc_dispatch_list.next,
+			struct ipc_post, node);
+	list_del(&msg->node);
+	pr_debug("sst: size: = %x\n", msg->mrfld_header.p.header_low_payload);
+	if (msg->mrfld_header.p.header_high.part.large)
+		memcpy_toio(sst_drv_ctx->mailbox + SST_MAILBOX_SEND,
+			    msg->mailbox_data, msg->mrfld_header.p.header_low_payload);
+
+	trace_sst_ipc("POST  ->", msg->mrfld_header.p.header_high.full,
+				  msg->mrfld_header.p.header_low_payload,
+				  msg->mrfld_header.p.header_high.part.drv_id);
+	trace_sst_ipc_mailbox(msg->mailbox_data, msg->mrfld_header.p.header_low_payload);
+	sst_shim_write64(sst_drv_ctx->shim, SST_IPCX, msg->mrfld_header.full);
+	spin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+	pr_debug("sst: Post message: header = %x\n",
+					msg->mrfld_header.p.header_high.full);
+	kfree(msg->mailbox_data);
+	kfree(msg);
+	return;
+}
+
+/**
+* sst_post_message - Posts message to SST
+*
+* @work: Pointer to work structure
+*
+* This function is called by any component in driver which
+* wants to send an IPC message. This will post message only if
+* busy bit is free
+*/
+void sst_post_message_mfld(struct work_struct *work)
+{
+	struct ipc_post *msg;
+	union ipc_header header;
+	unsigned long irq_flags;
+
+	pr_debug("Enter:%s\n", __func__);
+
+	spin_lock_irqsave(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+	/* check list */
+	if (list_empty(&sst_drv_ctx->ipc_dispatch_list)) {
+		/* queue is empty, nothing to send */
+		spin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+		pr_debug("Empty msg queue... NO Action\n");
+		return;
+	}
+
+	/* check busy bit */
+	header.full = sst_shim_read(sst_drv_ctx->shim, sst_drv_ctx->ipc_reg.ipcx);
+	if (header.part.busy) {
+		spin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+		pr_debug("Busy not free... Post later\n");
+		return;
+	}
+	/* copy msg from list */
+	msg = list_entry(sst_drv_ctx->ipc_dispatch_list.next,
+			struct ipc_post, node);
+	list_del(&msg->node);
+	pr_debug("size: = %x\n", msg->header.part.data);
+	if (msg->header.part.large)
+		memcpy_toio(sst_drv_ctx->mailbox + SST_MAILBOX_SEND,
+			msg->mailbox_data, msg->header.part.data);
+
+	sst_shim_write(sst_drv_ctx->shim, sst_drv_ctx->ipc_reg.ipcx, msg->header.full);
+	spin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+	pr_debug("Posted message: header = %x\n", msg->header.full);
+
+	kfree(msg->mailbox_data);
+	kfree(msg);
+	return;
+}
+
+int sst_sync_post_message_mrfld(struct ipc_post *msg)
+{
+	union ipc_header_mrfld header;
+	unsigned int loop_count = 0;
+	int retval = 0;
+	unsigned long irq_flags;
+
+	pr_debug("Enter:%s\n", __func__);
+	spin_lock_irqsave(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+
+	/* check busy bit */
+	header.full = sst_shim_read64(sst_drv_ctx->shim, SST_IPCX);
+	while (header.p.header_high.part.busy) {
+		if (loop_count > 10) {
+			pr_err("sst: Busy wait failed, cant send this msg\n");
+			retval = -EBUSY;
+			goto out;
+		}
+		udelay(500);
+		loop_count++;
+		header.full = sst_shim_read64(sst_drv_ctx->shim, SST_IPCX);
+	}
+	pr_debug("sst: Post message: header = %x\n",
+					msg->mrfld_header.p.header_high.full);
+	pr_debug("sst: size = 0x%x\n", msg->mrfld_header.p.header_low_payload);
+	if (msg->mrfld_header.p.header_high.part.large)
+		memcpy_toio(sst_drv_ctx->mailbox + SST_MAILBOX_SEND,
+			msg->mailbox_data, msg->mrfld_header.p.header_low_payload);
+
+	trace_sst_ipc("POST  ->", msg->mrfld_header.p.header_high.full,
+				  msg->mrfld_header.p.header_low_payload,
+				  msg->mrfld_header.p.header_high.part.drv_id);
+	trace_sst_ipc_mailbox(msg->mailbox_data, msg->mrfld_header.p.header_low_payload);
+	sst_shim_write64(sst_drv_ctx->shim, SST_IPCX, msg->mrfld_header.full);
+
+out:
+	spin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+	kfree(msg->mailbox_data);
+	kfree(msg);
+	return retval;
+}
+
+/* use this for trigger ops to post syncronous msgs
+ */
+int sst_sync_post_message_mfld(struct ipc_post *msg)
+{
+	union ipc_header header;
+	unsigned int loop_count = 0;
+	int retval = 0;
+	unsigned long irq_flags;
+
+	pr_debug("Enter:%s\n", __func__);
+	spin_lock_irqsave(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+
+	/* check busy bit */
+	header.full = sst_shim_read(sst_drv_ctx->shim, sst_drv_ctx->ipc_reg.ipcx);
+	while (header.part.busy) {
+		if (loop_count > 10) {
+			pr_err("busy wait failed, cant send this msg\n");
+			retval = -EBUSY;
+			goto out;
+		}
+		udelay(500);
+		loop_count++;
+		header.full = sst_shim_read(sst_drv_ctx->shim, sst_drv_ctx->ipc_reg.ipcx);
+	}
+	pr_debug("sst: Post message: header = %x\n", msg->header.full);
+	if (msg->header.part.large)
+		memcpy_toio(sst_drv_ctx->mailbox + SST_MAILBOX_SEND,
+			msg->mailbox_data, msg->header.part.data);
+	sst_shim_write(sst_drv_ctx->shim, sst_drv_ctx->ipc_reg.ipcx, msg->header.full);
+
+out:
+	spin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+	kfree(msg->mailbox_data);
+	kfree(msg);
+
+	return retval;
+}
+
+/*
+ * sst_clear_interrupt - clear the SST FW interrupt
+ *
+ * This function clears the interrupt register after the interrupt
+ * bottom half is complete allowing next interrupt to arrive
+ */
+void intel_sst_clear_intr_mfld(void)
+{
+	union interrupt_reg isr;
+	union interrupt_reg imr;
+	union ipc_header clear_ipc;
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+	imr.full = sst_shim_read(sst_drv_ctx->shim, SST_IMRX);
+	isr.full = sst_shim_read(sst_drv_ctx->shim, SST_ISRX);
+	/*  write 1 to clear  */;
+	isr.part.busy_interrupt = 1;
+	sst_shim_write(sst_drv_ctx->shim, SST_ISRX, isr.full);
+	/* Set IA done bit */
+	clear_ipc.full = sst_shim_read(sst_drv_ctx->shim, sst_drv_ctx->ipc_reg.ipcd);
+	clear_ipc.part.busy = 0;
+	clear_ipc.part.done = 1;
+	clear_ipc.part.data = IPC_ACK_SUCCESS;
+	sst_shim_write(sst_drv_ctx->shim, sst_drv_ctx->ipc_reg.ipcd, clear_ipc.full);
+	/* un mask busy interrupt */
+	imr.part.busy_interrupt = 0;
+	imr.part.done_interrupt = 0;
+	sst_shim_write(sst_drv_ctx->shim, SST_IMRX, imr.full);
+	spin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+}
+
+
+void intel_sst_clear_intr_mrfld(void)
+{
+	union interrupt_reg_mrfld isr;
+	union interrupt_reg_mrfld imr;
+	union ipc_header_mrfld clear_ipc;
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+	imr.full = sst_shim_read64(sst_drv_ctx->shim, SST_IMRX);
+	isr.full = sst_shim_read64(sst_drv_ctx->shim, SST_ISRX);
+
+	/*  write 1 to clear  */
+	isr.part.busy_interrupt = 1;
+	sst_shim_write64(sst_drv_ctx->shim, SST_ISRX, isr.full);
+
+	/* Set IA done bit */
+	clear_ipc.full = sst_shim_read64(sst_drv_ctx->shim, SST_IPCD);
+
+	clear_ipc.p.header_high.part.busy = 0;
+	clear_ipc.p.header_high.part.done = 1;
+	clear_ipc.p.header_low_payload = IPC_ACK_SUCCESS;
+	sst_shim_write64(sst_drv_ctx->shim, SST_IPCD, clear_ipc.full);
+	/* un mask busy interrupt */
+	imr.part.busy_interrupt = 0;
+	sst_shim_write64(sst_drv_ctx->shim, SST_IMRX, imr.full);
+	spin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+}
+
+
+/*
+ * process_fw_init - process the FW init msg
+ *
+ * @msg: IPC message mailbox data from FW
+ *
+ * This function processes the FW init msg from FW
+ * marks FW state and prints debug info of loaded FW
+ */
+static void process_fw_init(void *msg)
+{
+	struct ipc_header_fw_init *init =
+		(struct ipc_header_fw_init *)msg;
+	int retval = 0;
+
+	pr_debug("*** FW Init msg came***\n");
+	if (init->result) {
+		sst_drv_ctx->sst_state =  SST_RESET;
+		pr_debug("FW Init failed, Error %x\n", init->result);
+		pr_err("FW Init failed, Error %x\n", init->result);
+		retval = init->result;
+		goto ret;
+	}
+	pr_info("FW Version %02x.%02x.%02x.%02x\n",
+		init->fw_version.type, init->fw_version.major,
+		init->fw_version.minor, init->fw_version.build);
+	pr_info("Build date %s Time %s\n",
+			init->build_info.date, init->build_info.time);
+
+	/* If there any runtime parameter to set, send it */
+	if (sst_drv_ctx->runtime_param.param.addr)
+		sst_send_runtime_param(&(sst_drv_ctx->runtime_param.param));
+
+ret:
+	sst_wake_up_block(sst_drv_ctx, retval, FW_DWNL_ID, 0 , NULL, 0);
+}
+/**
+* sst_process_message_mfld - Processes message from SST
+*
+* @work:	Pointer to work structure
+*
+* This function is scheduled by ISR
+* It take a msg from process_queue and does action based on msg
+*/
+void sst_process_message_mfld(struct ipc_post *msg)
+{
+	int str_id;
+	struct stream_info *stream;
+
+	str_id = msg->header.part.str_id;
+	pr_debug("IPC process for %x\n", msg->header.full);
+	/* based on msg in list call respective handler */
+	switch (msg->header.part.msg_id) {
+	case IPC_SST_PERIOD_ELAPSED:
+		if (sst_validate_strid(str_id)) {
+			pr_err("stream id %d invalid\n", str_id);
+			break;
+		}
+		stream = &sst_drv_ctx->streams[str_id];
+		if (stream->period_elapsed)
+			stream->period_elapsed(stream->pcm_substream);
+		break;
+	case IPC_SST_BUF_UNDER_RUN:
+	case IPC_SST_BUF_OVER_RUN:
+		if (sst_validate_strid(str_id)) {
+			pr_err("stream id %d invalid\n", str_id);
+			break;
+		}
+		pr_err("Buffer under/overrun for %d\n",
+				msg->header.part.str_id);
+		pr_err("Got Underrun & not to send data...ignore\n");
+		break;
+
+	case IPC_SST_FRAGMENT_ELPASED: {
+		pr_debug("IPC_SST_FRAGMENT_ELPASED for %d", str_id);
+		sst_cdev_fragment_elapsed(str_id);
+		break;
+	}
+
+	case IPC_IA_PRINT_STRING:
+		pr_debug("been asked to print something by fw\n");
+		/* TBD */
+		break;
+
+	case IPC_IA_FW_INIT_CMPLT: {
+		/* send next data to FW */
+		process_fw_init(msg->mailbox_data);
+		break;
+	}
+
+	case IPC_SST_STREAM_PROCESS_FATAL_ERR:
+		if (sst_validate_strid(str_id)) {
+			pr_err("stream id %d invalid\n", str_id);
+			break;
+		}
+		pr_err("codec fatal error %x stream %d...\n",
+				msg->header.full, msg->header.part.str_id);
+		pr_err("Dropping the stream\n");
+		sst_drop_stream(msg->header.part.str_id);
+		break;
+	default:
+		/* Illegal case */
+		pr_err("Unhandled msg %x header %x\n",
+		msg->header.part.msg_id, msg->header.full);
+	}
+	return;
+}
+
+/**
+* sst_process_message - Processes message from SST
+*
+* @work:	Pointer to work structure
+*
+* This function is scheduled by ISR
+* It take a msg from process_queue and does action based on msg
+*/
+
+void sst_process_message_mrfld(struct ipc_post *msg)
+{
+	int str_id;
+
+	str_id = msg->mrfld_header.p.header_high.part.drv_id;
+
+	pr_debug("IPC process message header %x payload %x\n",
+			msg->mrfld_header.p.header_high.full,
+			msg->mrfld_header.p.header_low_payload);
+
+	return;
+}
+
+#define VTSV_MAX_NUM_RESULTS 6
+#define VTSV_SIZE_PER_RESULT 7 /* 7 16 bit words */
+/* Max 6 results each of size 7 words + 1 num results word */
+#define VTSV_MAX_TOTAL_RESULT_SIZE \
+	(VTSV_MAX_NUM_RESULTS*VTSV_SIZE_PER_RESULT + 1)
+/* Each data word in the result is sent as a string in the format:
+DATAn=d, where n is the data word index varying from 0 to
+				VTSV_MAX_TOTAL_RESULT_SIZE-1
+d = string representation of data in decimal format;
+				unsigned 16bit data needs max 5 chars
+So total data string size = 4("DATA")+2("n")+1("=")
+				+5("d")+1(null)+5(reserved) = 18  */
+#define VTSV_DATA_STRING_SIZE 18
+
+static int send_vtsv_result_event(void *data, int size)
+{
+	char *envp[VTSV_MAX_TOTAL_RESULT_SIZE+3];
+	char res_size[30];
+	char ev_type[30];
+	char result[VTSV_MAX_TOTAL_RESULT_SIZE][VTSV_DATA_STRING_SIZE];
+	int offset = 0;
+	u16 *tmp;
+	int i;
+	int ret;
+
+	if (!data) {
+		pr_err("Data pointer Null into %s\n", __func__);
+		return -EINVAL;
+	}
+	size = size / (sizeof(u16)); /* Number of 16 bit data words*/
+	if (size > VTSV_MAX_TOTAL_RESULT_SIZE) {
+		pr_err("VTSV result size exceeds expected value, no uevent sent\n");
+		return -EINVAL;
+	}
+
+	snprintf(ev_type, sizeof(res_size), "EVENT_TYPE=SST_VTSV");
+	envp[offset++] = ev_type;
+	snprintf(res_size, sizeof(ev_type), "VTSV_RESULT_SIZE=%u", size);
+	envp[offset++] = res_size;
+	tmp = (u16 *)(data);
+	for (i = 0; i < size; i++) {
+		/* Driver assumes all data to be u16; The VTSV service
+		layer will type cast to u16 or s16 as appropriate for
+		a given data word*/
+		snprintf(result[i], VTSV_DATA_STRING_SIZE,
+				"DATA%u=%u", i, *tmp++);
+		envp[offset++] = result[i];
+	}
+	envp[offset] = NULL;
+	ret = kobject_uevent_env(&sst_drv_ctx->dev->kobj, KOBJ_CHANGE, envp);
+	if (ret)
+		pr_err("VTSV event send failed: ret = %d\n", ret);
+	return ret;
+}
+
+static void process_fw_async_msg(struct ipc_post *msg)
+{
+	u32 msg_id;
+	int str_id;
+	int res_size, ret;
+	u32 data_size, i;
+	void *data_offset;
+	struct stream_info *stream;
+	union ipc_header_high msg_high;
+	u32 msg_low, pipe_id;
+
+	msg_high = msg->mrfld_header.p.header_high;
+	msg_low = msg->mrfld_header.p.header_low_payload;
+	msg_id = ((struct ipc_dsp_hdr *)msg->mailbox_data)->cmd_id;
+	data_offset = (msg->mailbox_data + sizeof(struct ipc_dsp_hdr));
+	data_size =  msg_low - (sizeof(struct ipc_dsp_hdr));
+
+	switch (msg_id) {
+	case IPC_SST_PERIOD_ELAPSED_MRFLD:
+		pipe_id = ((struct ipc_dsp_hdr *)msg->mailbox_data)->pipe_id;
+		str_id = get_stream_id_mrfld(pipe_id);
+		if (str_id > 0) {
+			pr_debug("Period elapsed rcvd for pipe id 0x%x\n", pipe_id);
+			stream = &sst_drv_ctx->streams[str_id];
+			if (stream->period_elapsed)
+				stream->period_elapsed(stream->pcm_substream);
+			if (stream->compr_cb)
+				stream->compr_cb(stream->compr_cb_param);
+		}
+		break;
+
+	case IPC_IA_DRAIN_STREAM_MRFLD:
+		pipe_id = ((struct ipc_dsp_hdr *)msg->mailbox_data)->pipe_id;
+		str_id = get_stream_id_mrfld(pipe_id);
+		if (str_id > 0) {
+			stream = &sst_drv_ctx->streams[str_id];
+			if (stream->drain_notify)
+				stream->drain_notify(stream->drain_cb_param);
+		}
+		break;
+
+	case IPC_IA_FW_ASYNC_ERR_MRFLD:
+		pr_err("FW sent async error msg:\n");
+		for (i = 0; i < (data_size/4); i++)
+			pr_err("0x%x\n", (*((unsigned int *)data_offset + i)));
+		break;
+
+	case IPC_IA_VTSV_DETECTED:
+		res_size = data_size;
+		ret = send_vtsv_result_event(data_offset, res_size);
+		if (ret)
+			pr_err("VTSV uevent send failed: %d\n", ret);
+		else
+			pr_debug("VTSV uevent sent\n");
+		break;
+
+	case IPC_IA_FW_INIT_CMPLT_MRFLD:
+		process_fw_init(data_offset);
+		break;
+
+	case IPC_IA_BUF_UNDER_RUN_MRFLD:
+		pipe_id = ((struct ipc_dsp_hdr *)msg->mailbox_data)->pipe_id;
+		str_id = get_stream_id_mrfld(pipe_id);
+		if (str_id > 0)
+			pr_err("Buffer under-run for pipe:%#x str_id:%d\n",
+					pipe_id, str_id);
+		break;
+
+	default:
+		pr_err("Unrecognized async msg from FW msg_id %#x\n", msg_id);
+	}
+}
+
+void sst_process_reply_mrfld(struct ipc_post *msg)
+{
+	unsigned int drv_id;
+	void *data;
+	union ipc_header_high msg_high;
+	u32 msg_low;
+	struct ipc_dsp_hdr *dsp_hdr;
+	unsigned int cmd_id;
+
+	msg_high = msg->mrfld_header.p.header_high;
+	msg_low = msg->mrfld_header.p.header_low_payload;
+
+	pr_debug("IPC process message header %x payload %x\n",
+			msg->mrfld_header.p.header_high.full,
+			msg->mrfld_header.p.header_low_payload);
+
+	drv_id = msg_high.part.drv_id;
+
+	/* Check for async messages */
+	if (drv_id == SST_ASYNC_DRV_ID) {
+		/* FW sent async large message */
+		process_fw_async_msg(msg);
+		goto end;
+	}
+
+	/* FW sent short error response for an IPC */
+	if (msg_high.part.result && drv_id && !msg_high.part.large) {
+		/* 32-bit FW error code in msg_low */
+		pr_err("FW sent error response 0x%x", msg_low);
+		sst_wake_up_block(sst_drv_ctx, msg_high.part.result,
+			msg_high.part.drv_id,
+			msg_high.part.msg_id, NULL, 0);
+		goto end;
+	}
+
+	/* Process all valid responses */
+	/* if it is a large message, the payload contains the size to
+	 * copy from mailbox */
+	if (msg_high.part.large) {
+		data = kzalloc(msg_low, GFP_KERNEL);
+		if (!data)
+			goto end;
+		memcpy(data, (void *) msg->mailbox_data, msg_low);
+		/* Copy command id so that we can use to put sst to reset */
+		dsp_hdr = (struct ipc_dsp_hdr *)data;
+		cmd_id = dsp_hdr->cmd_id;
+		pr_debug("cmd_id %d\n", dsp_hdr->cmd_id);
+		if (sst_wake_up_block(sst_drv_ctx, msg_high.part.result,
+				msg_high.part.drv_id,
+				msg_high.part.msg_id, data, msg_low))
+			kfree(data);
+		if (cmd_id == IPC_SST_VB_RESET)
+			sst_set_fw_state_locked(sst_drv_ctx, SST_RESET);
+	} else {
+		sst_wake_up_block(sst_drv_ctx, msg_high.part.result,
+				msg_high.part.drv_id,
+				msg_high.part.msg_id, NULL, 0);
+	}
+
+end:
+	return;
+}
+
+/**
+* sst_process_reply - Processes reply message from SST
+*
+* @work:	Pointer to work structure
+*
+* This function is scheduled by ISR
+* It take a reply msg from response_queue and
+* does action based on msg
+*/
+void sst_process_reply_mfld(struct ipc_post *msg)
+{
+	void *data;
+	int str_id;
+	struct stream_info *stream;
+
+
+	str_id = msg->header.part.str_id;
+
+	pr_debug("sst: IPC process reply for %x\n", msg->header.full);
+
+	/* handle drain notify first */
+	if (msg->header.part.msg_id == IPC_IA_DRAIN_STREAM) {
+		pr_debug("drain message notify\n");
+		if (str_id > 0) {
+			stream = &sst_drv_ctx->streams[str_id];
+			if (stream->drain_notify)
+				stream->drain_notify(stream->drain_cb_param);
+		}
+		return;
+	}
+
+
+	if (!msg->header.part.large) {
+		if (!msg->header.part.data)
+			pr_debug("Success\n");
+		else
+			pr_err("Error from firmware: %d\n", msg->header.part.data);
+		sst_wake_up_block(sst_drv_ctx, msg->header.part.data,
+				str_id, msg->header.part.msg_id, NULL, 0);
+	} else {
+		pr_debug("Allocating %d\n", msg->header.part.data);
+		data = kzalloc(msg->header.part.data, GFP_KERNEL);
+		if (!data) {
+			pr_err("sst: mem alloc failed\n");
+			return;
+		}
+
+		memcpy(data, (void *)msg->mailbox_data, msg->header.part.data);
+		if (sst_wake_up_block(sst_drv_ctx, 0, str_id,
+				msg->header.part.msg_id, data,
+				msg->header.part.data))
+			kfree(data);
+	}
+	return;
+}
diff --git a/sound/soc/intel/sst/sst_pvt.c b/sound/soc/intel/sst/sst_pvt.c
new file mode 100644
index 0000000..cc0b9d8
--- /dev/null
+++ b/sound/soc/intel/sst/sst_pvt.c
@@ -0,0 +1,572 @@
+/*
+ *  sst_pvt.c - Intel SST Driver for audio engine
+ *
+ *  Copyright (C) 2008-10	Intel Corp
+ *  Authors:	Vinod Koul <vinod.koul@intel.com>
+ *		Harsha Priya <priya.harsha@intel.com>
+ *		Dharageswari R <dharageswari.r@intel.com>
+ *		KP Jeeja <jeeja.kp@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This file contains all private functions
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/kobject.h>
+#include <linux/pci.h>
+#include <linux/fs.h>
+#include <linux/firmware.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <sound/asound.h>
+#include <sound/pcm.h>
+#include <sound/compress_offload.h>
+#include "../sst_platform.h"
+#include "../platform_ipc_v2.h"
+#include "sst.h"
+
+#define SST_EXCE_DUMP_BASE	0xFFFF2c00
+#define SST_EXCE_DUMP_WORD	4
+#define SST_EXCE_DUMP_LEN	32
+#define SST_EXCE_DUMP_SIZE	((SST_EXCE_DUMP_LEN)*(SST_EXCE_DUMP_WORD))
+#define SST_EXCE_DUMP_OFFSET	0xA00
+/*
+ * sst_wait_interruptible - wait on event
+ *
+ * @sst_drv_ctx: Driver context
+ * @block: Driver block to wait on
+ *
+ * This function waits without a timeout (and is interruptable) for a
+ * given block event
+ */
+int sst_wait_interruptible(struct intel_sst_drv *sst_drv_ctx,
+				struct sst_block *block)
+{
+	int retval = 0;
+
+	if (!wait_event_interruptible(sst_drv_ctx->wait_queue,
+				block->condition)) {
+		/* event wake */
+		if (block->ret_code < 0) {
+			pr_err("stream failed %d\n", block->ret_code);
+			retval = -EBUSY;
+		} else {
+			pr_debug("event up\n");
+			retval = 0;
+		}
+	} else {
+		pr_err("signal interrupted\n");
+		retval = -EINTR;
+	}
+	return retval;
+
+}
+
+unsigned long long read_shim_data(struct intel_sst_drv *sst, int addr)
+{
+	unsigned long long val = 0;
+
+	switch (sst->pci_id) {
+	case SST_CLV_PCI_ID:
+		val = sst_shim_read(sst->shim, addr);
+		break;
+	case SST_MRFLD_PCI_ID:
+	case SST_BYT_PCI_ID:
+		val = sst_shim_read64(sst->shim, addr);
+		break;
+	}
+	return val;
+}
+
+void write_shim_data(struct intel_sst_drv *sst, int addr,
+				unsigned long long data)
+{
+	switch (sst->pci_id) {
+	case SST_CLV_PCI_ID:
+		sst_shim_write(sst->shim, addr, (u32) data);
+		break;
+	case SST_MRFLD_PCI_ID:
+	case SST_BYT_PCI_ID:
+		sst_shim_write64(sst->shim, addr, (u64) data);
+		break;
+	}
+}
+
+
+void dump_sst_shim(struct intel_sst_drv *sst)
+{
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&sst->ipc_spin_lock, irq_flags);
+	pr_err("audio shim registers:\n"
+		"CSR: %.8llx\n"
+		"PISR: %.8llx\n"
+		"PIMR: %.8llx\n"
+		"ISRX: %.8llx\n"
+		"ISRD: %.8llx\n"
+		"IMRX: %.8llx\n"
+		"IMRD: %.8llx\n"
+		"IPCX: %.8llx\n"
+		"IPCD: %.8llx\n"
+		"ISRSC: %.8llx\n"
+		"ISRLPESC: %.8llx\n"
+		"IMRSC: %.8llx\n"
+		"IMRLPESC: %.8llx\n"
+		"IPCSC: %.8llx\n"
+		"IPCLPESC: %.8llx\n"
+		"CLKCTL: %.8llx\n"
+		"CSR2: %.8llx\n",
+		read_shim_data(sst, SST_CSR),
+		read_shim_data(sst, SST_PISR),
+		read_shim_data(sst, SST_PIMR),
+		read_shim_data(sst, SST_ISRX),
+		read_shim_data(sst, SST_ISRD),
+		read_shim_data(sst, SST_IMRX),
+		read_shim_data(sst, SST_IMRD),
+		read_shim_data(sst, sst->ipc_reg.ipcx),
+		read_shim_data(sst, sst->ipc_reg.ipcd),
+		read_shim_data(sst, SST_ISRSC),
+		read_shim_data(sst, SST_ISRLPESC),
+		read_shim_data(sst, SST_IMRSC),
+		read_shim_data(sst, SST_IMRLPESC),
+		read_shim_data(sst, SST_IPCSC),
+		read_shim_data(sst, SST_IPCLPESC),
+		read_shim_data(sst, SST_CLKCTL),
+		read_shim_data(sst, SST_CSR2));
+	spin_unlock_irqrestore(&sst->ipc_spin_lock, irq_flags);
+}
+
+void reset_sst_shim(struct intel_sst_drv *sst)
+{
+	union config_status_reg_mrfld csr;
+
+	pr_err("Resetting few Shim registers\n");
+	write_shim_data(sst, sst->ipc_reg.ipcx, 0x0);
+	write_shim_data(sst, sst->ipc_reg.ipcd, 0x0);
+	write_shim_data(sst, SST_ISRX, 0x0);
+	write_shim_data(sst, SST_ISRD, 0x0);
+	write_shim_data(sst, SST_IPCSC, 0x0);
+	write_shim_data(sst, SST_IPCLPESC, 0x0);
+	write_shim_data(sst, SST_ISRSC, 0x0);
+	write_shim_data(sst, SST_ISRLPESC, 0x0);
+	write_shim_data(sst, SST_PISR, 0x0);
+
+	/* Reset the CSR value to the default value. i.e 0x1e40001*/
+	csr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);
+	csr.part.xt_snoop = 0;
+	csr.full &= ~(0xf);
+	csr.full |= 0x01;
+	sst_shim_write64(sst_drv_ctx->shim, SST_CSR, csr.full);
+}
+
+static void dump_sst_crash_area(void)
+{
+	void __iomem *fw_dump_area;
+	u32 dump_word;
+	u8 i;
+
+	/* dump the firmware SRAM where the exception details are stored */
+	fw_dump_area = ioremap_nocache(SST_EXCE_DUMP_BASE, SST_EXCE_DUMP_SIZE);
+
+	pr_err("Firmware exception dump begins:\n");
+	pr_err("Exception start signature:%#x\n", readl(fw_dump_area + SST_EXCE_DUMP_WORD));
+	pr_err("EXCCAUSE:\t\t\t%#x\n", readl(fw_dump_area + SST_EXCE_DUMP_WORD*2));
+	pr_err("EXCVADDR:\t\t\t%#x\n", readl(fw_dump_area + (SST_EXCE_DUMP_WORD*3)));
+	pr_err("Firmware additional data:\n");
+
+	/* dump remaining FW debug data */
+	for (i = 1; i < (SST_EXCE_DUMP_LEN-4+1); i++) {
+		dump_word = readl(fw_dump_area + (SST_EXCE_DUMP_WORD*3)
+						+ (i*SST_EXCE_DUMP_WORD));
+		pr_err("Data[%d]=%#x\n", i, dump_word);
+	}
+	iounmap(fw_dump_area);
+	pr_err("Firmware exception dump ends\n");
+}
+
+/**
+ * dump_ram_area - dumps the iram/dram into a local buff
+ *
+ * @sst			: pointer to driver context
+ * @recovery		: pointer to the struct containing buffers
+ * @iram		: true if iram dump else false
+ * This function dumps the iram dram data into the respective buffers
+ */
+static void dump_ram_area(struct intel_sst_drv *sst,
+			struct sst_dump_buf *dump_buf, enum sst_ram_type type)
+{
+	if (type == SST_IRAM) {
+		pr_err("Iram dumped in buffer\n");
+		memcpy_fromio(dump_buf->iram_buf.buf, sst->iram,
+				dump_buf->iram_buf.size);
+	} else {
+		pr_err("Dram dumped in buffer\n");
+		memcpy_fromio(dump_buf->dram_buf.buf, sst->dram,
+				dump_buf->dram_buf.size);
+	}
+}
+
+/*FIXME Disabling IRAM/DRAM dump for timeout issues */
+static void sst_stream_recovery(struct intel_sst_drv *sst)
+{
+	struct stream_info *str_info;
+	u8 i;
+	for (i = 1; i <= sst->info.max_streams; i++) {
+		pr_err("Audio: Stream %d, state %d\n", i, sst->streams[i].status);
+		if (sst->streams[i].status != STREAM_UN_INIT) {
+			str_info = &sst_drv_ctx->streams[i];
+			if (str_info->pcm_substream)
+				snd_pcm_stop(str_info->pcm_substream, SNDRV_PCM_STATE_SETUP);
+			else if (str_info->compr_cb_param)
+				snd_compr_stop(str_info->compr_cb_param);
+			sst->streams[i].status = STREAM_RESET;
+		}
+	}
+}
+
+static void sst_dump_ipc_dispatch_lists(struct intel_sst_drv *sst)
+{
+	struct ipc_post *m, *_m;
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&sst->ipc_spin_lock, irq_flags);
+	if (list_empty(&sst->ipc_dispatch_list))
+		pr_err("ipc dispatch list is Empty\n");
+
+	list_for_each_entry_safe(m, _m, &sst->ipc_dispatch_list, node) {
+		pr_err("ipc-dispatch:pending msg header %#x\n", m->header.full);
+		list_del(&m->node);
+		kfree(m->mailbox_data);
+		kfree(m);
+	}
+	spin_unlock_irqrestore(&sst->ipc_spin_lock, irq_flags);
+}
+
+static void sst_dump_rx_lists(struct intel_sst_drv *sst)
+{
+	struct ipc_post *m, *_m;
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&sst->rx_msg_lock, irq_flags);
+	if (list_empty(&sst->rx_list))
+		pr_err("rx msg list is empty\n");
+
+	list_for_each_entry_safe(m, _m, &sst->rx_list, node) {
+		pr_err("rx: pending msg header %#x\n", m->header.full);
+		list_del(&m->node);
+		kfree(m->mailbox_data);
+		kfree(m);
+	}
+	spin_unlock_irqrestore(&sst->rx_msg_lock, irq_flags);
+}
+
+/* num_dwords: should be multiple of 4 */
+static void dump_buffer_fromio(void __iomem *from,
+				     unsigned int num_dwords)
+{
+	int i;
+	u32 val[4];
+
+	if (num_dwords % 4) {
+		pr_err("%s: num_dwords %d not multiple of 4\n",
+				__func__, num_dwords);
+		return;
+	}
+
+	pr_err("****** Start *******\n");
+	pr_err("Dump %d dwords, from location %p\n", num_dwords, from);
+
+	for (i = 0; i < num_dwords; ) {
+		val[0] = ioread32(from + (i++ * 4));
+		val[1] = ioread32(from + (i++ * 4));
+		val[2] = ioread32(from + (i++ * 4));
+		val[3] = ioread32(from + (i++ * 4));
+		pr_err("%.8x %.8x %.8x %.8x\n", val[0], val[1], val[2], val[3]);
+	}
+	pr_err("****** End *********\n\n\n");
+}
+
+static void sst_stall_lpe_n_wait(struct intel_sst_drv *sst)
+{
+	union config_status_reg_mrfld csr;
+	void __iomem *dma_reg0 = sst->debugfs.dma_reg[0];
+	void __iomem *dma_reg1 = sst->debugfs.dma_reg[1];
+	int offset = 0x3A0; /* ChEnReg of DMA */
+
+
+	pr_err("Before stall: DMA_0 Ch_EN %#llx DMA_1 Ch_EN %#llx\n",
+				sst_reg_read64(dma_reg0, offset),
+				sst_reg_read64(dma_reg1, offset));
+
+	/* Stall LPE */
+	csr.full = sst_shim_read64(sst->shim, SST_CSR);
+	csr.part.runstall  = 1;
+	sst_shim_write64(sst->shim, SST_CSR, csr.full);
+
+	/* A 5ms delay, before resetting the LPE */
+	usleep_range(5000, 5100);
+
+	pr_err("After stall: DMA_0 Ch_EN %#llx DMA_1 Ch_EN %#llx\n",
+				sst_reg_read64(dma_reg0, offset),
+				sst_reg_read64(dma_reg1, offset));
+}
+
+#if IS_ENABLED(CONFIG_INTEL_SCU_IPC)
+static void sst_send_scu_reset_ipc(struct intel_sst_drv *sst)
+{
+	int ret = 0;
+
+	/* Reset and power gate the LPE */
+	ret = intel_scu_ipc_simple_command(IPC_SCU_LPE_RESET, 0);
+	if (ret) {
+		pr_err("Power gating LPE failed %d\n", ret);
+		reset_sst_shim(sst);
+	} else {
+		pr_err("LPE reset via SCU is success!!\n");
+		pr_err("dump after LPE power cycle\n");
+		dump_sst_shim(sst);
+
+		/* Mask the DMA & SSP interrupts */
+		sst_shim_write64(sst->shim, SST_IMRX, 0xFFFF0038);
+	}
+}
+#else
+static void sst_send_scu_reset_ipc(struct intel_sst_drv *sst)
+{
+	pr_debug("%s: do nothing, just return\n", __func__);
+}
+#endif
+
+#define SRAM_OFFSET_MRFLD	0xc00
+#define NUM_DWORDS		256
+void sst_do_recovery_mrfld(struct intel_sst_drv *sst)
+{
+	char iram_event[30], dram_event[30], ddr_imr_event[65], event_type[30];
+	char *envp[5];
+	int env_offset = 0;
+
+	/*
+	 * setting firmware state as RESET so that the firmware will get
+	 * redownloaded on next request.This is because firmare not responding
+	 * for 1 sec is equalant to some unrecoverable error of FW.
+	 */
+	pr_err("Audio: Intel SST engine encountered an unrecoverable error\n");
+	pr_err("Audio: trying to reset the dsp now\n");
+
+	mutex_lock(&sst->sst_lock);
+	sst->sst_state = SST_RESET;
+	sst_stream_recovery(sst);
+	mutex_unlock(&sst->sst_lock);
+
+	dump_stack();
+	dump_sst_shim(sst);
+
+	sst_stall_lpe_n_wait(sst);
+
+	/* dump mailbox and sram */
+	pr_err("Dumping Mailbox...\n");
+	dump_buffer_fromio(sst->mailbox, NUM_DWORDS);
+	pr_err("Dumping SRAM...\n");
+	dump_buffer_fromio(sst->mailbox + SRAM_OFFSET_MRFLD, NUM_DWORDS);
+
+	if (sst_drv_ctx->ops->set_bypass) {
+
+		sst_drv_ctx->ops->set_bypass(true);
+		dump_ram_area(sst, &(sst->dump_buf), SST_IRAM);
+		dump_ram_area(sst, &(sst->dump_buf), SST_DRAM);
+		sst_drv_ctx->ops->set_bypass(false);
+
+	}
+
+	snprintf(event_type, sizeof(event_type), "EVENT_TYPE=SST_RECOVERY");
+	envp[env_offset++] = event_type;
+	snprintf(iram_event, sizeof(iram_event), "IRAM_DUMP_SIZE=%d",
+					sst->dump_buf.iram_buf.size);
+	envp[env_offset++] = iram_event;
+	snprintf(dram_event, sizeof(dram_event), "DRAM_DUMP_SIZE=%d",
+					sst->dump_buf.dram_buf.size);
+	envp[env_offset++] = dram_event;
+
+	if (sst->ddr != NULL) {
+		snprintf(ddr_imr_event, sizeof(ddr_imr_event),
+		"DDR_IMR_DUMP_SIZE=%d DDR_IMR_ADDRESS=%p", (sst->ddr_end - sst->ddr_base), sst->ddr);
+		envp[env_offset++] = ddr_imr_event;
+	}
+	envp[env_offset] = NULL;
+	kobject_uevent_env(&sst->dev->kobj, KOBJ_CHANGE, envp);
+	pr_err("Recovery Uevent Sent!!\n");
+
+	/* Send IPC to SCU to power gate and reset the LPE */
+	sst_send_scu_reset_ipc(sst);
+
+	pr_err("reset the pvt id from val %d\n", sst_drv_ctx->pvt_id);
+	spin_lock(&sst_drv_ctx->pvt_id_lock);
+	sst_drv_ctx->pvt_id = 0;
+	spin_unlock(&sst_drv_ctx->pvt_id_lock);
+	sst_dump_ipc_dispatch_lists(sst_drv_ctx);
+	sst_dump_rx_lists(sst_drv_ctx);
+
+	if (sst_drv_ctx->fw_in_mem) {
+		pr_err("Clearing the cached FW copy...\n");
+		kfree(sst_drv_ctx->fw_in_mem);
+		sst_drv_ctx->fw_in_mem = NULL;
+	}
+}
+
+void sst_do_recovery(struct intel_sst_drv *sst)
+{
+	pr_err("Audio: Intel SST engine encountered an unrecoverable error\n");
+
+	dump_stack();
+	dump_sst_shim(sst);
+
+	if (sst->sst_state == SST_FW_RUNNING &&
+		sst_drv_ctx->pci_id == SST_CLV_PCI_ID)
+		dump_sst_crash_area();
+
+	sst_dump_ipc_dispatch_lists(sst_drv_ctx);
+
+}
+
+/*
+ * sst_wait_timeout - wait on event for timeout
+ *
+ * @sst_drv_ctx: Driver context
+ * @block: Driver block to wait on
+ *
+ * This function waits with a timeout value (and is not interruptible) on a
+ * given block event
+ */
+int sst_wait_timeout(struct intel_sst_drv *sst_drv_ctx, struct sst_block *block)
+{
+	int retval = 0;
+
+	/* NOTE:
+	Observed that FW processes the alloc msg and replies even
+	before the alloc thread has finished execution */
+	pr_debug("sst: waiting for condition %x ipc %d drv_id %d\n",
+		       block->condition, block->msg_id, block->drv_id);
+	if (wait_event_timeout(sst_drv_ctx->wait_queue,
+				block->condition,
+				msecs_to_jiffies(SST_BLOCK_TIMEOUT))) {
+		/* event wake */
+		pr_debug("sst: Event wake %x\n", block->condition);
+		pr_debug("sst: message ret: %d\n", block->ret_code);
+		retval = -block->ret_code;
+	} else {
+		block->on = false;
+		pr_err("sst: Wait timed-out condition:%#x, msg_id:%#x fw_state %#x\n",
+				block->condition, block->msg_id, sst_drv_ctx->sst_state);
+
+		if (sst_drv_ctx->sst_state == SST_FW_LOADING) {
+			pr_err("Can't recover as timedout while downloading the FW\n");
+			pr_err("reseting fw state to RESET from %d ...\n", sst_drv_ctx->sst_state);
+			sst_drv_ctx->sst_state = SST_RESET;
+
+			dump_sst_shim(sst_drv_ctx);
+
+			/* Reset & Power Off the LPE only for MRFLD */
+			if (sst_drv_ctx->pci_id == SST_MRFLD_PCI_ID) {
+				sst_stall_lpe_n_wait(sst_drv_ctx);
+
+				/* Send IPC to SCU to power gate and reset the LPE */
+				sst_send_scu_reset_ipc(sst_drv_ctx);
+			}
+
+		} else {
+			if (sst_drv_ctx->ops->do_recovery)
+				sst_drv_ctx->ops->do_recovery(sst_drv_ctx);
+		}
+
+		retval = -EBUSY;
+	}
+	return retval;
+}
+
+/*
+ * sst_create_ipc_msg - create a IPC message
+ *
+ * @arg: ipc message
+ * @large: large or short message
+ *
+ * this function allocates structures to send a large or short
+ * message to the firmware
+ */
+int sst_create_ipc_msg(struct ipc_post **arg, bool large)
+{
+	struct ipc_post *msg;
+
+	msg = kzalloc(sizeof(struct ipc_post), GFP_ATOMIC);
+	if (!msg) {
+		pr_err("kzalloc ipc msg failed\n");
+		return -ENOMEM;
+	}
+	if (large) {
+		msg->mailbox_data = kzalloc(SST_MAILBOX_SIZE, GFP_ATOMIC);
+		if (!msg->mailbox_data) {
+			kfree(msg);
+			pr_err("kzalloc mailbox_data failed");
+			return -ENOMEM;
+		}
+	} else {
+		msg->mailbox_data = NULL;
+	}
+	msg->is_large = large;
+	*arg = msg;
+	return 0;
+}
+
+/*
+ * sst_create_block_and_ipc_msg - Creates IPC message and sst block
+ * @arg: passed to sst_create_ipc_message API
+ * @large: large or short message
+ * @sst_drv_ctx: sst driver context
+ * @block: return block allocated
+ * @msg_id: IPC
+ * @drv_id: stream id or private id
+ */
+int sst_create_block_and_ipc_msg(struct ipc_post **arg, bool large,
+		struct intel_sst_drv *sst_drv_ctx, struct sst_block **block,
+		u32 msg_id, u32 drv_id)
+{
+	int retval = 0;
+	retval = sst_create_ipc_msg(arg, large);
+	if (retval)
+		return retval;
+	*block = sst_create_block(sst_drv_ctx, msg_id, drv_id);
+	if (*block == NULL) {
+		kfree(*arg);
+		return -ENOMEM;
+	}
+	return retval;
+}
+
+/*
+ * sst_clean_stream - clean the stream context
+ *
+ * @stream: stream structure
+ *
+ * this function resets the stream contexts
+ * should be called in free
+ */
+void sst_clean_stream(struct stream_info *stream)
+{
+	stream->status = STREAM_UN_INIT;
+	stream->prev = STREAM_UN_INIT;
+	mutex_lock(&stream->lock);
+	stream->cumm_bytes = 0;
+	mutex_unlock(&stream->lock);
+}
+
diff --git a/sound/soc/intel/sst/sst_stream.c b/sound/soc/intel/sst/sst_stream.c
new file mode 100644
index 0000000..2c2d7e2
--- /dev/null
+++ b/sound/soc/intel/sst/sst_stream.c
@@ -0,0 +1,827 @@
+/*
+ *  sst_stream.c - Intel SST Driver for audio engine
+ *
+ *  Copyright (C) 2008-10 Intel Corp
+ *  Authors:	Vinod Koul <vinod.koul@intel.com>
+ *		Harsha Priya <priya.harsha@intel.com>
+ *		Dharageswari R <dharageswari.r@intel.com>
+ *		KP Jeeja <jeeja.kp@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This file contains the stream operations of SST driver
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/pci.h>
+#include <linux/firmware.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/pm_runtime.h>
+#include <asm/platform_sst_audio.h>
+#include "../sst_platform.h"
+#include "../platform_ipc_v2.h"
+#include "sst.h"
+#include "sst_trace.h"
+
+/**
+ * sst_alloc_stream - Send msg for a new stream ID
+ *
+ * @params:	stream params
+ * @stream_ops:	operation of stream PB/capture
+ * @codec:	codec for stream
+ * @device:	device stream to be allocated for
+ *
+ * This function is called by any function which wants to start
+ * a new stream. This also check if a stream exists which is idle
+ * it initializes idle stream id to this request
+ */
+int sst_alloc_stream_ctp(char *params, struct sst_block *block)
+{
+	struct ipc_post *msg = NULL;
+	struct snd_sst_alloc_params alloc_param;
+	unsigned int pcm_slot = 0x03, num_ch;
+	int str_id;
+	struct snd_sst_params *str_params;
+	struct snd_sst_stream_params *sparams;
+	struct snd_sst_alloc_params_ext *aparams;
+	struct stream_info *str_info;
+	unsigned int stream_ops, device;
+	u8 codec;
+
+	pr_debug("In %s\n", __func__);
+
+	BUG_ON(!params);
+	str_params = (struct snd_sst_params *)params;
+	stream_ops = str_params->ops;
+	codec = str_params->codec;
+	device = str_params->device_type;
+	sparams = &str_params->sparams;
+	aparams = &str_params->aparams;
+	num_ch = sst_get_num_channel(str_params);
+
+	pr_debug("period_size = %d\n", aparams->frag_size);
+	pr_debug("ring_buf_addr = 0x%x\n", aparams->ring_buf_info[0].addr);
+	pr_debug("ring_buf_size = %d\n", aparams->ring_buf_info[0].size);
+	pr_debug("In alloc device_type=%d\n", str_params->device_type);
+	pr_debug("In alloc sg_count =%d\n", aparams->sg_count);
+
+	str_id = str_params->stream_id;
+	if (str_id <= 0)
+		return -EBUSY;
+
+	/*allocate device type context*/
+	sst_init_stream(&sst_drv_ctx->streams[str_id], codec,
+			str_id, stream_ops, pcm_slot);
+	/* send msg to FW to allocate a stream */
+	if (sst_create_ipc_msg(&msg, true))
+		return -ENOMEM;
+
+	alloc_param.str_type.codec_type = codec;
+	alloc_param.str_type.str_type = str_params->stream_type;
+	alloc_param.str_type.operation = stream_ops;
+	alloc_param.str_type.protected_str = 0; /* non drm */
+	alloc_param.str_type.time_slots = pcm_slot;
+	alloc_param.str_type.reserved = 0;
+	alloc_param.str_type.result = 0;
+	memcpy(&alloc_param.stream_params, sparams,
+			sizeof(struct snd_sst_stream_params));
+	memcpy(&alloc_param.alloc_params, aparams,
+			sizeof(struct snd_sst_alloc_params_ext));
+	block->drv_id = str_id;
+	block->msg_id = IPC_IA_ALLOC_STREAM;
+	sst_fill_header(&msg->header, IPC_IA_ALLOC_STREAM, 1, str_id);
+	msg->header.part.data = sizeof(alloc_param) + sizeof(u32);
+	memcpy(msg->mailbox_data, &msg->header, sizeof(u32));
+	memcpy(msg->mailbox_data + sizeof(u32), &alloc_param,
+			sizeof(alloc_param));
+	str_info = &sst_drv_ctx->streams[str_id];
+	str_info->num_ch = num_ch;
+	sst_add_to_dispatch_list_and_post(sst_drv_ctx, msg);
+	return str_id;
+}
+
+int sst_alloc_stream_mrfld(char *params, struct sst_block *block)
+{
+	struct ipc_post *msg = NULL;
+	struct snd_sst_alloc_mrfld alloc_param;
+	struct ipc_dsp_hdr dsp_hdr;
+	struct snd_sst_params *str_params;
+	struct snd_sst_tstamp fw_tstamp;
+	unsigned int str_id, pipe_id, pvt_id, task_id;
+	u32 len = 0;
+	struct stream_info *str_info;
+	int i, num_ch;
+
+	pr_debug("In %s\n", __func__);
+	BUG_ON(!params);
+
+	str_params = (struct snd_sst_params *)params;
+	memset(&alloc_param, 0, sizeof(alloc_param));
+	alloc_param.operation = str_params->ops;
+	alloc_param.codec_type = str_params->codec;
+	alloc_param.sg_count = str_params->aparams.sg_count;
+	alloc_param.ring_buf_info[0].addr = str_params->aparams.ring_buf_info[0].addr;
+	alloc_param.ring_buf_info[0].size = str_params->aparams.ring_buf_info[0].size;
+	alloc_param.frag_size = str_params->aparams.frag_size;
+
+	memcpy(&alloc_param.codec_params, &str_params->sparams,
+			sizeof(struct snd_sst_stream_params));
+
+	/* fill channel map params for multichannel support.
+	 * Ideally channel map should be received from upper layers
+	 * for multichannel support.
+	 * Currently hardcoding as per FW reqm.
+	 */
+	num_ch = sst_get_num_channel(str_params);
+	for (i = 0; i < 8; i++) {
+		if (i < num_ch)
+			alloc_param.codec_params.uc.pcm_params.channel_map[i] = i;
+		else
+			alloc_param.codec_params.uc.pcm_params.channel_map[i] = 0xFF;
+	}
+
+	str_id = str_params->stream_id;
+	pipe_id = str_params->device_type;
+	task_id = str_params->task;
+	sst_drv_ctx->streams[str_id].pipe_id = pipe_id;
+	sst_drv_ctx->streams[str_id].task_id = task_id;
+	sst_drv_ctx->streams[str_id].num_ch = num_ch;
+
+	pvt_id = sst_assign_pvt_id(sst_drv_ctx);
+	if (sst_drv_ctx->info.lpe_viewpt_rqd)
+		alloc_param.ts = sst_drv_ctx->info.mailbox_start +
+			sst_drv_ctx->tstamp + (str_id * sizeof(fw_tstamp));
+	else
+		alloc_param.ts = sst_drv_ctx->mailbox_add +
+			sst_drv_ctx->tstamp + (str_id * sizeof(fw_tstamp));
+
+	pr_debug("alloc tstamp location = 0x%x\n", alloc_param.ts);
+	pr_debug("assigned pipe id 0x%x to task %d\n", pipe_id, task_id);
+
+	/*allocate device type context*/
+	sst_init_stream(&sst_drv_ctx->streams[str_id], alloc_param.codec_type,
+			str_id, alloc_param.operation, 0);
+	/* send msg to FW to allocate a stream */
+	if (sst_create_ipc_msg(&msg, true))
+		return -ENOMEM;
+
+	block->drv_id = pvt_id;
+	block->msg_id = IPC_CMD;
+
+	sst_fill_header_mrfld(&msg->mrfld_header, IPC_CMD,
+			      task_id, 1, pvt_id);
+	pr_debug("header:%x\n", msg->mrfld_header.p.header_high.full);
+	msg->mrfld_header.p.header_high.part.res_rqd = 1;
+
+	len = msg->mrfld_header.p.header_low_payload = sizeof(alloc_param) + sizeof(dsp_hdr);
+	sst_fill_header_dsp(&dsp_hdr, IPC_IA_ALLOC_STREAM_MRFLD, pipe_id, sizeof(alloc_param));
+	memcpy(msg->mailbox_data, &dsp_hdr, sizeof(dsp_hdr));
+	memcpy(msg->mailbox_data + sizeof(dsp_hdr), &alloc_param,
+			sizeof(alloc_param));
+	trace_sst_stream("ALLOC ->", str_id, pipe_id);
+	str_info = &sst_drv_ctx->streams[str_id];
+	pr_debug("header:%x\n", msg->mrfld_header.p.header_high.full);
+	pr_debug("response rqd: %x", msg->mrfld_header.p.header_high.part.res_rqd);
+	pr_debug("calling post_message\n");
+	pr_info("Alloc for str %d pipe %#x\n", str_id, pipe_id);
+
+	sst_add_to_dispatch_list_and_post(sst_drv_ctx, msg);
+	return str_id;
+}
+
+/**
+* sst_stream_stream - Send msg for a pausing stream
+* @str_id:	 stream ID
+*
+* This function is called by any function which wants to start
+* a stream.
+*/
+int sst_start_stream(int str_id)
+{
+	int retval = 0, pvt_id;
+	u32 len = 0;
+	struct ipc_post *msg = NULL;
+	struct ipc_dsp_hdr dsp_hdr;
+	struct stream_info *str_info;
+
+	pr_debug("sst_start_stream for %d\n", str_id);
+	str_info = get_stream_info(str_id);
+	if (!str_info)
+		return -EINVAL;
+	if (str_info->status != STREAM_RUNNING)
+		return -EBADRQC;
+
+	if (sst_create_ipc_msg(&msg, true))
+		return -ENOMEM;
+
+	if (!sst_drv_ctx->use_32bit_ops) {
+		pvt_id = sst_assign_pvt_id(sst_drv_ctx);
+		pr_debug("pvt_id = %d, pipe id = %d, task = %d\n",
+			 pvt_id, str_info->pipe_id, str_info->task_id);
+		sst_fill_header_mrfld(&msg->mrfld_header, IPC_CMD,
+				      str_info->task_id, 1, pvt_id);
+
+		len = sizeof(u16) + sizeof(dsp_hdr);
+		msg->mrfld_header.p.header_low_payload = len;
+		sst_fill_header_dsp(&dsp_hdr, IPC_IA_START_STREAM_MRFLD,
+				str_info->pipe_id, sizeof(u16));
+		memcpy(msg->mailbox_data, &dsp_hdr, sizeof(dsp_hdr));
+		memset(msg->mailbox_data + sizeof(dsp_hdr), 0, sizeof(u16));
+		trace_sst_stream("START ->", str_id, str_info->pipe_id);
+		pr_info("Start for str %d pipe %#x\n", str_id, str_info->pipe_id);
+
+	} else {
+		pr_debug("fill START_STREAM for CTP\n");
+		sst_fill_header(&msg->header, IPC_IA_START_STREAM, 1, str_id);
+		msg->header.part.data =  sizeof(u32) + sizeof(u32);
+		memcpy(msg->mailbox_data, &msg->header, sizeof(u32));
+		memset(msg->mailbox_data + sizeof(u32), 0, sizeof(u32));
+	}
+	sst_drv_ctx->ops->sync_post_message(msg);
+	return retval;
+}
+
+int sst_send_byte_stream_mrfld(void *sbytes)
+{
+	struct ipc_post *msg = NULL;
+	struct snd_sst_bytes_v2 *bytes = (struct snd_sst_bytes_v2 *) sbytes;
+	u32 length;
+	int pvt_id, ret = 0;
+	struct sst_block *block = NULL;
+
+	pr_debug("%s: type:%u ipc_msg:%u block:%u task_id:%u pipe: %#x length:%#x\n",
+		__func__, bytes->type, bytes->ipc_msg,
+		bytes->block, bytes->task_id,
+		bytes->pipe_id, bytes->len);
+
+	/* need some err check as this is user data, perhpas move this to the
+	 * platform driver and pass the struct
+	 */
+	if (sst_create_ipc_msg(&msg, true))
+		return -ENOMEM;
+
+	pvt_id = sst_assign_pvt_id(sst_drv_ctx);
+	sst_fill_header_mrfld(&msg->mrfld_header, bytes->ipc_msg, bytes->task_id,
+			      1, pvt_id);
+	msg->mrfld_header.p.header_high.part.res_rqd = bytes->block;
+	length = bytes->len;
+	msg->mrfld_header.p.header_low_payload = length;
+	pr_debug("length is %d\n", length);
+	memcpy(msg->mailbox_data, &bytes->bytes, bytes->len);
+	trace_sst_stream("BYTES ->", bytes->type, bytes->pipe_id);
+	if (bytes->block) {
+		block = sst_create_block(sst_drv_ctx, bytes->ipc_msg, pvt_id);
+		if (block == NULL) {
+			kfree(msg);
+			return -ENOMEM;
+		}
+	}
+	sst_add_to_dispatch_list_and_post(sst_drv_ctx, msg);
+	pr_debug("msg->mrfld_header.p.header_low_payload:%d", msg->mrfld_header.p.header_low_payload);
+	if (bytes->block) {
+		ret = sst_wait_timeout(sst_drv_ctx, block);
+		if (ret) {
+			pr_err("%s: fw returned err %d\n", __func__, ret);
+			sst_free_block(sst_drv_ctx, block);
+			return ret;
+		}
+	}
+	if (bytes->type == SND_SST_BYTES_GET) {
+		/* copy the reply and send back
+		 * we need to update only sz and payload
+		 */
+		if (bytes->block) {
+			unsigned char *r = block->data;
+			pr_debug("read back %d bytes", bytes->len);
+			memcpy(bytes->bytes, r, bytes->len);
+			trace_sst_stream("BYTES <-", bytes->type, bytes->pipe_id);
+		}
+	}
+	if (bytes->block)
+		sst_free_block(sst_drv_ctx, block);
+	return 0;
+}
+
+int sst_send_probe_bytes(struct intel_sst_drv *sst)
+{
+	struct ipc_post *msg = NULL;
+	struct sst_block *block;
+	int ret_val = 0;
+
+	ret_val = sst_create_block_and_ipc_msg(&msg, true, sst,
+			&block, IPC_IA_DBG_SET_PROBE_PARAMS, 0);
+	if (ret_val) {
+		pr_err("Can't allocate block/msg: Probe Byte Stream\n");
+		return ret_val;
+	}
+
+	sst_fill_header(&msg->header, IPC_IA_DBG_SET_PROBE_PARAMS, 1, 0);
+
+	msg->header.part.data = sizeof(u32) + sst->probe_bytes->len;
+	memcpy(msg->mailbox_data, &msg->header.full, sizeof(u32));
+	memcpy(msg->mailbox_data + sizeof(u32), sst->probe_bytes->bytes,
+				sst->probe_bytes->len);
+
+	sst_add_to_dispatch_list_and_post(sst, msg);
+	ret_val = sst_wait_timeout(sst, block);
+	sst_free_block(sst, block);
+	if (ret_val)
+		pr_err("set probe stream param..timeout!\n");
+	return ret_val;
+}
+
+/*
+ * sst_pause_stream - Send msg for a pausing stream
+ * @str_id:	 stream ID
+ *
+ * This function is called by any function which wants to pause
+ * an already running stream.
+ */
+int sst_pause_stream(int str_id)
+{
+	int retval = 0, pvt_id, len;
+	struct ipc_post *msg = NULL;
+	struct stream_info *str_info;
+	struct intel_sst_ops *ops;
+	struct sst_block *block;
+	struct ipc_dsp_hdr dsp_hdr;
+
+	pr_debug("SST DBG:sst_pause_stream for %d\n", str_id);
+	str_info = get_stream_info(str_id);
+	if (!str_info)
+		return -EINVAL;
+	ops = sst_drv_ctx->ops;
+	if (str_info->status == STREAM_PAUSED)
+		return 0;
+	if (str_info->status == STREAM_RUNNING ||
+		str_info->status == STREAM_INIT) {
+		if (str_info->prev == STREAM_UN_INIT)
+			return -EBADRQC;
+		if (!sst_drv_ctx->use_32bit_ops) {
+			pvt_id = sst_assign_pvt_id(sst_drv_ctx);
+			retval = sst_create_block_and_ipc_msg(&msg, true,
+					sst_drv_ctx, &block, IPC_CMD, pvt_id);
+			if (retval)
+				return retval;
+			sst_fill_header_mrfld(&msg->mrfld_header, IPC_CMD,
+					str_info->task_id, 1, pvt_id);
+			msg->mrfld_header.p.header_high.part.res_rqd = 1;
+			len = sizeof(dsp_hdr);
+			msg->mrfld_header.p.header_low_payload = len;
+			sst_fill_header_dsp(&dsp_hdr, IPC_IA_PAUSE_STREAM_MRFLD,
+						str_info->pipe_id, 0);
+			memcpy(msg->mailbox_data, &dsp_hdr, sizeof(dsp_hdr));
+			trace_sst_stream("PAUSE ->", str_id, str_info->pipe_id);
+		} else {
+			retval = sst_create_block_and_ipc_msg(&msg, false,
+					sst_drv_ctx, &block,
+					IPC_IA_PAUSE_STREAM, str_id);
+			if (retval)
+				return retval;
+			sst_fill_header(&msg->header, IPC_IA_PAUSE_STREAM,
+								0, str_id);
+		}
+		sst_add_to_dispatch_list_and_post(sst_drv_ctx, msg);
+		retval = sst_wait_timeout(sst_drv_ctx, block);
+		sst_free_block(sst_drv_ctx, block);
+		if (retval == 0) {
+			str_info->prev = str_info->status;
+			str_info->status = STREAM_PAUSED;
+		} else if (retval == SST_ERR_INVALID_STREAM_ID) {
+			retval = -EINVAL;
+			mutex_lock(&sst_drv_ctx->stream_lock);
+			sst_clean_stream(str_info);
+			mutex_unlock(&sst_drv_ctx->stream_lock);
+		}
+	} else {
+		retval = -EBADRQC;
+		pr_debug("SST DBG:BADRQC for stream\n ");
+	}
+
+	return retval;
+}
+
+/**
+ * sst_resume_stream - Send msg for resuming stream
+ * @str_id:		stream ID
+ *
+ * This function is called by any function which wants to resume
+ * an already paused stream.
+ */
+int sst_resume_stream(int str_id)
+{
+	int retval = 0;
+	struct ipc_post *msg = NULL;
+	struct stream_info *str_info;
+	struct intel_sst_ops *ops;
+	struct sst_block *block = NULL;
+	int pvt_id, len;
+	struct ipc_dsp_hdr dsp_hdr;
+
+	pr_debug("SST DBG:sst_resume_stream for %d\n", str_id);
+	str_info = get_stream_info(str_id);
+	if (!str_info)
+		return -EINVAL;
+	ops = sst_drv_ctx->ops;
+	if (str_info->status == STREAM_RUNNING)
+			return 0;
+	if (str_info->status == STREAM_PAUSED) {
+		if (!sst_drv_ctx->use_32bit_ops) {
+			pvt_id = sst_assign_pvt_id(sst_drv_ctx);
+			retval = sst_create_block_and_ipc_msg(&msg, true,
+					sst_drv_ctx, &block, IPC_CMD, pvt_id);
+			if (retval)
+				return retval;
+			sst_fill_header_mrfld(&msg->mrfld_header, IPC_CMD,
+					str_info->task_id, 1, pvt_id);
+			msg->mrfld_header.p.header_high.part.res_rqd = 1;
+			len = sizeof(dsp_hdr);
+			msg->mrfld_header.p.header_low_payload = len;
+			sst_fill_header_dsp(&dsp_hdr,
+						IPC_IA_RESUME_STREAM_MRFLD,
+						str_info->pipe_id, 0);
+			memcpy(msg->mailbox_data, &dsp_hdr, sizeof(dsp_hdr));
+			trace_sst_stream("RESUME->", str_id, str_info->pipe_id);
+		} else {
+			retval = sst_create_block_and_ipc_msg(&msg, false,
+					sst_drv_ctx, &block,
+					IPC_IA_RESUME_STREAM, str_id);
+			if (retval)
+				return retval;
+			sst_fill_header(&msg->header, IPC_IA_RESUME_STREAM,
+								0, str_id);
+		}
+		sst_add_to_dispatch_list_and_post(sst_drv_ctx, msg);
+		retval = sst_wait_timeout(sst_drv_ctx, block);
+		sst_free_block(sst_drv_ctx, block);
+		if (!retval) {
+			if (str_info->prev == STREAM_RUNNING)
+				str_info->status = STREAM_RUNNING;
+			else
+				str_info->status = STREAM_INIT;
+			str_info->prev = STREAM_PAUSED;
+		} else if (retval == -SST_ERR_INVALID_STREAM_ID) {
+			retval = -EINVAL;
+			mutex_lock(&sst_drv_ctx->stream_lock);
+			sst_clean_stream(str_info);
+			mutex_unlock(&sst_drv_ctx->stream_lock);
+		}
+	} else {
+		retval = -EBADRQC;
+		pr_err("SST ERR: BADQRC for stream\n");
+	}
+
+	return retval;
+}
+
+
+/**
+ * sst_drop_stream - Send msg for stopping stream
+ * @str_id:		stream ID
+ *
+ * This function is called by any function which wants to stop
+ * a stream.
+ */
+int sst_drop_stream(int str_id)
+{
+	int retval = 0, pvt_id;
+	struct stream_info *str_info;
+	struct ipc_post *msg = NULL;
+	struct ipc_dsp_hdr dsp_hdr;
+
+	pr_debug("SST DBG:sst_drop_stream for %d\n", str_id);
+	str_info = get_stream_info(str_id);
+	if (!str_info)
+		return -EINVAL;
+
+	if (str_info->status != STREAM_UN_INIT) {
+
+		if (sst_drv_ctx->use_32bit_ops == true) {
+			str_info->prev = STREAM_UN_INIT;
+			str_info->status = STREAM_INIT;
+			str_info->cumm_bytes = 0;
+			sst_send_sync_msg(IPC_IA_DROP_STREAM, str_id);
+		} else {
+			if (sst_create_ipc_msg(&msg, true))
+				return -ENOMEM;
+			str_info->prev = STREAM_UN_INIT;
+			str_info->status = STREAM_INIT;
+			str_info->cumm_bytes = 0;
+			pvt_id = sst_assign_pvt_id(sst_drv_ctx);
+			sst_fill_header_mrfld(&msg->mrfld_header, IPC_CMD,
+					      str_info->task_id, 1, pvt_id);
+
+			msg->mrfld_header.p.header_low_payload = sizeof(dsp_hdr);
+			sst_fill_header_dsp(&dsp_hdr, IPC_IA_DROP_STREAM_MRFLD,
+					str_info->pipe_id, 0);
+			memcpy(msg->mailbox_data, &dsp_hdr, sizeof(dsp_hdr));
+			trace_sst_stream("STOP  ->", str_id, str_info->pipe_id);
+			pr_info("Stop for str %d pipe %#x\n", str_id, str_info->pipe_id);
+
+			sst_drv_ctx->ops->sync_post_message(msg);
+		}
+	} else {
+		retval = -EBADRQC;
+		pr_debug("BADQRC for stream, state %x\n", str_info->status);
+	}
+	return retval;
+}
+
+/**
+ * sst_next_track: notify next track
+ * @str_id:		stream ID
+ *
+ * This function is called by any function which wants to
+ * set next track. Current this is NOP as FW doest care
+ */
+int sst_next_track(void)
+{
+	pr_debug("SST DBG: next_track");
+	return 0;
+}
+
+/**
+* sst_drain_stream - Send msg for draining stream
+* @str_id:		stream ID
+*
+* This function is called by any function which wants to drain
+* a stream.
+*/
+int sst_drain_stream(int str_id, bool partial_drain)
+{
+	int retval = 0, pvt_id, len;
+	struct ipc_post *msg = NULL;
+	struct stream_info *str_info;
+	struct intel_sst_ops *ops;
+	struct sst_block *block = NULL;
+	struct ipc_dsp_hdr dsp_hdr;
+
+	pr_debug("SST DBG:sst_drain_stream for %d\n", str_id);
+	str_info = get_stream_info(str_id);
+	if (!str_info)
+		return -EINVAL;
+	ops = sst_drv_ctx->ops;
+	if (str_info->status != STREAM_RUNNING &&
+		str_info->status != STREAM_INIT &&
+		str_info->status != STREAM_PAUSED) {
+			pr_err("SST ERR: BADQRC for stream = %d\n",
+				       str_info->status);
+			return -EBADRQC;
+	}
+
+	if (!sst_drv_ctx->use_32bit_ops) {
+		pvt_id = sst_assign_pvt_id(sst_drv_ctx);
+		retval = sst_create_block_and_ipc_msg(&msg, true,
+				sst_drv_ctx, &block, IPC_CMD, pvt_id);
+		if (retval)
+			return retval;
+		sst_fill_header_mrfld(&msg->mrfld_header, IPC_CMD,
+				str_info->task_id, 1, pvt_id);
+		pr_debug("header:%x\n",
+			(unsigned int)msg->mrfld_header.p.header_high.full);
+		msg->mrfld_header.p.header_high.part.res_rqd = 1;
+
+		len = sizeof(u8) + sizeof(dsp_hdr);
+		msg->mrfld_header.p.header_low_payload = len;
+		sst_fill_header_dsp(&dsp_hdr, IPC_IA_DRAIN_STREAM_MRFLD,
+					str_info->pipe_id, sizeof(u8));
+		memcpy(msg->mailbox_data, &dsp_hdr, sizeof(dsp_hdr));
+		memcpy(msg->mailbox_data + sizeof(dsp_hdr),
+				&partial_drain, sizeof(u8));
+		trace_sst_stream("DRAIN ->", str_id, str_info->pipe_id);
+	} else {
+		retval = sst_create_block_and_ipc_msg(&msg, false,
+				sst_drv_ctx, &block,
+				IPC_IA_DRAIN_STREAM, str_id);
+		if (retval)
+			return retval;
+		sst_fill_header(&msg->header, IPC_IA_DRAIN_STREAM, 0, str_id);
+		msg->header.part.data = partial_drain;
+	}
+	sst_add_to_dispatch_list_and_post(sst_drv_ctx, msg);
+	/* with new non blocked drain implementation in core we dont need to
+	 * wait for respsonse, and need to only invoke callback for drain
+	 * complete
+	 */
+
+	sst_free_block(sst_drv_ctx, block);
+	return retval;
+}
+
+/**
+ * sst_free_stream - Frees a stream
+ * @str_id:		stream ID
+ *
+ * This function is called by any function which wants to free
+ * a stream.
+ */
+int sst_free_stream(int str_id)
+{
+	int retval = 0;
+	unsigned int pvt_id;
+	struct ipc_post *msg = NULL;
+	struct stream_info *str_info;
+	struct intel_sst_ops *ops;
+	unsigned long irq_flags;
+	struct ipc_dsp_hdr dsp_hdr;
+	struct sst_block *block;
+
+	pr_debug("SST DBG:sst_free_stream for %d\n", str_id);
+
+	mutex_lock(&sst_drv_ctx->sst_lock);
+	if (sst_drv_ctx->sst_state == SST_RESET) {
+		mutex_unlock(&sst_drv_ctx->sst_lock);
+		return -ENODEV;
+	}
+	mutex_unlock(&sst_drv_ctx->sst_lock);
+	str_info = get_stream_info(str_id);
+	if (!str_info)
+		return -EINVAL;
+	ops = sst_drv_ctx->ops;
+
+	mutex_lock(&str_info->lock);
+	if (str_info->status != STREAM_UN_INIT) {
+		str_info->prev =  str_info->status;
+		str_info->status = STREAM_UN_INIT;
+		mutex_unlock(&str_info->lock);
+
+		if (!sst_drv_ctx->use_32bit_ops) {
+			pvt_id = sst_assign_pvt_id(sst_drv_ctx);
+			retval = sst_create_block_and_ipc_msg(&msg, true,
+					sst_drv_ctx, &block, IPC_CMD, pvt_id);
+			if (retval)
+				return retval;
+
+			sst_fill_header_mrfld(&msg->mrfld_header, IPC_CMD,
+					      str_info->task_id, 1, pvt_id);
+			msg->mrfld_header.p.header_low_payload =
+							sizeof(dsp_hdr);
+			sst_fill_header_dsp(&dsp_hdr, IPC_IA_FREE_STREAM_MRFLD,
+						str_info->pipe_id,  0);
+			memcpy(msg->mailbox_data, &dsp_hdr, sizeof(dsp_hdr));
+			trace_sst_stream("FREE  ->", str_id, str_info->pipe_id);
+			pr_info("Free for str %d pipe %#x\n", str_id, str_info->pipe_id);
+
+		} else {
+			retval = sst_create_block_and_ipc_msg(&msg, false,
+						sst_drv_ctx, &block,
+						IPC_IA_FREE_STREAM, str_id);
+			if (retval)
+				return retval;
+			sst_fill_header(&msg->header, IPC_IA_FREE_STREAM,
+								 0, str_id);
+		}
+		spin_lock_irqsave(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+		list_add_tail(&msg->node, &sst_drv_ctx->ipc_dispatch_list);
+		spin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+		if (!sst_drv_ctx->use_32bit_ops) {
+			/*FIXME: do we need to wake up drain stream here,
+			 * how to get the pvt_id and msg_id
+			 */
+		} else {
+			sst_wake_up_block(sst_drv_ctx, 0, str_id,
+				IPC_IA_DRAIN_STREAM, NULL, 0);
+		}
+		ops->post_message(&sst_drv_ctx->ipc_post_msg_wq);
+		retval = sst_wait_timeout(sst_drv_ctx, block);
+		pr_debug("sst: wait for free returned %d\n", retval);
+		mutex_lock(&sst_drv_ctx->stream_lock);
+		sst_clean_stream(str_info);
+		mutex_unlock(&sst_drv_ctx->stream_lock);
+		pr_debug("SST DBG:Stream freed\n");
+		sst_free_block(sst_drv_ctx, block);
+	} else {
+		mutex_unlock(&str_info->lock);
+		retval = -EBADRQC;
+		pr_debug("SST DBG:BADQRC for stream\n");
+	}
+
+	return retval;
+}
+
+int sst_request_vtsv_file(char *fname, struct intel_sst_drv *ctx,
+		void **out_file, u32 *out_size)
+{
+	int retval = 0;
+	const struct firmware *file;
+	void *ddr_virt_addr;
+	unsigned long file_base;
+
+	if (!ctx->pdata->lib_info) {
+		pr_err("lib_info pointer NULL\n");
+		return -EINVAL;
+	}
+
+	pr_debug("Requesting VTSV file %s now...\n", fname);
+	retval = request_firmware(&file, fname, ctx->dev);
+	if (file == NULL) {
+		pr_err("VTSV file is returning as null\n");
+		return -EINVAL;
+	}
+	if (retval) {
+		pr_err("request fw failed %d\n", retval);
+		return retval;
+	}
+
+	if ((*out_file == NULL) || (*out_size < file->size)) {
+		retval = sst_get_next_lib_mem(&ctx->lib_mem_mgr, file->size,
+			&file_base);
+		*out_file = (void *)file_base;
+	}
+	ddr_virt_addr = (unsigned char *)ctx->ddr +
+		(unsigned long)(*out_file - ctx->pdata->lib_info->mod_base);
+	memcpy(ddr_virt_addr, file->data, file->size);
+
+	*out_size = file->size;
+	release_firmware(file);
+	return 0;
+}
+
+int sst_format_vtsv_message(struct intel_sst_drv *ctx,
+	struct ipc_post **msgptr, struct sst_block **block)
+{
+	int retval = 0, pvt_id, len;
+	struct ipc_dsp_hdr dsp_hdr;
+	struct snd_sst_vtsv_info vinfo;
+	struct ipc_post *msg;
+
+	BUG_ON((unsigned long)(ctx->vcache.file1_in_mem) & 0xffffffff00000000ULL);
+	BUG_ON((unsigned long)(ctx->vcache.file2_in_mem) & 0xffffffff00000000ULL);
+
+	vinfo.vfiles[0].addr = (u32)((unsigned long)ctx->vcache.file1_in_mem
+				& 0xffffffff);
+	vinfo.vfiles[0].size = ctx->vcache.size1;
+	vinfo.vfiles[1].addr = (u32)((unsigned long)ctx->vcache.file2_in_mem
+				& 0xffffffff);
+	vinfo.vfiles[1].size = ctx->vcache.size2;
+
+	/* Create the vtsv message */
+	pvt_id = sst_assign_pvt_id(ctx);
+	retval = sst_create_block_and_ipc_msg(msgptr, true,
+			ctx, block, IPC_CMD, pvt_id);
+	if (retval)
+		return retval;
+	msg = *msgptr;
+	sst_fill_header_mrfld(&msg->mrfld_header, IPC_CMD,
+			SST_TASK_ID_AWARE, 1, pvt_id);
+	pr_debug("header:%x\n",
+			(unsigned int)msg->mrfld_header.p.header_high.full);
+	msg->mrfld_header.p.header_high.part.res_rqd = 1;
+
+	len = sizeof(vinfo) + sizeof(dsp_hdr);
+	msg->mrfld_header.p.header_low_payload = len;
+	sst_fill_header_dsp(&dsp_hdr, IPC_IA_VTSV_UPDATE_MODULES,
+				PIPE_VAD_OUT, sizeof(u8));
+	dsp_hdr.mod_id = SST_ALGO_VTSV;
+	memcpy(msg->mailbox_data, &dsp_hdr, sizeof(dsp_hdr));
+	memcpy(msg->mailbox_data + sizeof(dsp_hdr),
+			&vinfo, sizeof(vinfo));
+	return 0;
+}
+
+int sst_send_vtsv_data_to_fw(struct intel_sst_drv *ctx)
+{
+	int retval = 0;
+	struct ipc_post *msg = NULL;
+	struct sst_block *block = NULL;
+
+	/* Download both the data files */
+	retval = sst_request_vtsv_file("vtsv_net.bin", ctx,
+			&ctx->vcache.file1_in_mem, &ctx->vcache.size1);
+	if (retval) {
+		pr_err("vtsv data file1 request failed %d\n", retval);
+		return retval;
+	}
+
+	retval = sst_request_vtsv_file("vtsv_grammar.bin", ctx,
+			&ctx->vcache.file2_in_mem, &ctx->vcache.size2);
+	if (retval) {
+		pr_err("vtsv data file2 request failed %d\n", retval);
+		return retval;
+	}
+
+	retval = sst_format_vtsv_message(ctx, &msg, &block);
+	if (retval) {
+		pr_err("vtsv msg format failed %d\n", retval);
+		return retval;
+	}
+	sst_add_to_dispatch_list_and_post(ctx, msg);
+	retval = sst_wait_timeout(ctx, block);
+	if (retval)
+		pr_err("vtsv msg send to fw failed %d\n", retval);
+
+	sst_free_block(ctx, block);
+	return retval;
+}
diff --git a/sound/soc/intel/sst/sst_trace.h b/sound/soc/intel/sst/sst_trace.h
new file mode 100644
index 0000000..6ff2f95
--- /dev/null
+++ b/sound/soc/intel/sst/sst_trace.h
@@ -0,0 +1,143 @@
+/*
+ *  sst_trace.h - Intel SST Driver tracing support
+ *
+ *  Copyright (C) 2013	Intel Corp
+ *  Authors: Omair Mohammed Abdullah <omair.m.abdullah@linux.intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM sst
+
+#if !defined(_TRACE_SST_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_SST_H
+
+#include <linux/types.h>
+#include <linux/ktime.h>
+#include <linux/tracepoint.h>
+
+TRACE_EVENT(sst_ipc,
+
+	TP_PROTO(const char *msg, u32 header_high, u32 header_low, int pvt_id),
+
+	TP_ARGS(msg, header_high, header_low, pvt_id),
+
+	TP_STRUCT__entry(
+		__string(info_msg,	msg)
+		__field(unsigned int,	val_l)
+		__field(unsigned int,	val_h)
+		__field(unsigned int,	id)
+	),
+
+	TP_fast_assign(
+		__assign_str(info_msg, msg);
+		__entry->val_l = header_low;
+		__entry->val_h = header_high;
+		__entry->id = pvt_id;
+	),
+
+	TP_printk("\t%s\t [%2u] = %#8.8x:%.4x", __get_str(info_msg),
+		  (unsigned int)__entry->id,
+		  (unsigned int)__entry->val_h, (unsigned int)__entry->val_l)
+
+);
+
+TRACE_EVENT(sst_stream,
+
+	TP_PROTO(const char *msg, int str_id, int pipe_id),
+
+	TP_ARGS(msg, str_id, pipe_id),
+
+	TP_STRUCT__entry(
+		__string(info_msg,	msg)
+		__field(unsigned int,	str_id)
+		__field(unsigned int,	pipe_id)
+	),
+
+	TP_fast_assign(
+		__assign_str(info_msg, msg);
+		__entry->str_id = str_id;
+		__entry->pipe_id = pipe_id;
+	),
+
+	TP_printk("\t%s\t str  = %2u, pipe = %#x", __get_str(info_msg),
+		  (unsigned int)__entry->str_id, (unsigned int)__entry->pipe_id)
+);
+
+TRACE_EVENT(sst_ipc_mailbox,
+
+	TP_PROTO(const char *mailbox, int mbox_len),
+
+	TP_ARGS(mailbox, mbox_len),
+
+	TP_STRUCT__entry(
+		__dynamic_array(char,	mbox,	(3 * mbox_len))
+	),
+
+	TP_fast_assign(
+		sst_dump_to_buffer(mailbox, mbox_len,
+				   __get_dynamic_array(mbox));
+	),
+
+	TP_printk("  %s", __get_str(mbox))
+
+);
+
+TRACE_EVENT(sst_lib_download,
+
+	TP_PROTO(const char *msg, const char *lib_name),
+
+	TP_ARGS(msg, lib_name),
+
+	TP_STRUCT__entry(
+		__string(info_msg, msg)
+		__string(info_lib_name, lib_name)
+	),
+
+	TP_fast_assign(
+		__assign_str(info_msg, msg);
+		__assign_str(info_lib_name, lib_name);
+	),
+
+	TP_printk("\t%s %s", __get_str(info_msg),
+			__get_str(info_lib_name))
+);
+
+TRACE_EVENT(sst_fw_download,
+
+	TP_PROTO(const char *msg, int fw_state),
+
+	TP_ARGS(msg, fw_state),
+
+	TP_STRUCT__entry(
+		__string(info_msg, msg)
+		__field(unsigned int,   fw_state)
+	),
+
+	TP_fast_assign(
+		__assign_str(info_msg, msg);
+		__entry->fw_state = fw_state;
+	),
+
+	TP_printk("\t%s\tFW state = %d", __get_str(info_msg),
+				(unsigned int)__entry->fw_state)
+);
+
+#endif /* _TRACE_SST_H */
+
+/* This part must be outside protection */
+#undef TRACE_INCLUDE_PATH
+#define TRACE_INCLUDE_PATH .
+#define TRACE_INCLUDE_FILE sst_trace
+#include <trace/define_trace.h>
diff --git a/sound/soc/intel/sst_platform.h b/sound/soc/intel/sst_platform.h
new file mode 100644
index 0000000..b61a00c
--- /dev/null
+++ b/sound/soc/intel/sst_platform.h
@@ -0,0 +1,151 @@
+/*
+ *  sst_platform.h - Intel MID Platform driver header file
+ *
+ *  Copyright (C) 2010 Intel Corp
+ *  Author: Vinod Koul <vinod.koul@intel.com>
+ *  Author: Harsha Priya <priya.harsha@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *
+ */
+
+#ifndef __SST_PLATFORM_H__
+#define __SST_PLATFORM_H__
+
+#include <sound/soc.h>
+
+#define SST_MAX_BIN_BYTES 1024
+
+struct sst_data;
+
+enum sst_audio_device_type {
+	SND_SST_DEVICE_HEADSET = 1,
+	SND_SST_DEVICE_IHF,
+	SND_SST_DEVICE_VIBRA,
+	SND_SST_DEVICE_HAPTIC,
+	SND_SST_DEVICE_CAPTURE,
+	SND_SST_DEVICE_COMPRESS,
+};
+
+enum snd_sst_input_stream {
+	SST_INPUT_STREAM_NONE = 0x0,
+	SST_INPUT_STREAM_PCM = 0x6,
+	SST_INPUT_STREAM_COMPRESS = 0x8,
+	SST_INPUT_STREAM_MIXED = 0xE,
+};
+
+enum sst_stream_ops {
+	STREAM_OPS_PLAYBACK = 0,        /* Decode */
+	STREAM_OPS_CAPTURE,             /* Encode */
+	STREAM_OPS_COMPRESSED_PATH,     /* Offload playback/capture */
+
+};
+enum snd_sst_stream_type {
+	SST_STREAM_DEVICE_HS = 32,
+	SST_STREAM_DEVICE_IHF = 33,
+	SST_STREAM_DEVICE_MIC0 = 34,
+	SST_STREAM_DEVICE_MIC1 = 35,
+};
+
+enum sst_controls {
+	SST_SND_ALLOC =			0x1000,
+	SST_SND_PAUSE =			0x1001,
+	SST_SND_RESUME =		0x1002,
+	SST_SND_DROP =			0x1003,
+	SST_SND_FREE =			0x1004,
+	SST_SND_BUFFER_POINTER =	0x1005,
+	SST_SND_STREAM_INIT =		0x1006,
+	SST_SND_START	 =		0x1007,
+	SST_SET_RUNTIME_PARAMS =	0x1008,
+	SST_SET_ALGO_PARAMS =		0x1009,
+	SST_SET_BYTE_STREAM =		0x100A,
+	SST_GET_BYTE_STREAM =		0x100B,
+	SST_SET_SSP_CONFIG =		0x100C,
+	SST_SET_PROBE_BYTE_STREAM =     0x100D,
+	SST_GET_PROBE_BYTE_STREAM =	0x100E,
+	SST_SET_VTSV_INFO =		0x100F,
+};
+
+struct pcm_stream_info {
+	int str_id;
+	void *mad_substream;
+	void (*period_elapsed) (void *mad_substream);
+	unsigned long long buffer_ptr;
+	unsigned long long pcm_delay;
+	int sfreq;
+};
+
+struct sst_compress_cb {
+	void *param;
+	void (*compr_cb)(void *param);
+	void *drain_cb_param;
+	void (*drain_notify)(void *param);
+
+};
+
+struct snd_sst_params;
+
+struct compress_sst_ops {
+	const char *name;
+	int (*open) (struct snd_sst_params *str_params,
+			struct sst_compress_cb *cb);
+	int (*control) (unsigned int cmd, unsigned int str_id);
+	int (*tstamp) (unsigned int str_id, struct snd_compr_tstamp *tstamp);
+	int (*ack) (unsigned int str_id, unsigned long bytes);
+	int (*close) (unsigned int str_id);
+	int (*get_caps) (struct snd_compr_caps *caps);
+	int (*get_codec_caps) (struct snd_compr_codec_caps *codec);
+	int (*set_metadata) (unsigned int str_id, struct snd_compr_metadata *metadata);
+
+};
+
+enum lpe_param_types_mixer {
+	SST_ALGO_PARAM_MIXER_STREAM_CFG = 0x801,
+};
+
+struct mad_ops_wq {
+	int stream_id;
+	enum sst_controls control_op;
+	struct work_struct wq;
+};
+
+struct sst_ops {
+	int (*open) (struct snd_sst_params *str_param);
+	int (*device_control) (int cmd, void *arg);
+	int (*set_generic_params) (enum sst_controls cmd, void *arg);
+	int (*close) (unsigned int str_id);
+	int (*power) (bool state);
+};
+
+struct sst_runtime_stream {
+	int     stream_status;
+	unsigned int id;
+	size_t bytes_written;
+	struct pcm_stream_info stream_info;
+	struct sst_ops *ops;
+	struct compress_sst_ops *compr_ops;
+	spinlock_t	status_lock;
+};
+
+struct sst_device {
+	char *name;
+	struct device *dev;
+	struct sst_ops *ops;
+	struct platform_device *pdev;
+	struct compress_sst_ops *compr_ops;
+};
+
+int sst_register_dsp(struct sst_device *sst);
+int sst_unregister_dsp(struct sst_device *sst);
+#endif
diff --git a/sound/soc/intel/sst_platform_pvt.h b/sound/soc/intel/sst_platform_pvt.h
new file mode 100644
index 0000000..4671cb8
--- /dev/null
+++ b/sound/soc/intel/sst_platform_pvt.h
@@ -0,0 +1,141 @@
+/*
+ *  sst_platform_pvt.h - Intel MID Platform driver header file
+ *
+ *  Copyright (C) 2010 Intel Corp
+ *  Author: Vinod Koul <vinod.koul@intel.com>
+ *  Author: Harsha Priya <priya.harsha@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *
+ */
+
+#ifndef __SST_PLATFORM_PVT_H__
+#define __SST_PLATFORM_PVT_H__
+
+/* TODO rmv this global */
+extern struct sst_device *sst_dsp;
+
+#define SST_MONO		1
+#define SST_STEREO		2
+
+#define SST_MIN_RATE		8000
+#define SST_MAX_RATE		48000
+#define SST_MIN_CHANNEL		1
+#define SST_MAX_CHANNEL		2
+
+#define SST_MAX_BUFFER		96000 /*500ms@48K,16bit,2ch - CLV*/
+#define SST_MIN_PERIOD_BYTES	1536  /*24ms@16K,16bit,2ch - For VoIP on Mrfld*/
+#define SST_MAX_PERIOD_BYTES	48000 /*250ms@48K,16bit,2ch - CLV*/
+
+#define SST_MIN_PERIODS		2
+#define SST_MAX_PERIODS		50
+#define SST_FIFO_SIZE		0
+#define SST_CODEC_TYPE_PCM	1
+
+#define SST_HEADSET_DAI		"Headset-cpu-dai"
+#define SST_SPEAKER_DAI		"Speaker-cpu-dai"
+#define SST_VOICE_DAI		"Voice-cpu-dai"
+#define SST_VIRTUAL_DAI		"Virtual-cpu-dai"
+#define SST_LOOPBACK_DAI	"Loopback-cpu-dai"
+#define SST_POWER_DAI		"Power-cpu-dai"
+#define SST_COMPRESS_DAI	"Compress-cpu-dai"
+#define SST_PROBE_DAI		"Probe-cpu-dai"
+#define SST_VOIP_DAI		"Voip-cpu-dai"
+#define SST_DEEPBUFFER_DAI	"Deepbuffer-cpu-dai"
+#define SST_LOWLATENCY_DAI	"Lowlatency-cpu-dai"
+
+struct sst_device;
+
+enum sst_drv_status {
+	SST_PLATFORM_UNINIT,
+	SST_PLATFORM_INIT,
+	SST_PLATFORM_RUNNING,
+	SST_PLATFORM_PAUSED,
+	SST_PLATFORM_DROPPED,
+};
+
+enum ssp_port {
+	SST_SSP_PORT0 = 0,
+	SST_SSP_PORT1,
+	SST_SSP_PORT2,
+	SST_SSP_PORT3,
+};
+
+#define SST_PIPE_CONTROL	0x0
+#define SST_COMPRESS_VOL	0x01
+
+int sst_platform_clv_init(struct snd_soc_platform *platform);
+int sst_dsp_init(struct snd_soc_platform *platform);
+int sst_dsp_init_v2_dpcm(struct snd_soc_platform *platform);
+int sst_send_pipe_gains(struct snd_soc_dai *dai, int stream, int mute);
+void send_ssp_cmd(struct snd_soc_platform *platform, const char *id, bool enable);
+void sst_handle_vb_timer(struct snd_soc_platform *platform, bool enable);
+
+unsigned int sst_soc_read(struct snd_soc_platform *platform, unsigned int reg);
+int sst_soc_write(struct snd_soc_platform *platform, unsigned int reg, unsigned int val);
+unsigned int sst_reg_read(struct sst_data *sst, unsigned int reg,
+			  unsigned int shift, unsigned int max);
+unsigned int sst_reg_write(struct sst_data *sst, unsigned int reg,
+			   unsigned int shift, unsigned int max, unsigned int val);
+
+int sst_algo_int_ctl_info(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo);
+void sst_set_stream_status(struct sst_runtime_stream *stream, int state);
+int sst_fill_stream_params(void *substream, const struct sst_data *ctx,
+			   struct snd_sst_params *str_params, bool is_compress);
+int sst_dpcm_probe_send(struct snd_soc_platform *platform, u16 probe_pipe,
+			int substream, int direction, bool on);
+int sst_byte_control_get(struct snd_kcontrol *kcontrol,
+			 struct snd_ctl_elem_value *ucontrol);
+int sst_byte_control_set(struct snd_kcontrol *kcontrol,
+			 struct snd_ctl_elem_value *ucontrol);
+
+struct sst_algo_int_control_v2 {
+	struct soc_mixer_control mc;
+	u16 module_id; /* module identifieer */
+	u16 pipe_id; /* location info: pipe_id + instance_id */
+	u16 instance_id;
+	unsigned int value; /* Value received is stored here */
+};
+
+struct sst_lowlatency_deepbuff {
+	/* Thresholds for low latency & deep buffer */
+	unsigned long	*low_latency;
+	unsigned long	*deep_buffer;
+	unsigned long	period_time;
+};
+
+struct sst_pcm_format {
+	unsigned int sample_bits;
+	unsigned int rate_min;
+	unsigned int rate_max;
+	unsigned int channels_min;
+	unsigned int channels_max;
+};
+
+
+struct sst_data {
+	struct platform_device *pdev;
+	struct sst_platform_data *pdata;
+	unsigned int lpe_mixer_input_ihf;
+	unsigned int lpe_mixer_input_hs;
+	u32 *widget;
+	char *byte_stream;
+	struct mutex lock;
+	/* Pipe_id for probe_stream to be saved in stream map */
+	u8 pipe_id;
+	bool vtsv_enroll;
+	struct sst_lowlatency_deepbuff ll_db;
+};
+#endif
-- 
1.9.3

